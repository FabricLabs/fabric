./whitepaper-2015.md:### TODO: include content hashes of links as they appear at document compilation time.
./constants.js:const LARGE_COLLECTION_SIZE = 10; // TODO: test with 1,000,000
./constants.js:const P2P_INSTRUCTION = 0x00000020; // TODO: select w/ no overlap
./constants.js:const P2P_STATE_REQUEST = 0x00000029; // TODO: select w/ no overlap
./constants.js:const P2P_STATE_ROOT = 0x00000030; // TODO: select w/ no overlap
./constants.js:const P2P_BASE_MESSAGE = 0x00000031; // TODO: select w/ no overlap
./constants.js:const P2P_STATE_COMMITTMENT = 0x00000032; // TODO: select w/ no overlap
./constants.js:const P2P_STATE_CHANGE = 0x00000033; // TODO: select w/ no overlap
./constants.js:const P2P_TRANSACTION = 0x00000039; // TODO: select w/ no overlap
./constants.js:// TODO: should be 0x02 for Bitcoin P2P
./snippets/specification.md:// TODO: migrate script
./types/witness.js:      // TODO: assign R coordinate
./types/witness.js:      // TODO: assign S coordinate
./types/channel.js:    // TODO: remove short-circuit
./types/interface.js:    // TODO: remove these... ~E
./types/interface.js:    // TODO: use Layer
./types/interface.js:    // TODO: apply `transaction.operations` to Interface state
./types/interface.js:      // TODO: document why @input is removed
./types/scribe.js:    // TODO: enable
./types/key.js:// TODO: replace with bcoin
./types/key.js:// TODO: remove all external dependencies
./types/key.js:    // TODO: determine if this makes sense / needs to be private
./types/chain.js:    // TODO: set this up via define?
./types/chain.js:    // TODO: define all state transitions
./types/remote.js:    // TODO: use onion address for secure mode
./types/remote.js:    // TODO: break out into independent auth module
./types/renderer.js:    // TODO: move this to dynamic event handler
./types/swap.js:// TODO: revert to 1.0.2 to enable
./types/stash.js:// TODO: note that generally, requirements are loosely ordered by
./types/message.js:    // TODO: Node 12
./types/message.js:      // TODO: eliminate this type
./types/message.js:      // TODO: document Generic type
./types/message.js:      // TODO: restore this type
./types/message.js:      // TODO: restore above StateRoot type
./types/session.js:  // TODO: implement
./types/session.js:  // TODO: implement
./types/resource.js:      list: `/${this.names[1].toLowerCase()}`, // TODO: unpin, offer larger name list
./types/service.js:      // TODO: export this as the default data in `inputs/fabric.json`
./types/service.js:    // TODO: fix this
./types/service.js:    // TODO: re-re-evaluate a better approach... oh how I long for Object.observe!
./types/service.js:    // TODO: use Resource definition to de-deuplicate by fields.id
./types/service.js:    // TODO: reduce storage to references
./types/service.js:    // TODO: implement a basic Stream
./types/service.js:      // TODO: add robust + convenient database opener
./types/service.js:          // TODO: notify status?
./types/service.js:      // TODO: allow configurable validators
./types/service.js:        // TODO: update this in constructor
./types/promise.js:    // TODO: make private
./types/promise.js:    // TODO: formalize type
./types/promise.js:    // TODO: encrypt state
./types/promise.js:    // TODO: recover state
./types/swarm.js:      // TODO: define seed list
./types/swarm.js:    // TODO: consider renaming this to JOIN
./types/swarm.js:    // TODO: store timers globally (ConnectionManager?)
./types/swarm.js:    // TODO: exponential backoff for reconnections
./types/swarm.js:      // TODO: use `slots` from above
./types/store.js:// TODO: note that generally, requirements are loosely ordered by
./types/store.js:    let secret = value; // TODO: encrypt value
./types/store.js:    let decrypted = secret; // TODO: decrypt value
./types/store.js:      // TODO: store metadata
./types/store.js:    // TODO: check for commit state
./types/store.js:    // TODO: use ._GET
./types/store.js:      // TODO: document the special case of "null"
./types/store.js:    // TODO: make work for single instance deletes
./types/store.js:        // TODO: document verbosity 6
./types/store.js:    // TODO: document re-opening of store
./types/fabric.js:    // TODO: remove this
./types/fabric.js:    // TODO: select random function
./types/fabric.js:    // TODO: remove lodash
./types/fabric.js:        path: source.name + patch.path // TODO: check in Vector Machine that this is safe
./types/compiler.js:// TODO: rewrite these / use lexical parser
./types/compiler.js:// TODO: have Lexer review
./types/compiler.js:// TODO: render the following:
./types/compiler.js:  // TODO: @melnx to refactor into f(x) => y
./types/vector.js:  // TODO: standardize on a serialization format
./types/vector.js:    // TODO: standardize on a serialization format
./types/circuit.js:    // TODO: generate polynomial for circuit
./types/bitcoin/block.js:    // TODO: validation
./types/hash256.js:  // TODO: document `hash256.value`
./types/oracle.js:    // TODO: define all resources
./types/oracle.js:    // TODO: pre-populate
./types/router.js:// TODO: re-define this class for Fabric messages
./types/router.js:            // TODO: remove this.fabric.plugins call
./types/mempool.js:    // TODO: compare target.id and entity.id
./types/wallet.js:// TODO: most of these should be converted to use Consensus,
./types/wallet.js:    // TODO: enable wordlist translations
./types/wallet.js:    // TODO: remove these
./types/wallet.js:    // TODO: bind @fabric/core/services/bitcoin to addresses on wallet...
./types/wallet.js:    // TODO: update channels
./types/wallet.js:    // TODO: parse as {@link Message}
./types/wallet.js:    // TODO: store in this.messages
./types/wallet.js:        // TODO: validate destination is this wallet
./types/wallet.js:      // TODO: process transaction
./types/wallet.js:    // TODO: check that `txid` is a proper TXID
./types/wallet.js:      // TODO: test these outputs
./types/wallet.js:      // TODO: remove this audit message
./types/wallet.js:    // TODO: use coin selection
./types/wallet.js:    // TODO: use the MTX to select outputs
./types/wallet.js:    // TODO: use Fabric.Script
./types/wallet.js:    // TODO: remove short-circuit
./types/wallet.js:    // TODO: complete order construction
./types/wallet.js:      // TODO: should be split parts
./types/wallet.js:    // TODO: remove short-circuit
./types/wallet.js:      // TODO: replace this with a randomly-generated input
./types/wallet.js:    // TODO: remove short-circuit
./types/wallet.js:    // TODO: complete order construction
./types/wallet.js:      // TODO: should be split parts
./types/wallet.js:    // TODO: labeled keypairs
./types/wallet.js:      rate: 10000, // TODO: fee calculation
./types/wallet.js:    // TODO: labeled keypairs
./types/wallet.js:      rate: 10000, // TODO: fee calculation
./types/wallet.js:    // TODO: return a full object for Fabric
./types/wallet.js:    // TODO: restore swap code, abstract input types
./types/wallet.js:    // TODO: use Satoshis for all calculations
./types/wallet.js:    // TODO: remove all fake coinbases
./types/wallet.js:    // TODO: remove all short-circuits
./types/wallet.js:    // TODO: remove short-circuit
./types/wallet.js:    // TODO: remove entirely, test short-circuit removal
./types/wallet.js:    // TODO: wallet._getSpendableOutput()
./types/wallet.js:    // TODO: allow override of wallet name
./types/wallet.js:    // TODO: load available outputs from wallet
./types/wallet.js:      // TODO: fee estimation
./types/wallet.js:      // TODO: fee estimation
./types/wallet.js:    // TODO: load available outputs from wallet
./types/wallet.js:      // TODO: fee estimation
./types/wallet.js:      // TODO: restore address tracking in state
./types/wallet.js:      // TODO: check on above events, should be more like...
./types/wallet.js:    // TODO: allow override of wallet name
./types/wallet.js:    // TODO: also retrieve key for address
./types/wallet.js:    // TODO: label as identity address
./types/wallet.js:    // TODO: notify downstream of short-circuit removal
./types/state.js:    // TODO: test and document memory alignment
./types/state.js:    // TODO: re-enable
./types/state.js:    // TODO: document hidden properties
./types/state.js:    // TODO: re-enable the below, map security considerations
./types/state.js:      // TODO: order?
./types/keystore.js:        // TODO: recursively cast { type, data } tuples as Buffer
./types/secret.js:    // TODO: check and document upstream pattern
./types/cli.js:// TODO: use Jade to render pre-registered components
./types/cli.js:    // TODO: test this on testnet / mainnet
./types/cli.js:      // TODO: use peer ID for managed list
./types/cli.js:    // TODO: clean up workaround (from https://github.com/chjj/blessed/issues/109)
./types/consensus.js:    // TODO: define class ConsensusProvider
./types/consensus.js:  // TODO: remove from {@link Consensus}
./types/consensus.js:      // TODO: compute from chain height
./types/machine.js:      seed: 1 // TODO: select seed for production
./types/peer.js:        // TODO: parse as encrypted data
./types/peer.js:    // TODO: document wallet settings
./types/peer.js:    // TODO: add getters for these
./types/peer.js:    // TODO: use Proxy
./types/peer.js:          // TODO: notify remote peer of closure
./types/peer.js:  // TODO: use in _connect
./types/peer.js:    // TODO: consolidate with similar _handleConnection segment
./types/peer.js:    // TODO: check peer ID, eject if self or known
./types/peer.js:    // TODO re-enable (disabled to reduce spammy messaging)
./types/peer.js:    // TODO: re-evaluate use of IdentityRequest
./types/peer.js:    // TODO: actually decrypt packet
./types/peer.js:    // TODO: refactor to use local functions + specific unbindings
./types/peer.js:        // TODO: consider using `process.nextTick` to only clean up after event?
./types/peer.js:      // TODO: unify as _dataHandler
./types/peer.js:      // TODO: replace with handshake
./types/peer.js:    // TODO: use known key
./types/peer.js:    // TODO: document peer announcement
./types/peer.js:    // TODO: eliminate use of JSON in messaging
./types/peer.js:          // TODO: remove in favor of StartSession
./types/peer.js:        // TODO: use packet's peer ID, not socket address
./types/peer.js:        // TODO: avoid using JSON in overall protocol
./types/peer.js:        // TODO: validate signature
./types/peer.js:        // TODO: restore session identity
./types/peer.js:          // TODO: document peer registration process
./types/peer.js:          // TODO: use message type for next phase of session (i.e., NOISE)
./types/peer.js:        // TODO: test protocol flow (i.e., understand StateRoot)
./types/peer.js:        // TODO: use Fabric.Script / Fabric.Machine
./types/peer.js:      // TODO: select type byte for state updates
./types/peer.js:      // TODO: require `Message` type before broadcast (or, preferrably, cast as necessary)
./types/peer.js:      // TODO: select type byte for state updates
./types/peer.js:      // TODO: require `Message` type before broadcast (or, preferrably, cast as necessary)
./types/peer.js:      // TODO: select type byte for state updates
./types/entity.js:    // TODO: use getters/setters to restrict access to these elements
./types/entity.js:        // TODO: write up longer-form explanation as to why we use an Array here
./types/collection.js:    // TODO: document `listeners` handler (currently only `create`)
./types/collection.js:      // TODO: document determinism
./types/collection.js:      // TODO: fix bug here (check for symbol)
./types/collection.js:  // TODO: deep search, consider GraphQL (!!!: to discuss)
./types/collection.js:    // TODO: enable upstream specification via pure JSON
./types/collection.js:    // TODO: validation of result by calling result.validate()
./types/collection.js:    // TODO: signing of result by calling result.signWith()
./types/collection.js:    // TODO: `list()` should return an Array
./types/collection.js:    // TODO: `list()` should return an Array
./types/collection.js:    // TODO: enable specifying names (again)
./types/collection.js:    // TODO: handle duplicates (when desired, i.e., "unique" in settings)
./types/collection.js:    // TODO: ensure updates sent on subscriber channels
./types/collection.js:    // TODO: test upstream attack vectors
./types/app.js:      // TODO: decide on resource['@data'] vs. resource (new)
./types/layer.js:    // TODO: describe state-passing for key
./types/stack.js:    // TODO: return Transaction
./TODO.txt:# TODO
./contracts/exchange.js:  // TODO: reconcile API wth @fabric/doorman as appears at: https://github.com/FabricLabs/doorman
./contracts/chat.js:  // TODO: reconcile API wth @fabric/doorman as appears at: https://github.com/FabricLabs/doorman
./tests/fabric.interface.js:      // TODO: remove this case / rework messages
./tests/fabric.remote.js:    // TODO: fix local options
./tests/fabric.tree.js:      assert.strictEqual(tree.root.toString('hex'), ''); // TODO: wat?
./tests/fabric.tree.js:      assert.strictEqual(tree.root.toString('hex'), '906b5aaf65ae98f8c98848de5e81ba865659f16fd53aefa4c78b34176f068079'); // TODO: wat?
./tests/fabric.core.js:// TODO: write parser for comments
./tests/fabric.core.js:  // TODO: implement polyfill for browserland
./tests/fabric.weave.js:      assert.strictEqual(weave._state.root, '906b5aaf65ae98f8c98848de5e81ba865659f16fd53aefa4c78b34176f068079'); // TODO: wat?
./tests/fabric.machine.js:      // TODO: use Fabric itself
./tests/fabric.machine.js:      // TODO: use Fabric instead of Fabric.Machine
./tests/fabric.router.js:// TODO: test class/function middleware
./tests/fabric.stack.js:      // TODO: move to constants, verify
./tests/fabric.stack.js:      // TODO: migrate to Stack
./tests/fabric.wallet.js:        // TODO: replace with fixture
./tests/fixtures/lightning.js:// TODO: test same as before
./package.json:    "review:todo": "grep --exclude-dir=.git --exclude-dir=node_modules --exclude-dir=reports --exclude-dir=coverage --exclude-dir=docs -rEI \"TODO|FIXME\" . 2>/dev/null > reports/TODO.txt",
./examples/bitcoin.js:  // TODO: import these into core process logic
./examples/game.js:    // TODO: use fabric call
./examples/swarm.html:          <p>TODO: create entities on seed node
./examples/swarm.html:            TODO: receive entities from seed node
./examples/swarm.html:            TODO: create entities on swarm instance</p>
./examples/bitcoin.html:          <p>TODO: import these into core process logic
./examples/service.js:      // TODO: revert to OPTIONS (this was a temporary fix for an NGINX bug)
./examples/swarm.js:  // TODO: create entities on seed node
./examples/swarm.js:  // TODO: receive entities from seed node
./examples/swarm.js:  // TODO: create entities on swarm instance
./examples/oracle.html:          <p>TODO: use bottom panel for inline execution (<em>a la</em> “Run this Code &raquo;”)</p>
./examples/oracle.js:// TODO: use bottom panel for inline execution (_a la_ "Run this Code &raquo;")
./examples/service.html:          <p>TODO: revert to OPTIONS (this was a temporary fix for an NGINX bug)</p>
./examples/game.html:          <p>TODO: use fabric call
./examples/blockchain.html:          <p>TODO: disconnect peers</p>
./examples/blockchain.js:      // TODO: disconnect peers
./scripts/example.js:// TODO: generate signature, hash of function definition (the "type")
./scripts/cli.js:  // TODO: read & test contracts
./scripts/cli.js:      // TODO: remove from log output...
./scripts/cli.js:      // TODO: replicate this program in C / ASM
./scripts/chat.js:  // TODO: remove Wallet-specfic configuration
./scripts/chat.js:      // TODO: reconcile API wth @fabric/doorman as appears at: https://github.com/FabricLabs/doorman
./scripts/chat.js:      // TODO: remove from log output...
./scripts/chat.js:      // TODO: replicate this program in C / ASM
./_book/TODO.txt:# TODO
./_book/search_index.json:{"index":{"version":"0.5.12","fields":[{"name":"title","boost":10},{"name":"keywords","boost":15},{"name":"body","boost":1}],"ref":"url","documentStore":{"store":{"./":["#learn","(#fabric","(http)","(message)","=","@data","@fabric/cor","@fabric/doorman","@fabric/http","@fabric/soundtrack","@fabricprotocol","@type","actor","add","agreements,","alreadi","any.","api","app","applic","application.","applications.","approach","artifici","assist","avail","base","befor","best","brows","browser","browser.","built","bundle,","channel,","cli","clone","code,","collabor","collect","command","common","complet","components,","conjur","console.log('receiv","const","contain","content","core,","creat","current","decentr","deploy","describ","descript","dev","develop","direct","distribut","doc","docs,","document","documentation.","documents.","doorman,","downstream","dure","eager","edit","educ","empass","enabl","environments,","establish","event","event,","event.","eventemitt","exampl","examples,","examples.","execut","experiment","expos","extens","fabric","fabric();","fabric,","fabric.min.j","fabric.on('message',","fabric.start();","fabric:',","familiar","feel","file","financi","follows:","fork","framework","framework,","freenode)","full","function","game","gener","get","github","goals.","great","head","help","here","html","http","http.","hyperledg","ibm","idl","idlerpg,","implement","includ","including:","instal","instanc","integr","intellig","interact","interest","interfac","internet","introduct","it'","jukebox","launch","learn","legaci","librari","line","link","list,","local","localhost","messag","message);","method","model,","more","more.","name","net","network","network.","new","node","node.","now","npm","offer","offici","on","onc","over","packag","pass","pattern,","peer","place","pleas","plugin","plugins.","primari","proce","product","project","properties:","prototyp","provid","public","publish","python","rapid","read","readi","recommend","refer","releas","remain","repositori","requir","require('@fabric/core');","research","retriev","reward","risk.","robust","rpg","run","save","secur","see","serv","server","servic","set","sever","simpl","simul","soundtrack.io,","sourc","source.","start","started,","state.","statu","subscrib","success","support","technology.","them,","thing","things,","tool","transactions.","tri","twitter","twitter:","type","type.","univers","unrel","up","up!","us","varieti","verse,","view","virtual","wait","way","web","webs.","well","work.","you'r","you.","{","});","🚨","🤔"],"QUICKSTART.html":["#1","'1cxabhxmiynpgz2k2gnprxy6bncnkvoegw',","'1l3lyapmhfuhldtsjzw77bsqhzc5esx9qf',","'default',","'main',","'pubkeyhash',","'quick","'wltttuqamtxmrip33glf1bn2js5heswxhehe',","'xpub6cn1n6iwapyrqod4ss9sx4i2flmdz4zswb5nulg6dgcnxmvikaork3kfrihqrqlspintdmvhgj7ff1lmlidcvemf8kphsx51cjbtztcqidu',","()","(above)","(optional)","0,","1,","10,","12.16","3","=","=>",">","@fabric/cor","[]","[audit]","account:","accountindex:","accountkey:","async","await","bitcoin","bitcoin({","bitcoin.start();","changeaddress:","changedepth:","code:","console.error('[quickstart]',","const","core:","creat","develop","exception);","fabric","failed:',","false,","file","finally,","follow","function","gener","hd","https://nvm.sh","id:","initialized:","instal","instead.","instruct","key","keys:","lookahead:","m:","main","main().catch((exception)","martindale/fabric#fabr","match","meet","n:","name:","nestedaddress:","nesteddepth:","network:","new","node","note:","npm","null,","nvm:","output","prerequisit","program","program:","quick","quickstart","receiveaddress:","receivedepth:","releases,","require('@fabric/core/services/bitcoin');","run","sampl","save","scripts/quickstart.j","see","start","true,","type:","us","verbosity:","verifi","version","wallet","wallet...","watchonly:","wid:","witness:","{","}","});","👀"],"API.html":["\"bitcoin\"","\"chaincode\".","\"fulfil","\"genesis\"","\"in","\"initialization\"","\"key\"","\"localhost\".","\"map\"","\"name\"","\"scribe\"","\"service\"","\"step\"","\"symbol\"","\"threads\",","\"type\",","\"value\"","$btc","'deadbeef...'","(\"commands\")","(4096","(===","(a","(address:port).","(all","(and","(ast).","(audit)","(block","(cli)","(debug),","(error),","(hkdf),","(key","(max","(none),","(notice),","(satoshis).","(side","(warning),","(will","*","*inspect","...input","._connectspv()","._createcrowdfund(fund)","._define(dir,","._delete(path,","._downsample([input])","._explore(path,","._fromjavascript(body)","._get(path)","._get(path,","._getjavascriptast(input)","._getrefundinputscript(redeemscript)","._getswapinputscript(redeemscript,","._handleblockfromspv(msg)","._handlecommittedblock(block)","._handlepeerpacket(msg)","._handletransactionfromspv(tx)","._load(settings)","._options(path,","._patch(path,","._patchtarget(path,","._post(key,","._post(path,","._preparetransaction(obj)","._put(path,","._register(obj)","._registeractor(actor)","._send(message)","._serialize(input)","._setkey(name)","._sign(tx)","._subscribetoshard(shard)",".add(amount)",".append(item)",".asmerkletree()",".asraw()",".attach(element)",".broadcast(msg)",".commit()",".compute()",".compute(input)",".connect(addr)",".connect(notify)",".consume(resources)",".create(entity)",".create(obj)",".createpricedorder(order)",".cycle(val)",".defer(authority)",".define(name,",".del(key)",".derive([info],",".deserialize(input)",".digest(input)",".enumerate()",".envelop(selector)",".extractsecret(tx,",".findbyfield(name,",".findbyname(name)",".findbysymbol(symbol)",".flush()",".fork()",".fromjson(input)",".fund(input)",".get(key)",".get(path)",".getaddressforscript(script)",".getaddressfromredeemscript(redeemscript)",".getbyid(id)",".getlatest()",".handler(message)",".height",".id",".import(state,",".inherits(scribe)",".isvalid()",".list()",".listen()",".log(...inputs)",".map()",".mutabletransact",".now()",".open(channel)",".publickeyfromstring(input)",".push(data)",".push(value)",".register(service)",".render()",".reverse()",".route(msg)",".send(channel,",".serialize([input])",".set(key,",".set(path)",".sign()",".sip([n])",".start()",".state",".stop()",".tick()",".tip",".tobuffer()",".tojson()",".toraw()",".tostring()",".tostring(input)",".totypedarray()",".transact",".trust(source)",".uastr",".update(id,",".use(name,",".use(plugin,",".value(input)","0","0.","1","1)","2","2.0","256","3","32","32).","4","5","5869.","7777",":","=","=>",">","@buffer","@data","@data.)","@entiti","@fabric/core/services/bitcoin","@fabric/core/services/bitcoin~bitcoin","@id","@parent","@type","[!!!]","[]","[actor.private]","[actor.public]","[actor.seed]","[actor]","[commit]","[commit])","[config.@data]","[config.listen]","[config.networking]","[config.peers]","[config.port]","[config.upnp]","[config]","[configuration]","[data]","[description]","[info]","[input]","[json","[list]","[map]","[map])","[n]","[settings.algorithm]","[settings.currencies]","[settings.fullnode]","[settings.key.seed]","[settings.key]","[settings.network]","[settings.nodes]","[settings.private]","[settings.provider]","[settings.public]","[settings.salt]","[settings.seed]","[settings.seeds]","[settings.verbosity]","[settings]","[size]","[size])","\\","_registeractor","_send","_serial","_serialize.","absolut","abstract","activ","actor","actor([actor])","actor,","actor.","actor.pubkey","actor.sign()","actor.tobuffer()","ad","add","add.","addr","address","address)","address.","address:port","addresses.","advertis","against","agent","agre","algorithm","alway","amount","amp.","analag","another.","anyth","api","app","app(definition)","app.","app.attach(element)","app.commit()","app.consume(resources)","app.defer(authority)","app.define(name,","app.deserialize(input)","app.envelop(selector)","app.fork()","app.get(path)","app.id","app.inherits(scribe)","app.now()","app.render()","app.serialize([input])","app.set(path)","app.start()","app.stop()","app.tostring()","app.trust(source)","app.use(name,","append","applic","application'","application.","applications.","apply.","appoverrides:","appreturns:","arbitrari","arc","array","assembl","assign.","ast","ast.","asynchron","at.","atom","attach","attempt","attribut","author","authority.","automat","avail","balance.","balances.","barebon","base","basic","bcoin'","bcointx","bech32","begin","behaviors.","between","bind","bip24","bit","bitcoin","bitcoin'","bitcoin([settings])","bitcoin._connectspv()","bitcoin._handleblockfromspv(msg)","bitcoin._handlecommittedblock(block)","bitcoin._handlepeerpacket(msg)","bitcoin._handletransactionfromspv(tx)","bitcoin._preparetransaction(obj)","bitcoin._subscribetoshard(shard)","bitcoin.connect(addr)","bitcoin.height","bitcoin.mutabletransact","bitcoin.start()","bitcoin.stop()","bitcoin.tip","bitcoin.transact","bitcoin.uastr","bitcoinaddress","bitcoinscript","bitcoinscript.","bitcointransact","bitcointransaction,","blindli","blob.","block","block.","blockmessag","bodi","body)","bond","boolean","bound","broadcast","btc).","buffer","buffer.","build","bundl","byte","bytes).","bytes.","call","cast","certain","chain","chain(genesis)","chain.","chainabl","chang","changes.","channel","channel'","channel([settings])","channel.","channel.add(amount)","channel.fund(input)","channel.open(channel)","child","choos","circuit","circuits.","claim","class","class.","classemits:","classextends:","classproperti","cli","cli([settings])","cli.","cli.start()","cli.stop()","client,","client.","clock","clock,","close","closure.","code","collect","collection'","collection([configuration])","collection.","collection._patchtarget(path,","collection._setkey(name)","collection.asmerkletree()","collection.create(entity)","collection.findbyfield(name,","collection.findbyname(name)","collection.findbysymbol(symbol)","collection.get(path)","collection.getbyid(id)","collection.getlatest()","collection.import(state,","collection.list()","collection.map()","collection.push(data)","collection.set(path)","collection.totypedarray()","collectionemits:","collectionreturns:","collections,","command","commit","commit)","committed.","compat","compil","compile.","compiler'","compiler(settings)","compiler.","compiler._fromjavascript(body)","compiler._getjavascriptast(input)","compilerreturns:","complet","complete.","compon","components,","components.","compos","comput","computing.","conditions\"","config","config.verbos","configur","configuration.","confirm","connect","connections.","consensu","consensus([settings])","consid","console.","constructor.","consum","consumption.","contain","content","contention\",","contents.","context","contract","contract'","contract.","contracts,","control","convert","core","core/","correctli","count","crawl","creat","crowdfund","cryptograph","css","currenc","current","cycl","cycle.","data","data.","datastore.","decentr","deeper","default","defer","defin","definit","definition)","definition.","definitions.","delet","deliv","demonstr","deprec","deriv","describ","descript","design","desired.","determinist","development,","digest","digest.","digit","dir","direct","directori","disclos","disconnect","discussed.","disk.","distinct","distribut","document","document'","document.","dom","domain,","domel","downsample.","drop","durat","e.g.","each","effects).","element","element.","elements.","elment","else.","emit","empow","emulator.","encod","encrypt","engine.","entiti","entity([data])","entity.","entity._downsample([input])","entity.tojson()","entity.toraw()","entityreturns:","entropy.","enumer","es6","establish","evaluate.","event","event:messag","event:{message}","eventemitt","eventemitterproperti","events.","example,","examples.","exchang","exchange(settings)","exchange.","execut","exist","exit","expand","expect","explicit","explicitli","explor","extends:","extern","extract","fabric","fabric(config)","fabric.","fabric.compute()","fabric.push(value)","fabric.register(service)","fabric.trust(source)","fabricreturns:","face","failure,","failure.","fals","familiar","fee","field","field.","find","fingerprint","finit","first,","flush","follow","for.","forward","found.","framework","fresh","friendli","from.","full","function","function.","fund","further","future.","gener","general,","generator.","genesi","getter","getter.","global","graph","group,","hand","handl","handle.","handler","hash","hash.","hash256","hash256(),","hash256(settings)","hash256.digest(input)","hash256.reverse()","hash256returns:","hashmap","hashtabl","height","held","hex","hex.","hexadecim","highest","hkdf","hkdf(settings)","hkdf.derive([info],","hmac","hold","host,","host.","hostnam","http","https://www.w3.org/tr/activitystream","human","i/o","id","id.","ident","identifi","identifier.","immut","implement","implementaton.","implicitli","import.","includ","inclus","incom","increment","indic","information.","infrastructure.","init","initi","inner","input","input.","insert","instanc","instance'","instance,","instance.","instanti","instruct","instructions.","integ","interact","interaction.","interactions.","interfac","interface'","interface(settings)","interface,","interface.","interface.cycle(val)","interface.log(...inputs)","interface.now()","interface.start()","interface.stop()","intern","internally.","interpret","item","items.","iter","itself.","javascript","job.","jobs,","json","json,","keep","key","key()","key([settings])","key({","key,","key.","keypair,","keyring.","kind:","knowledge.","known","label","later","later.","ledger","ledger'","ledger.","ledger.append(item)","ledger.commit()","ledger.deserialize(input)","ledger.fork()","ledger.get(path)","ledger.id","ledger.inherits(scribe)","ledger.now()","ledger.render()","ledger.serialize([input])","ledger.set(path)","ledger.tostring()","ledger.trust(source)","ledgeroverrides:","ledgerreturns:","length","lifecycle.","lifetim","line","link","list","listen","live","load","local","log","long","long.","machin","machine(config)","machine.","machine.compute(input)","machine.sip([n])","machinereturns:","mainnet.","maintain","make","manag","mani","map","map.","market","marshal","match","match.","materi","material.","matrix","matrix([settings])","matrix.","matrix._get(path)","matrix._put(path,","matrix._registeractor(actor)","matrix._send(message)","matrix.connect(notify)","matrix.handler(message)","matrix.route(msg)","matrix.send(channel,","matrix.st","matrix.start()","matrix.stop()","matrix.tick()","matrixoverrides:","matrixreturns:","mechan","mechanics.","member","memori","memory.","mempool","mempool(settings)","merkletre","merkletree.","messag","message(message)","message)","message.","message.asraw()","messagereturns:","messages,","messages.","message}","method","method.","method.emits:","millisecond","milliseconds.","mind","minimum","mix","mnemon","model","modifi","modify.","modul","module:messag","monitor.","more","move","msg","mtx","mutual","n","name","name)","name.","nativ","necessari","need","network","network,","network.","new","next","node","node.","nodes.","noisy?","non","none.","normal","notifi","null","number","numer","obj","object","object,","object.","objects,","objects.","objects.properti","of:","on","onc","onto","open","oper","operates,","opportun","option","oracl","oracle(initial)","oracle._post(key,","oracle._register(obj)","oracle.broadcast(msg)","oracle.del(key)","oracle.flush()","oracle.get(key)","oracle.set(key,","oracle.start()","oracle.trust(source)","oracleoverrides:","oraclereturns:","orchestr","order","order.","order.amount","order.asset","origin","others!","outbound","outcom","outcome.","outgo","output","output,","output.","outsid","outstand","over","over.","p2p","p2sh","page","pages.","paid","pair","pairs.","param","paramet","params)","parent.","pars","parse.","parti","particular","particularli","pass","patch","patches)","path","path(input)","path.","path.isvalid()","pathreturns:","pattern.","peer","peer#event:readi","peer([config])","peer.","peer.listen()","peer.start()","peer.stop()","peerpacket","peerreturns:","peers.","period","persist","phrase.","place","placeholder,","plugin","plugin.","plugin.nam","point","pointer","pointer.","port","position,","possibl","post","power","prepar","prepare.","presenc","prevent","previou","price","prior","prioriti","privat","process","process.","produc","product.","program","program.","promis","proof","properti","properties.","propos","protocol","protocol,","prototype.","provid","provided,","provided.","provider.","pubkey.","public","public:","pure","purpos","push","put","quit","random","readi","real","receiv","recent","reclaim","recordkeeper.","redeemscript","refer","reflect","regist","register.","registration.","regtest,","relay","reli","reliabl","remain","remot","remote(target)","remote._delete(path,","remote._get(path,","remote._options(path,","remote._patch(path,","remote._post(path,","remote._put(path,","remote.enumerate()","remotereturns:","remov","remove.","render","renderreturns:","renders)","repres","represent","request","request.","requests.","requir","resolv","resourc","resource'","resource(definition)","resource,","resource.","resource.create(obj)","resource.update(id,","resourcereturns:","respons","restor","result","result.","results.","retriev","retrieval.","retrieve.","retriv","return","returns:","reveal","revers","rfc","rout","routabl","route.","router","router(map)","router.","router.commit()","router.deserialize(input)","router.fork()","router.get(path)","router.id","router.inherits(scribe)","router.now()","router.render()","router.route(msg)","router.serialize([input])","router.set(path)","router.tostring()","router.trust(source)","router.use(plugin,","routerreturns:","rules.","run","salt","scribe","scribe(config)","scribe.","scribe.commit()","scribe.deserialize(input)","scribe.fork()","scribe.get(path)","scribe.id","scribe.inherits(scribe)","scribe.now()","scribe.render()","scribe.serialize([input])","scribe.set(path)","scribe.tostring()","scribe.trust(source)","scribeproperti","scribereturns:","script","script(config)","script,","script.","search","search.","secret","secret)","secur","see","seed","seek","select","selector","selector.","semantics.","send","send.","sent.","serial","serialize.","serv","servic","service'","service(config)","service,","service.","service._get(path)","service._put(path,","service._registeractor(actor)","service._send(message)","service.connect(notify)","service.handler(message)","service.route(msg)","service.send(channel,","service.start()","service.tick()","servicereturns:","services.","session","session(settings)","session,","session.","session.start()","session.stop()","set","settings.","settings.bodi","settings.fe","settings.fees.minimum","settings.initi","settings.input","settl","settled.","sha256","sha256(input)","shard","share","sheet","sign","simpl","simple!","simpli","simul","singl","size","slice","snapshot","snapshot(settings)","snapshot.","snapshot.commit()","snapshot}","someth","sourc","source,","source.","spaces.","spec:","specif","spend","spv","spvsource.","stack","stack#fram","stack#id.","stack([list])","stack.","stack.push(data)","stackreturns:","standard","start","startreturns:","stash","state","state(data)","state,","state.","state.commit()","state.deserialize(input)","state.fork()","state.fromjson(input)","state.get(path)","state.id","state.render()","state.serialize([input])","state.set(path)","state.tostring()","stateproperti","statereturns:","static","statu","step","stop","storag","storage(config)","storage,","storage.","storage.set","store","store([settings])","store.","store._post(key,","store._register(obj)","store.del(key)","store.flush()","store.get(key)","store.set(key,","store.start()","store.trust(source)","storereturns:","stream","stream.","string","string,","string.","structur","structure)","subscrib","success","success,","success.","sum.","suppli","supply.","support.","swap","swap([settings])","swap.","swap.extractsecret(tx,","swapreturns:","swarm","swarm(config)","swarm.","swarm.start()","swarm.trust(source)","swarmreturns:","symbol","syntax","system","system'","system.","systems,","tag","take","target","target.","target.host","target.secur","task.","templat","term","termin","testnet,","therein.","this.chain","this.state.","thought","through","tick","time","time,","time.","timestamp,","timestamp.","tip","tl","to.","tool","top","track","trade","transact","transaction.","transactions,","transactions.","transit","transition(settings)","transmit","treat","tree","tree.","trigger","true","trust","trust.","two","tx","type","type,","type.","typic","undefin","uniqu","unmarshal","updat","update)","update.","updates.","upnp","upon","us","use.","used.","user","user,","user.","util","utilize.","val","valid","valid.","valu","value(data)","value)","value).","value,","value.","value.]","value.value(input)","values).","values.","variou","vector","vector(origin)","vector,","vector.","vector._serialize(input)","vector.tostring(input)","vectorreturns:","verbatim.","verifi","verifier.","version","virtual","walker","walker(init)","walker._define(dir,","walker._explore(path,","walkerreturns:","wallet","wallet([settings])","wallet,","wallet.","wallet._createcrowdfund(fund)","wallet._getrefundinputscript(redeemscript)","wallet._getswapinputscript(redeemscript,","wallet._load(settings)","wallet._sign(tx)","wallet.createpricedorder(order)","wallet.getaddressforscript(script)","wallet.getaddressfromredeemscript(redeemscript)","wallet.publickeyfromstring(input)","wallet.start()","web","whether","wipe","wisely.","with.","within","work)","work.","worker","worker(method)","worker.compute(input)","workerreturns:","workflow","{@link","{@link}","{}","})","~bitcoin","—","⇐","⇒","🖨️"],"DEVELOPERS.html":["(msg)","(rfcs).","=","=>","access","actor","actor();","actor.on('message',","actor.sign().signature;","actor:',","applications,","architectur","between","build","carri","class","coffe","comput","console.log('messag","const","cover","cryptograph","data","decentr","develop","eventemitt","exchang","extern","fabric","fabric.","familiar","format","grab","guid","in.","inform","information,","information.","interact","javascript","lot","messag","method:","more","msg);","networks.","new","node","object","options.","overview","pass","pattern:","primari","provid","regard","reli","request","require('@fabric/core/types/actor');","resourc","see","servic","settl","sign()","signatur","signatures,","special","there'","tool","transact","us","varieti","variou","via","{","});","☕","🤯"],"SERVICES.html":["=","@fabric/bitcoin","@fabric/cor","@fabric/lightn","@fabric/matrix","allow","basic","bitcoin","bitcoin();","bitcoin.start();","btc","const","consum","fabric","function","implement","list","made","network.","new","numer","offer","oracl","overview","pay","payments,","provid","quick","request","requir","require('@fabric/core/services/bitcoin');","servic","services.","start","🏦"],"whitepaper.html":["\"/assets\"","\"/instances\"","\"/items\"","\"/players\"","\"/transactions\"","\"/users\"","\"arc","\"bitcoins\",","\"block","\"block\".","\"blockchain\".","\"blocks\",","\"blocks\".","\"carri","\"commit\",","\"duplex","\"enigma:","\"failover\"","\"fuzzchain\",","\"fuzzchain\".","\"fuzzy\",","\"homomorphic\"","\"inform","\"linked\"","\"mpc","\"offlin","\"opcodes\",","\"page\"","\"perspective\"","\"proof","\"purity\".","\"request","\"servic","\"settle\"","\"shell\"","\"spend\"","\"transactions\".","\"trust","\"truth\",","\"work","\"zero","#","&","'/items{id}'","(\"zkcp\")","(...)","(1.00","(100","(a","(a)","(again,","(arc)","(creator","(fsm)","(latest)","(layer","(limit","(not","(operations)","(or","(rsk,","(see","(such","(term","(the","(uniform","(unit","(wip)",".","...","....","//","/asset","/instanc","/item","/items/{id}","/player","/transact","/universes/{id}","/universes/{id}\"]","/user","0","0.1.0","0:","1","1)","1)\"","1)\\nto:","1.","1.1.","1.1.1.","1.1.1.1.","1.1.1.2.","1.1.1.3:","1.1.2.","1.2.1:","1.2.2:","1.2.3:","1.2:","1.3.1:","1.3.2:","1.3:","1.4.1:","1.4:","10.1:","100.00","1000","1008","10:","11:","12:","175","185","196.","1978.","1982.","198~","1999.","1:","2","2)","2)\"","2.1:","2.2:","2008","2013","2013.","202.","2:","3","3)","3)\"","3.1.1.1:","3.1.1:","3.1:","3.2:","3.3.1:","3.3.2:","3.3.3:","3.3.4:","3.3.5.1:","3.3.5.2:","3.3.5.3:","3.3.5.4.1:","3.3.5.4.2:","3.3.5.4.3:","3.3.5.4.4:","3.3.5.4:","3.3.5:","3.3.6:","3.3:","3.4.4:","3.4.5:","3.4:","32","32gb.","3:","4:","4gb","54th","5:","6:","7:","8.1","8:","9:","=","???","@","[1b5879d683819f2a623049e9d0e4bd954d9f228da000d2774f58652af1f3c882]…","[8ee89711330c1ccf39a2e65ad12bbd7df4a4a2ee857f53b4823f00fecb7bd252]…","[???]","[a","[bitcoin]:","[capabl","[citat","[cite:","[gray78]","[label=\"","[label=\"1000","[zero","_t,","`0`","`add`","`application`","`example`","`start`","a:","abil","abov","above,","abstract","accept","access","account","accumul","accur","achiev","actor","actors,","acut","ad","add","addit","address","adopt","adoption.","advanc","advantag","adversari","against","aggreg","aggregate,","agre","agreement","ahead","aim","al","al.","alan","alex","algorithm","align","alloc","allow","alreadi","altcoin","altern","amount","anchor","anchor,","and,","andrew","annual","anoth","another.","anothers'","appear","append","appendix","appli","applic","application'","applications,","applications.","approach","arbitrari","arc","arc:","architectur","arrang","array","assert","asset,","assum","assur","asymmetri","asynchron","atom","attent","audit","author","author'","authority.","avail","averag","awar","away","b","b)","b]","back","backdrop","background","bank","bare","base","basi","basic","basis.","baum'","baum,","be","becam","becom","befor","before.","behavior","behavior,","behavior.","behaviors,","behaviors.","berlin","berner","between","beyond","birth","bit","bitcoin","bitcoin'","bitcoin,","block","block.","blockchain","blockchain)","blockchain,","blockchain.","blocks,","blossom","bond","both","bound","boundari","brace","broadcast","bubbl","bug","build","built","bundl","burgeon","buy","buyer","buyer.","c","c.","call","called,","came","can:","capabl","capac","capit","carsten,","case","cash","catalyst","catalyz","ceas","central","chain","chain.","chains,","challeng","chang","change.","channel","channel.","channels\".","charli","check","choos","circuit","citat","claim","claudio","clear","clever","client","close","cluster_anchor","cluster_arc","cluster_mpc","code","code.","cohen,","collabor","collaps","collect","collections,","combin","comment","commit","common","commun","compat","compel","compet","competit","compil","complet","complete,","complex","complexity,","compon","components,","compos","composit","composition,","compromis","comput","computation\":","computation,","computation.”","computations,","computations.","computations.”","concept","concern","conclus","conflict","connect","consensu","consensus.","constrain","constraint","construct","construct:","constructed.","constructively?","consum","consume,","consumers.","contain","contains.","content","context","context:","contextu","conting","continu","contract","contract,","contract.","contracts\")","contracts,","contracts.","contrast","control","conveni","conversation?","coordinator.","copi","core","correct","correl","cost","coupl","craft","creat","creation.","cross","cryptograph","cryptographi","cryptologycrypto","cryptosystem,","curiou","curli","currenc","currency,","current","d,","damgrd,","data","data,","data.","databas","datastor","date","date.","david","debug","decentr","decis","decrypt","deeper","defens","defin","defined,","definit","definitions.","definitions:","degre","deliv","deliveri","delta","demand","demonstr","denot","depend","deplo","deploy","depth","deriv","describ","descript","deserv","desir","despit","destroy","detail","detect","determin","deterministic,","develop","difficult","difficult.","dig","digest","digit","dilley","direct","directli","discern","discov","discret","discuss","disk","dispar","distribut","diverg","divid","document","domain","door","draft","drawback","drivechain,","drop","duplex","duplicate,","dynam","e.","each","earn","easili","econom","economi","economics)","effect","effici","effort","efforts.","elements,","emerg","emerged,","enabl","encourag","encrypt","encryption,","end","endang","energi","enforc","enforcement.","engin","ensur","entir","entireti","entity,","entri","environ","environment,","environments,","environments.","ephemer","ephemera","eponym","equal","equival","era","establish","et","etc.)","ev","even","event","exampl","example,","example:","exchang","excit","execut","execution.","exhibit","exist","expand","expans","expect","expected,","expend","expens","expensive,","explicit","explicitli","explorer,","expos","extend","extens","extent","extern","extrem","fabric","fabric'","fabric,","fabric.","facilit","fact","failur","failures].","fair","familiarity.","fashion,","fashion.","favor","featur","feedback,","fhe,","fhe.","fiat","field.","figur","final","financi","find","finit","finite,","first","first\",","first.","fix","flow","focii.","follow","follows:","forc","form","formallyverifi","formulae.”","forward\"","foundat","fragment","frame","frank","fraud","free","freedom","friendli","friendster","from.","fulfil","fulli","function","function,","functions,","functions.","fund","fundament","fundamentally,","funds.","further","further,","furthermor","furthermore,","futur","fuzzchain","gain","garner","gave","gener","gil,","given","global","graph","graphs,","gray","great!","greater","greatest","gregori","group","group,","growth","guarante","guarantees)","guarantees.","guy","handshak","hash","hashes,","healthi","heidelberg,","help","hidden","hierarch","hierarchi","hierarchy.","high","highli","highvolum","histor","histori","history,","homomorph","honest,","hous","however,","htlc","htlc+1","htlc+2","htlcs.","html","html,","http://bitcoin.org/bitcoin.pdf","http://www.cypherpunks.to/erights/elib/capability/ode/ode.pdf","human","hyperlink.","hyperlinks,","hypertext","id","id:","idea","idea,","ident","identifi","identity,","ieee","ieee,","implement","implementation.","implementations).","implic","improv","improvement.","incent","incentives.","includ","include:","inconveniently,","increas","incred","increment","indent","independ","independent,","independentlysecur","index","individu","industri","ineffici","influenc","inform","information,","information.","infrastructur","initi","initiatives.","injl","injr","ink","ink)","ink)\"]","input","instead","instead,","instruct","instructions,","intang","integer.","integr","integration,","intend","intens","intention","interact","interconnect","interest","interesting,","interfac","intern","interoper","interoperability,","intrins","introduc","introduct","invalid","invalid,","invent","invers","invest","involv","irrat","is,","isol","isomorph","issu","issuanc","it.","iter","itself","itself,","itself.","ivan","j.","kay","keep","key","know","knowledg","known","l1:","l2:","l3:","label","languag","language,","larg","large,","larger","later","latest","layer","leav","ledger","ledger,","lee","legaci","lend","let'","level","leverag","lightn","limit","limitit","line","link","linkabl","list","lock","log","logic","long","longer).","look","loop","lower","machin","machine,","machines,","made","main","maintain","major","make","maki,","malici","management,","mani","manifest","manipul","market","market\"","market,","market.","markup","martindale,","math.","mathemat","maxim","maxwel","meaning","mechan","mechanism.","mechanisms,","medium","memory,","messag","method","microformat","microsoft","middl","mint","mit","mode","model","model,","models.","moder","modern","modif","modifi","momentum","monetari","money,","monopoli","monopolies,","more","morrison","morrison,","move","mpc","much","multi","multiparti","multipl","mutat","mutation,","myspace,","n","n+1","n+2","nakamoto","nakamoto,","name","namespac","nathan,","navig","necessari","necessarili","need","needed.","needed],","needed].","network","network,","network.","networks,","networks.","never","new","new,","newli","next.","node","node,","nodes,","nois","normally.","not,","notic","notifi","notori","now","number","numbers.","object","object)","object,","observ","obviat","offer","on","onc","once,","one'","op_checklocktimeverifi","op_checksig","op_drop","op_dup","op_els","op_endif","op_equ","op_equalverifi","op_hash160","op_if","op_sha256","opcode,","open","opendif","oper","optional,","oracle,","order","ordering.","orders\"","organ","orient","origin","originator.","orlandi.","ostens","other,","otherwis","out","output","output.","outright","outsid","outstand","over","overhead","overview","own,","oz","p","pages,","paid","paillier","pair","pallier","paper,","parallel","paramet","parti","partial","particip","participants.","particular","parties,","parties.","party.","pascal","pass","patchsets,","paul","payment","payment\",","payment,","payment][zkcp],","payments,","peer","peers,","pentland.","per","perfect","perform","performed,","perhap","period","phase","phase,","philosophy,","philosophy.","place","platform","point","polynomi","posit","possibl","potenti","power","power,","power]","pre","predict","present","preserv","previous","price","primarili","primit","primitives,","principl","prior","privaci","privacy\"","privacy,","privat","probabilist","problem","problem.","process","produc","product","profil","program","program,","program.","programs,","prohibit","project","promis","proof","proof.","properti","propos","proposal?","proprietari","prospect","protect","protocol","protocol,","protocol.","provabl","proven","provid","provided)","provided.","provis","public","publicli","publish","publishing,","purchas","pure","purpos","puzzle,","quadrat","quantiti","quickli","quit","quorum","random","rang","rate","re","readable,","reader","reason","reason,","receiv","recent","recipient.","record","redeem","redeemscript","refer","reference,","reference.","regard","reinforc","rel","relay","reli","reliabl","reliable,","remain","remov","rep","repair","replac","replic","repres","repriev","request","requir","requirements,","requirements.","requisit","research","resili","resist","resolution,","resourc","resources,","resources.","respect","restor","restrict","result","results.","resurg","retain","retriev","return","reveal","review.","reviewers:","reward","risk","risk!","role","roll","root","rotat","roughli","rout","routes.","rpg","rule","rule,","run","safe","sake,","same","sat","sat\"]","satoshi","say,","scalabl","scale","scale,","scarce.","schema.org","scheme","scheme,","science.","scope","script","script'","script,","search","second","secur","secure,","security.","select","self","seller","semant","sender","sent","separ","sequenc","seri","serv","server","server,","servic","services,","session","set","sets,","settl","sever","sha256","share","sidechain","sign","signatori","signatur","signature,","signific","silo","similar","similarly,","simpl","simplicity'","simply:","simultan","singl","singular","size","size]","slightli","small","smaller","smart","softwar","solut","solv","sourc","speak","special","specif","specifi","specifically,","spectrum,","speech","spendabl","spent","split","springer","stabl","stack","stand","start","start!","state","state,","state.","storag","storage,","store","strategi","stream","structur","structure,","sub","subgraph","subject","submit","subscrib","subscript","subscriptions,","subsequ","subset.","subsidies.","subsidy\",","substrat","succe","success","such","sudoku","sugar","sum","suppli","supply)","suppos","surround","symposium","syntact","syntax","system","system,","systems.","systems]:","t","t^","tackl","tag.","take","tangibl","techniqu","tenet","term","thermodynam","they'd","think","third","threshold","threshold.","through","thrown","tightli","time","time,","time.","timefram","timeout","timestamp","timothi","to:","today","today.","todo","todo:","token","token,","token.","tokens,","tool","topolog","topology,","toward","traction,","tradit","transact","transactions,","transfers,","tree","tri","tripl","trivial","trust","trust,","trustlessli","truth","truth.","turn","twitter,","two","type","types,","typic","underli","unencrypted,","unifi","unit","unix","unknowable,","unknown","unspent","until","untrust","up","updat","upon","us","user","util","utilized,","valid","valu","valuable.","value,","value.","values,","values.","vari","variou","veri","verifi","verified,","verify.","version","via","viable.","visual","voluntari","vote","want","warning!","wave","way","way,","way?","we'v","wealth","web","web,","week","week),","wherebi","wherein","whitepap","wide","widespread","widest","within","without","work","work\".","work,","work.","worker","workload","world","x","x'","xanadu","xmlhttprequest","yao,","zero","zkcp","zkcp.","zyskind,","{","|","}","}\"]","§","ƒ","ƒ(x)","δ","δx'","φ...","φ0","φ1","φ2","φ3","–","—","’sandy’","”effici","”protocol","”publicli","⇒","⚡","📄"],"whitepaper-2015.html":["\"atomic\"","\"bitcoins\",","\"block","\"block\".","\"blockchain\".","\"blocks\",","\"blocks\".","\"commit\",","\"comput","\"converg","\"duplex","\"enigma:","\"fuzzchain\".","\"page\"","\"proof","\"servic","\"shell\"","\"transactions\".","&","(2015)","(arc)","(fhe)","(or","(posit","(such","(term","(the","(thu","(uniform","(wip)","....","1","1.","175","185","196.","1978.","1982.","198~","1:","2,","2001^[citat","2008","2008,","2009,","2013","2013.","2014.","202.","2:","30","3:","54th","???","[???]","[citat","[cite:","[gray78]","_x","abil","abstract","accord","account","achiev","actor","actors,","acut","add","addit","addition","address","adoption.","advanc","advantag","against","agreement","aim","al.","alan","alex","algorithm.","alic","alloc","allow","along","altcoin","alternatives,","amount","anchor,","andrew","annual","anoth","another.","anothers'","appear","append","appli","applic","application'","approach","arbitrari","arrang","array","assumpt","asynchron","atom","audit","author","avail","b","background","balanc","bare","basi","baum'","baum,","be","becam","becom","befor","before.","behavior","behaviors.","berlin","berner","between","birth","bitcoin","bitcoin'","bitcoin,","blind","block","block.","blockchain","blockchain.","blossom","bond","boolean","boundari","broadcast","build","bundl","burgeon","byzantin","c.","calcul","called,","came","capabl","capac","capit","carsten,","case","cash","catalyz","ceas","chain","chains,","chang","channel","channels\".","check","choos","circuit","citat","claim","claudio","clear","clever","code","cohen,","coin","combin","commit","commitment)","commitment,","compel","competit","compil","complet","complex","complexity,","compon","components;","compos","compromis","comput","computation,","computation.","computation.”","computations,","computations.","computations.”","computed,","concept","conflict","consensu","consensus,","constraint","construct","constructed.","consum","contains.","content","context","contract","contract,","contract.","contracts\")","contracts.","contrast","coordin","correct","correl","counterparty)","counterparty.","creation.","cross","cryptograph","cryptographi","cryptologycrypto","crystal","currenc","current","damgrd,","data","data,","databas","datastor","date","decentr","deepli","defens","defer","defin","defined,","definitions.","deliveri","demonstr","deploy","depth","deriv","describ","descript","description).","design","designs,","desir","destroy","determin","develop","difficult","digit","direct","directli","discov","dissimilar","distribut","diverg","document","domain","domin","door","duplicate,","dynam","each","earlier","econom","edg","effect^[cit","effort","efforts.","elements.","embed","emerg","emerged,","encount","encrypt","end","energi","enforc","engin","enigma","ensur","entir","entireti","entri","equal","equival","era","establish","et","even","exampl","exchang","execut","exist","exist,","expend","expensive.","explicitli","expos","extend","extern","extrem","fabric","fabric'","fabric,","facilit","failures].","fair","famous","fashion,","fashion.","favor","fee","fibonacci","field.","final","find","finit","finite,","first","first.","focii.","follows:","form","formulae.”","foundat","freedom","friendli","friendster","from.","fulli","function","functions,","functions.","fund","fundamentally,","funds.","further,","furthermor","furthermore,","fuzzchain","garbl","gave","gener","general'","gil,","given","global","goal\"","gone","gray","greatest","group","guarante","guarantees)","guy","happen","hash","hashes,","have","heidelberg,","hierarch","hierarchi","hierarchy.","high","highest","homomorph","honest,","hous","however,","html","hundr","hypertext","idea","idea,","identifi","identity,","ieee","ieee,","implement","impulse.","incent","includ","include:","inconveniently,","increas","independ","independent,","indic","individu","industri","inform","initi","input","instead,","instrument","intang","integration,","intens","interact","interconnect","interest","interesting,","interfac","intern","interoper","interoperability,","intrins","introduc","introduct","invalid,","invers","irrat","is,","isol","isomorph","it.","ivan","j.","kay","keep","known","languag","larg","later","launch","lay","layer","leav","ledger","ledger,","lee","let'","level","leverag","lifecycl","lightn","likelihood","limit","lindi","linear,","link","linkabl","list","lock","lock,","log","longer).","look","made","major","maki,","malici","mani","manipul","market","market,","market.","markets\",","markup","measur","mechan","mechanism,","mechanism.","mechanisms,","messag","microformat","microsoft","minim","mint","minut","mit","model","model,","model^[cit","models.","modif","modifi","monetari","more","move","mpc","much","multi","multiparti","multipli","mutat","mutation,","myspace,","n","n_th","nakamoto","nakamoto,","name","namespac","nathan,","necessari","necessarili","need","needed.","needed]","needed],","needed].","negative).","network","network,","network.","networks.","never","new","new,","newli","next.","nick","node","node,","nodes,","not,","note","novel","now","number.","observ","offer","on","onc","once,","one'","open","oper","operations,","optim","order","ordering.","orlandi.","ostens","other,","output.","outright","outsid","outstand","over","overhead","overhead.","own,","oz","pages,","paid","pair","parallel","part","parti","particip","participants.","particular","particularli","parties,","party.","patchsets,","path","path,","pay","payment","payments,","peer","peers,","pentland.","perfect","perform","perhap","phase","phase,","place","platform","point","polynomi","posit","possibl","potenti","power]","pre","preimage,","present","price","primari","primarili","principl","prior","privacy\"","probabl","problem","problem.","produc","profil","program","program,","programs.","prohibit","project","promis","proof","proprietari","protect","protocol","protocol,","provabl","provid","publicli","publishing,","pure","purpos","quadratic,","quickli","quorum","rang","rank","rapidli","rate","real","reason","reason,","recent","reduc","refer","reknown","relationship","relay","reli","reliable,","remain","remov","replac","repres","request","requir","requisit","resist","resolut","resolution,","resourc","resources,","restor","result","results.","resurg","retriev","reveal","reversal,","reward","risk","roll","roughli","rout","rule","rule,","same","satoshi","scalability.","schema.org","scienc","science.","search","second","secret","secur","security.","see:","select","self","semant","sequenc","sequence.","session","set","sets,","share","shared,","signatur","silo","similar","simpl","simplest","simultan","singl","size","size]","slightli","small","small,","smaller,","smart","smpc.","solut","sort","space","speak","special","specif","specifically,","speech","spent","split","springer","state","state,","state.","strategi","subsequ","subsidi","subsidy\",","success","such","such,","suffici","sum","supply)","surround","symposium","system","system,","system.","systems.","szabo","t","t,","t^","take","tangibl","term","themselv","they'd","think","third","thousand","three","threshold","through","time","time,","time.","timestamp","timothi","today","todo:","token","token,","token.","tokens,","tolerable,","tool","toward","tradit","transact","transactions,","tripl","trivial","trust","trust,","twitter,","two","type","typic","underli","unit","until","up","updat","upstart","us","user","users,","util","utilized,","valid","valu","valuable.","value,","vari","variou","veri","verifi","verified,","verify.","via","viable.","volum","vote","want","wave","web","well","wherebi","wherein","whether","whitepap","widest","within","without","work","work\".","work,","world","world'","writing,","x","xanadu","xmlhttprequest","y","yao'","yao,","zero","zyskind,","–","’sandy’","”effici","”protocol","”publicli","📃"]},"length":7},"tokenStore":{"root":{"0":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915}},",":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.015267175572519083}}},".":{"1":{"docs":{},".":{"0":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"docs":{}}},"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"1":{"0":{"0":{"0":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}},"8":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"docs":{},".":{"0":{"0":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}},"docs":{}},"docs":{}}},"docs":{},",":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}},".":{"1":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"docs":{}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"1":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"2":{"docs":{},".":{"1":{"6":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.015267175572519083}}},"docs":{}},"docs":{}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"7":{"5":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"docs":{}},"8":{"5":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"docs":{}},"9":{"6":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"7":{"8":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"docs":{}},"8":{"2":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"docs":{},"~":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"9":{"9":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"docs":{}},"docs":{}},"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.002635046113306983},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},",":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.03816793893129771}}},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915}},"\"":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"\\":{"docs":{},"n":{"docs":{},"t":{"docs":{},"o":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},".":{"1":{"docs":{},".":{"1":{"docs":{},".":{"1":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"2":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"3":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"2":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"2":{"docs":{},".":{"1":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"2":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"3":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"docs":{}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"3":{"docs":{},".":{"1":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"2":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"docs":{}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"4":{"docs":{},".":{"1":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"docs":{}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"2":{"0":{"0":{"1":{"docs":{},"^":{"docs":{},"[":{"docs":{},"c":{"docs":{},"i":{"docs":{},"t":{"docs":{},"a":{"docs":{},"t":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}},"8":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"9":{"docs":{},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"docs":{}},"1":{"3":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}},"4":{"docs":{},".":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"docs":{}},"2":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"docs":{}},"5":{"6":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}}},"docs":{}},"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},".":{"0":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"1":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"2":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"docs":{}},")":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"\"":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"3":{"0":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"2":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},")":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"g":{"docs":{},"b":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542},"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},")":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"\"":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},".":{"1":{"docs":{},".":{"1":{"docs":{},".":{"1":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"docs":{}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"docs":{}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"2":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"3":{"docs":{},".":{"1":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"2":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"3":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"4":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"5":{"docs":{},".":{"1":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"2":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"3":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"4":{"docs":{},".":{"1":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"2":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"3":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"4":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"docs":{}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"docs":{}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"6":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"docs":{}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"4":{"docs":{},".":{"4":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"5":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"docs":{}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"docs":{}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"4":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}},"g":{"docs":{},"b":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"5":{"4":{"docs":{},"t":{"docs":{},"h":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"8":{"6":{"9":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}},"docs":{}},"docs":{}},"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}},"6":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"7":{"7":{"7":{"7":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"docs":{}},"docs":{}},"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"8":{"docs":{},".":{"1":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"docs":{}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}},"9":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"docs":{},"#":{"1":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}},"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}},"l":{"docs":{},"e":{"docs":{},"a":{"docs":{},"r":{"docs":{},"n":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}}}},"(":{"1":{"0":{"0":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}},"docs":{}},"docs":{},".":{"0":{"0":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}},"docs":{}},"docs":{}}},"2":{"0":{"1":{"5":{"docs":{},")":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":3.333333333333333}}}},"docs":{}},"docs":{}},"docs":{}},"4":{"0":{"9":{"6":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"docs":{}},"docs":{}},"docs":{}},"docs":{},"#":{"docs":{},"f":{"docs":{},"a":{"docs":{},"b":{"docs":{},"r":{"docs":{},"i":{"docs":{},"c":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}}}}},"h":{"docs":{},"t":{"docs":{},"t":{"docs":{},"p":{"docs":{},")":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}},"k":{"docs":{},"d":{"docs":{},"f":{"docs":{},")":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}},"m":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},"a":{"docs":{},"g":{"docs":{},"e":{"docs":{},")":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}}}}},"a":{"docs":{},"x":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"s":{"docs":{},"g":{"docs":{},")":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}}}}}},")":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}},"a":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643}},"b":{"docs":{},"o":{"docs":{},"v":{"docs":{},"e":{"docs":{},")":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}},"d":{"docs":{},"d":{"docs":{},"r":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},":":{"docs":{},"p":{"docs":{},"o":{"docs":{},"r":{"docs":{},"t":{"docs":{},")":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}},"l":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"n":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"s":{"docs":{},"t":{"docs":{},")":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"u":{"docs":{},"d":{"docs":{},"i":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},")":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"g":{"docs":{},"a":{"docs":{},"i":{"docs":{},"n":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"r":{"docs":{},"c":{"docs":{},")":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"o":{"docs":{},"p":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"a":{"docs":{},"l":{"docs":{},")":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}}}},"e":{"docs":{},"r":{"docs":{},"a":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"s":{"docs":{},")":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}}},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"\"":{"docs":{},"c":{"docs":{},"o":{"docs":{},"m":{"docs":{},"m":{"docs":{},"a":{"docs":{},"n":{"docs":{},"d":{"docs":{},"s":{"docs":{},"\"":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"z":{"docs":{},"k":{"docs":{},"c":{"docs":{},"p":{"docs":{},"\"":{"docs":{},")":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"=":{"docs":{},"=":{"docs":{},"=":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"b":{"docs":{},"l":{"docs":{},"o":{"docs":{},"c":{"docs":{},"k":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"c":{"docs":{},"l":{"docs":{},"i":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}},"r":{"docs":{},"e":{"docs":{},"a":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"d":{"docs":{},"e":{"docs":{},"b":{"docs":{},"u":{"docs":{},"g":{"docs":{},")":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"e":{"docs":{},"r":{"docs":{},"r":{"docs":{},"o":{"docs":{},"r":{"docs":{},")":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"n":{"docs":{},"o":{"docs":{},"n":{"docs":{},"e":{"docs":{},")":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"i":{"docs":{},"c":{"docs":{},"e":{"docs":{},")":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"s":{"docs":{},"a":{"docs":{},"t":{"docs":{},"o":{"docs":{},"s":{"docs":{},"h":{"docs":{},"i":{"docs":{},"s":{"docs":{},")":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"i":{"docs":{},"d":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}},"e":{"docs":{},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"u":{"docs":{},"c":{"docs":{},"h":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"w":{"docs":{},"a":{"docs":{},"r":{"docs":{},"n":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},")":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"i":{"docs":{},"l":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"p":{"docs":{},")":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"r":{"docs":{},"f":{"docs":{},"c":{"docs":{},"s":{"docs":{},")":{"docs":{},".":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}}}}}}},"s":{"docs":{},"k":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},".":{"docs":{},".":{"docs":{},".":{"docs":{},")":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"f":{"docs":{},"s":{"docs":{},"m":{"docs":{},")":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"h":{"docs":{},"e":{"docs":{},")":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"l":{"docs":{},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},"s":{"docs":{},"t":{"docs":{},")":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":3.333333333333333}}}}}}},"y":{"docs":{},"e":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0029644268774703555}}}}}},"i":{"docs":{},"m":{"docs":{},"i":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"h":{"docs":{},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}},"u":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"u":{"docs":{},"n":{"docs":{},"i":{"docs":{},"f":{"docs":{},"o":{"docs":{},"r":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}},"p":{"docs":{},"o":{"docs":{},"s":{"docs":{},"i":{"docs":{},"t":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"=":{"docs":{"./":{"ref":"./","tf":0.005494505494505495},"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.015267175572519083},"API.html":{"ref":"API.html","tf":0.00015384615384615385},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.049019607843137254},"SERVICES.html":{"ref":"SERVICES.html","tf":0.05},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}},">":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542},"API.html":{"ref":"API.html","tf":0.0003076923076923077},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}}}},"@":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}},"d":{"docs":{},"a":{"docs":{},"t":{"docs":{},"a":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0003076923076923077}},".":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"f":{"docs":{},"a":{"docs":{},"b":{"docs":{},"r":{"docs":{},"i":{"docs":{},"c":{"docs":{},"/":{"docs":{},"c":{"docs":{},"o":{"docs":{},"r":{"docs":{"./":{"ref":"./","tf":0.005494505494505495},"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542},"SERVICES.html":{"ref":"SERVICES.html","tf":0.025}},"e":{"docs":{},"/":{"docs":{},"s":{"docs":{},"e":{"docs":{},"r":{"docs":{},"v":{"docs":{},"i":{"docs":{},"c":{"docs":{},"e":{"docs":{},"s":{"docs":{},"/":{"docs":{},"b":{"docs":{},"i":{"docs":{},"t":{"docs":{},"c":{"docs":{},"o":{"docs":{},"i":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}},"~":{"docs":{},"b":{"docs":{},"i":{"docs":{},"t":{"docs":{},"c":{"docs":{},"o":{"docs":{},"i":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"d":{"docs":{},"o":{"docs":{},"o":{"docs":{},"r":{"docs":{},"m":{"docs":{},"a":{"docs":{},"n":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}}}}},"h":{"docs":{},"t":{"docs":{},"t":{"docs":{},"p":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}},"s":{"docs":{},"o":{"docs":{},"u":{"docs":{},"n":{"docs":{},"d":{"docs":{},"t":{"docs":{},"r":{"docs":{},"a":{"docs":{},"c":{"docs":{},"k":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}}}}}}}},"b":{"docs":{},"i":{"docs":{},"t":{"docs":{},"c":{"docs":{},"o":{"docs":{},"i":{"docs":{},"n":{"docs":{"SERVICES.html":{"ref":"SERVICES.html","tf":0.025}}}}}}}}},"l":{"docs":{},"i":{"docs":{},"g":{"docs":{},"h":{"docs":{},"t":{"docs":{},"n":{"docs":{"SERVICES.html":{"ref":"SERVICES.html","tf":0.025}}}}}}}},"m":{"docs":{},"a":{"docs":{},"t":{"docs":{},"r":{"docs":{},"i":{"docs":{},"x":{"docs":{"SERVICES.html":{"ref":"SERVICES.html","tf":0.025}}}}}}}}},"p":{"docs":{},"r":{"docs":{},"o":{"docs":{},"t":{"docs":{},"o":{"docs":{},"c":{"docs":{},"o":{"docs":{},"l":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}}}}}}}}}}}},"t":{"docs":{},"y":{"docs":{},"p":{"docs":{},"e":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"b":{"docs":{},"u":{"docs":{},"f":{"docs":{},"f":{"docs":{},"e":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},"i":{"docs":{},"t":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"i":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"p":{"docs":{},"a":{"docs":{},"r":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}}}}}}}}},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.003076923076923077},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.0784313725490196},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}},"(":{"docs":{},"[":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{},"]":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}},")":{"docs":{},";":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.0196078431372549}}}}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0012307692307692308}},"p":{"docs":{},"u":{"docs":{},"b":{"docs":{},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"s":{"docs":{},"i":{"docs":{},"g":{"docs":{},"n":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},".":{"docs":{},"s":{"docs":{},"i":{"docs":{},"g":{"docs":{},"n":{"docs":{},"a":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"e":{"docs":{},";":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}}}}}}}}}}}}}}}}}}},"t":{"docs":{},"o":{"docs":{},"b":{"docs":{},"u":{"docs":{},"f":{"docs":{},"f":{"docs":{},"e":{"docs":{},"r":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"o":{"docs":{},"n":{"docs":{},"(":{"docs":{},"'":{"docs":{},"m":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},"a":{"docs":{},"g":{"docs":{},"e":{"docs":{},"'":{"docs":{},",":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}}}}}}}}}}}}}}}},":":{"docs":{},"'":{"docs":{},",":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}}}}},"s":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"i":{"docs":{},"v":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}}}}},"c":{"docs":{},"o":{"docs":{},"u":{"docs":{},"n":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}},"i":{"docs":{},"n":{"docs":{},"d":{"docs":{},"e":{"docs":{},"x":{"docs":{},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}}},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}}}},"r":{"docs":{},"d":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}},"p":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}},"u":{"docs":{},"m":{"docs":{},"u":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"h":{"docs":{},"i":{"docs":{},"e":{"docs":{},"v":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}},"u":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"d":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0007692307692307692},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{"API.html":{"ref":"API.html","tf":0.0010769230769230769},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},":":{"docs":{},"p":{"docs":{},"o":{"docs":{},"r":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"e":{"docs":{},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}},"i":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00230566534914361},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.004240282685512367}},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"v":{"docs":{},"e":{"docs":{},"r":{"docs":{},"t":{"docs":{},"i":{"docs":{},"s":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}},"s":{"docs":{},"a":{"docs":{},"r":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"a":{"docs":{},"n":{"docs":{},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}}},"t":{"docs":{},"a":{"docs":{},"g":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"o":{"docs":{},"p":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}},"g":{"docs":{},"r":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"e":{"docs":{},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"s":{"docs":{},",":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}}}}}}},"a":{"docs":{},"i":{"docs":{},"n":{"docs":{},"s":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}}},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"g":{"docs":{},"r":{"docs":{},"e":{"docs":{},"g":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"r":{"docs":{},"e":{"docs":{},"a":{"docs":{},"d":{"docs":{},"i":{"docs":{"./":{"ref":"./","tf":0.005494505494505495},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"g":{"docs":{},"o":{"docs":{},"r":{"docs":{},"i":{"docs":{},"t":{"docs":{},"h":{"docs":{},"m":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},".":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}},"w":{"docs":{},"a":{"docs":{},"y":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}},"l":{"docs":{},"o":{"docs":{},"w":{"docs":{"SERVICES.html":{"ref":"SERVICES.html","tf":0.025},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0036231884057971015},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.004240282685512367}}},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"a":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"e":{"docs":{},"x":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"i":{"docs":{},"g":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"c":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}},"t":{"docs":{},"c":{"docs":{},"o":{"docs":{},"i":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"e":{"docs":{},"r":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"a":{"docs":{},"t":{"docs":{},"i":{"docs":{},"v":{"docs":{},"e":{"docs":{},"s":{"docs":{},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}}}}},"o":{"docs":{},"n":{"docs":{},"g":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}},"n":{"docs":{},"y":{"docs":{},".":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}},"t":{"docs":{},"h":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"a":{"docs":{},"l":{"docs":{},"a":{"docs":{},"g":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"o":{"docs":{},"t":{"docs":{},"h":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"e":{"docs":{},"r":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"s":{"docs":{},"'":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"c":{"docs":{},"h":{"docs":{},"o":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00230566534914361}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"d":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"r":{"docs":{},"e":{"docs":{},"w":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"n":{"docs":{},"u":{"docs":{},"a":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"p":{"docs":{},"i":{"docs":{"./":{"ref":"./","tf":0.008241758241758242},"API.html":{"ref":"API.html","tf":2.5}}},"p":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0043076923076923075}},"l":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"c":{"docs":{"./":{"ref":"./","tf":0.008241758241758242},"API.html":{"ref":"API.html","tf":0.002},"whitepaper.html":{"ref":"whitepaper.html","tf":0.007246376811594203},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.009187279151943463}},"a":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},".":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.00046153846153846153}}},"s":{"docs":{},".":{"docs":{"./":{"ref":"./","tf":0.005494505494505495},"API.html":{"ref":"API.html","tf":0.00046153846153846153},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}},",":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"'":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}},"y":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"r":{"docs":{},"o":{"docs":{},"a":{"docs":{},"c":{"docs":{},"h":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}}}}}},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.0018461538461538461}}}}}}}}}},"(":{"docs":{},"d":{"docs":{},"e":{"docs":{},"f":{"docs":{},"i":{"docs":{},"n":{"docs":{},"i":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"a":{"docs":{},"t":{"docs":{},"t":{"docs":{},"a":{"docs":{},"c":{"docs":{},"h":{"docs":{},"(":{"docs":{},"e":{"docs":{},"l":{"docs":{},"e":{"docs":{},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}},"c":{"docs":{},"o":{"docs":{},"m":{"docs":{},"m":{"docs":{},"i":{"docs":{},"t":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"n":{"docs":{},"s":{"docs":{},"u":{"docs":{},"m":{"docs":{},"e":{"docs":{},"(":{"docs":{},"r":{"docs":{},"e":{"docs":{},"s":{"docs":{},"o":{"docs":{},"u":{"docs":{},"r":{"docs":{},"c":{"docs":{},"e":{"docs":{},"s":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}},"d":{"docs":{},"e":{"docs":{},"f":{"docs":{},"e":{"docs":{},"r":{"docs":{},"(":{"docs":{},"a":{"docs":{},"u":{"docs":{},"t":{"docs":{},"h":{"docs":{},"o":{"docs":{},"r":{"docs":{},"i":{"docs":{},"t":{"docs":{},"y":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}},"i":{"docs":{},"n":{"docs":{},"e":{"docs":{},"(":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{},"e":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"s":{"docs":{},"e":{"docs":{},"r":{"docs":{},"i":{"docs":{},"a":{"docs":{},"l":{"docs":{},"i":{"docs":{},"z":{"docs":{},"e":{"docs":{},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}},"e":{"docs":{},"n":{"docs":{},"v":{"docs":{},"e":{"docs":{},"l":{"docs":{},"o":{"docs":{},"p":{"docs":{},"(":{"docs":{},"s":{"docs":{},"e":{"docs":{},"l":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}},"f":{"docs":{},"o":{"docs":{},"r":{"docs":{},"k":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"i":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"n":{"docs":{},"h":{"docs":{},"e":{"docs":{},"r":{"docs":{},"i":{"docs":{},"t":{"docs":{},"s":{"docs":{},"(":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"b":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}},"n":{"docs":{},"o":{"docs":{},"w":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"r":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{},"e":{"docs":{},"r":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"s":{"docs":{},"e":{"docs":{},"r":{"docs":{},"i":{"docs":{},"a":{"docs":{},"l":{"docs":{},"i":{"docs":{},"z":{"docs":{},"e":{"docs":{},"(":{"docs":{},"[":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},"]":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}},"t":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"o":{"docs":{},"p":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"t":{"docs":{},"o":{"docs":{},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"r":{"docs":{},"u":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},"s":{"docs":{},"o":{"docs":{},"u":{"docs":{},"r":{"docs":{},"c":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}},"u":{"docs":{},"s":{"docs":{},"e":{"docs":{},"(":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{},"e":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"i":{"docs":{},"x":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"a":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"o":{"docs":{},"v":{"docs":{},"e":{"docs":{},"r":{"docs":{},"r":{"docs":{},"i":{"docs":{},"d":{"docs":{},"e":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}},"r":{"docs":{},"t":{"docs":{},"i":{"docs":{},"f":{"docs":{},"i":{"docs":{},"c":{"docs":{},"i":{"docs":{"./":{"ref":"./","tf":0.005494505494505495}}}}}}}},"b":{"docs":{},"i":{"docs":{},"t":{"docs":{},"r":{"docs":{},"a":{"docs":{},"r":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper.html":{"ref":"whitepaper.html","tf":0.001976284584980237},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"c":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915}},"h":{"docs":{},"i":{"docs":{},"t":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915}}}}}}}}}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"r":{"docs":{},"a":{"docs":{},"y":{"docs":{"API.html":{"ref":"API.html","tf":0.002307692307692308},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"n":{"docs":{},"g":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}}}}}}},"s":{"docs":{},"s":{"docs":{},"i":{"docs":{},"s":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.005494505494505495}}}},"g":{"docs":{},"n":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"e":{"docs":{},"m":{"docs":{},"b":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"r":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"t":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"u":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"p":{"docs":{},"t":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"y":{"docs":{},"n":{"docs":{},"c":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}},"h":{"docs":{},"r":{"docs":{},"o":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"m":{"docs":{},"m":{"docs":{},"e":{"docs":{},"t":{"docs":{},"r":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"v":{"docs":{},"a":{"docs":{},"i":{"docs":{},"l":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00230566534914361},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"e":{"docs":{},"r":{"docs":{},"a":{"docs":{},"g":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"w":{"docs":{},"a":{"docs":{},"i":{"docs":{},"t":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"y":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"b":{"docs":{},"s":{"docs":{},"o":{"docs":{},"l":{"docs":{},"u":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"t":{"docs":{},"r":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"i":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}},"o":{"docs":{},"v":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"e":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"m":{"docs":{},"o":{"docs":{},"u":{"docs":{},"n":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"p":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}},"t":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"o":{"docs":{},"m":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}}}},"t":{"docs":{},"a":{"docs":{},"c":{"docs":{},"h":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}}}}},"e":{"docs":{},"m":{"docs":{},"p":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"n":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}}}},"r":{"docs":{},"i":{"docs":{},"b":{"docs":{},"u":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"u":{"docs":{},"t":{"docs":{},"h":{"docs":{},"o":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"i":{"docs":{},"t":{"docs":{},"y":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0012307692307692308},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"'":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"o":{"docs":{},"m":{"docs":{},"a":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"d":{"docs":{},"i":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"h":{"docs":{},"e":{"docs":{},"a":{"docs":{},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"i":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}},"b":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"a":{"docs":{},"s":{"docs":{},"e":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643}}},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"c":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"SERVICES.html":{"ref":"SERVICES.html","tf":0.025},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"s":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"l":{"docs":{},"a":{"docs":{},"n":{"docs":{},"c":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}},"r":{"docs":{},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"b":{"docs":{},"o":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}},"c":{"docs":{},"k":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"d":{"docs":{},"r":{"docs":{},"o":{"docs":{},"p":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"g":{"docs":{},"r":{"docs":{},"o":{"docs":{},"u":{"docs":{},"n":{"docs":{},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}},"n":{"docs":{},"k":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"u":{"docs":{},"m":{"docs":{},"'":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"f":{"docs":{},"o":{"docs":{},"r":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"s":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}},"c":{"docs":{},"h":{"3":{"2":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"docs":{}},"docs":{}},"a":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}},"o":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}},"g":{"docs":{},"i":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}},"h":{"docs":{},"a":{"docs":{},"v":{"docs":{},"i":{"docs":{},"o":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"t":{"docs":{},"w":{"docs":{},"e":{"docs":{},"e":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}}},"r":{"docs":{},"l":{"docs":{},"i":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"n":{"docs":{},"e":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"y":{"docs":{},"o":{"docs":{},"n":{"docs":{},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}}},"r":{"docs":{},"o":{"docs":{},"w":{"docs":{},"s":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}},"e":{"docs":{},"r":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}},".":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}}},"a":{"docs":{},"d":{"docs":{},"c":{"docs":{},"a":{"docs":{},"s":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0013846153846153845},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00230566534914361},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}}}}}}}}},"a":{"docs":{},"c":{"docs":{},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"u":{"docs":{},"i":{"docs":{},"l":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}}}}},"n":{"docs":{},"d":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}},"e":{"docs":{},",":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}}},"f":{"docs":{},"f":{"docs":{},"e":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.005384615384615384}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0010769230769230769}}}}}}},"b":{"docs":{},"b":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}},"g":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"r":{"docs":{},"g":{"docs":{},"e":{"docs":{},"o":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"y":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}},"e":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"i":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"c":{"docs":{},"o":{"docs":{},"i":{"docs":{},"n":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.015267175572519083},"API.html":{"ref":"API.html","tf":0.004},"SERVICES.html":{"ref":"SERVICES.html","tf":0.05},"whitepaper.html":{"ref":"whitepaper.html","tf":0.008563899868247694},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.01060070671378092}},"(":{"docs":{},"{":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}},"[":{"docs":{},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"s":{"docs":{},"]":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}}}}}}}}}}}}},")":{"docs":{},";":{"docs":{"SERVICES.html":{"ref":"SERVICES.html","tf":0.025}}}}},".":{"docs":{},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},";":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542},"SERVICES.html":{"ref":"SERVICES.html","tf":0.025}}}}}}}},"o":{"docs":{},"p":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"_":{"docs":{},"c":{"docs":{},"o":{"docs":{},"n":{"docs":{},"n":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{},"s":{"docs":{},"p":{"docs":{},"v":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}},"h":{"docs":{},"a":{"docs":{},"n":{"docs":{},"d":{"docs":{},"l":{"docs":{},"e":{"docs":{},"b":{"docs":{},"l":{"docs":{},"o":{"docs":{},"c":{"docs":{},"k":{"docs":{},"f":{"docs":{},"r":{"docs":{},"o":{"docs":{},"m":{"docs":{},"s":{"docs":{},"p":{"docs":{},"v":{"docs":{},"(":{"docs":{},"m":{"docs":{},"s":{"docs":{},"g":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}},"c":{"docs":{},"o":{"docs":{},"m":{"docs":{},"m":{"docs":{},"i":{"docs":{},"t":{"docs":{},"t":{"docs":{},"e":{"docs":{},"d":{"docs":{},"b":{"docs":{},"l":{"docs":{},"o":{"docs":{},"c":{"docs":{},"k":{"docs":{},"(":{"docs":{},"b":{"docs":{},"l":{"docs":{},"o":{"docs":{},"c":{"docs":{},"k":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}}}},"p":{"docs":{},"e":{"docs":{},"e":{"docs":{},"r":{"docs":{},"p":{"docs":{},"a":{"docs":{},"c":{"docs":{},"k":{"docs":{},"e":{"docs":{},"t":{"docs":{},"(":{"docs":{},"m":{"docs":{},"s":{"docs":{},"g":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}},"t":{"docs":{},"r":{"docs":{},"a":{"docs":{},"n":{"docs":{},"s":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"f":{"docs":{},"r":{"docs":{},"o":{"docs":{},"m":{"docs":{},"s":{"docs":{},"p":{"docs":{},"v":{"docs":{},"(":{"docs":{},"t":{"docs":{},"x":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"p":{"docs":{},"r":{"docs":{},"e":{"docs":{},"p":{"docs":{},"a":{"docs":{},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"r":{"docs":{},"a":{"docs":{},"n":{"docs":{},"s":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"(":{"docs":{},"o":{"docs":{},"b":{"docs":{},"j":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"u":{"docs":{},"b":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"b":{"docs":{},"e":{"docs":{},"t":{"docs":{},"o":{"docs":{},"s":{"docs":{},"h":{"docs":{},"a":{"docs":{},"r":{"docs":{},"d":{"docs":{},"(":{"docs":{},"s":{"docs":{},"h":{"docs":{},"a":{"docs":{},"r":{"docs":{},"d":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}}}}}}},"c":{"docs":{},"o":{"docs":{},"n":{"docs":{},"n":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{},"(":{"docs":{},"a":{"docs":{},"d":{"docs":{},"d":{"docs":{},"r":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}},"h":{"docs":{},"e":{"docs":{},"i":{"docs":{},"g":{"docs":{},"h":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"m":{"docs":{},"u":{"docs":{},"t":{"docs":{},"a":{"docs":{},"b":{"docs":{},"l":{"docs":{},"e":{"docs":{},"t":{"docs":{},"r":{"docs":{},"a":{"docs":{},"n":{"docs":{},"s":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}},"t":{"docs":{},"i":{"docs":{},"p":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"r":{"docs":{},"a":{"docs":{},"n":{"docs":{},"s":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"u":{"docs":{},"a":{"docs":{},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"'":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}}},"a":{"docs":{},"d":{"docs":{},"d":{"docs":{},"r":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"t":{"docs":{},"r":{"docs":{},"a":{"docs":{},"n":{"docs":{},"s":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"n":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231}}}},"p":{"2":{"4":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"docs":{}},"docs":{}},"r":{"docs":{},"t":{"docs":{},"h":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"c":{"docs":{},"o":{"docs":{},"i":{"docs":{},"n":{"docs":{},"'":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"t":{"docs":{},"x":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"l":{"docs":{},"i":{"docs":{},"n":{"docs":{},"d":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"l":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}}}}}}},"o":{"docs":{},"b":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.002307692307692308}}}},"c":{"docs":{},"k":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0029644268774703555},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"m":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},"a":{"docs":{},"g":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"c":{"docs":{},"h":{"docs":{},"a":{"docs":{},"i":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}},")":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"s":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"s":{"docs":{},"s":{"docs":{},"o":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"o":{"docs":{},"d":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}}},"y":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}}}}},"n":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}}}},"o":{"docs":{},"l":{"docs":{},"e":{"docs":{},"a":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.004153846153846154},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"u":{"docs":{},"n":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"a":{"docs":{},"r":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"t":{"docs":{},"h":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"t":{"docs":{},"c":{"docs":{"SERVICES.html":{"ref":"SERVICES.html","tf":0.025}},")":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"y":{"docs":{},"t":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}},"s":{"docs":{},")":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"z":{"docs":{},"a":{"docs":{},"n":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},")":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00230566534914361}}},"]":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"h":{"docs":{},"a":{"docs":{},"n":{"docs":{},"n":{"docs":{},"e":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.002769230769230769},"whitepaper.html":{"ref":"whitepaper.html","tf":0.002635046113306983},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}},",":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}},"'":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"(":{"docs":{},"[":{"docs":{},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"s":{"docs":{},"]":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"a":{"docs":{},"d":{"docs":{},"d":{"docs":{},"(":{"docs":{},"a":{"docs":{},"m":{"docs":{},"o":{"docs":{},"u":{"docs":{},"n":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}},"f":{"docs":{},"u":{"docs":{},"n":{"docs":{},"d":{"docs":{},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}},"o":{"docs":{},"p":{"docs":{},"e":{"docs":{},"n":{"docs":{},"(":{"docs":{},"c":{"docs":{},"h":{"docs":{},"a":{"docs":{},"n":{"docs":{},"n":{"docs":{},"e":{"docs":{},"l":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}},"s":{"docs":{},"\"":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"g":{"docs":{"API.html":{"ref":"API.html","tf":0.0018461538461538461},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"e":{"docs":{},"a":{"docs":{},"d":{"docs":{},"d":{"docs":{},"r":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}}}}},"d":{"docs":{},"e":{"docs":{},"p":{"docs":{},"t":{"docs":{},"h":{"docs":{},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}}},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"i":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.002307692307692308},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0035335689045936395}},"(":{"docs":{},"g":{"docs":{},"e":{"docs":{},"n":{"docs":{},"e":{"docs":{},"s":{"docs":{},"i":{"docs":{},"s":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"a":{"docs":{},"b":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}}}}},"s":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"l":{"docs":{},"l":{"docs":{},"e":{"docs":{},"n":{"docs":{},"g":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"r":{"docs":{},"l":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"i":{"docs":{},"l":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}}}}},"o":{"docs":{},"o":{"docs":{},"s":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"e":{"docs":{},"c":{"docs":{},"k":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"l":{"docs":{},"i":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0007692307692307692}},"(":{"docs":{},"[":{"docs":{},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"s":{"docs":{},"]":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"o":{"docs":{},"p":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"o":{"docs":{},"n":{"docs":{},"e":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}},"c":{"docs":{},"k":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}}}}},"s":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"u":{"docs":{},"r":{"docs":{},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}},"a":{"docs":{},"i":{"docs":{},"m":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}}}},"s":{"docs":{},"s":{"docs":{"API.html":{"ref":"API.html","tf":0.004615384615384616},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}}},"e":{"docs":{},"m":{"docs":{},"i":{"docs":{},"t":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}},"x":{"docs":{},"t":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.0012307692307692308}}}}}}}}}},"p":{"docs":{},"r":{"docs":{},"o":{"docs":{},"p":{"docs":{},"e":{"docs":{},"r":{"docs":{},"t":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.0012307692307692308}}}}}}}}}}}},"u":{"docs":{},"d":{"docs":{},"i":{"docs":{},"o":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"e":{"docs":{},"a":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"v":{"docs":{},"e":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"u":{"docs":{},"s":{"docs":{},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{},"_":{"docs":{},"a":{"docs":{},"n":{"docs":{},"c":{"docs":{},"h":{"docs":{},"o":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"r":{"docs":{},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"m":{"docs":{},"p":{"docs":{},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}}},"o":{"docs":{},"d":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},",":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"l":{"docs":{},"l":{"docs":{},"a":{"docs":{},"b":{"docs":{},"o":{"docs":{},"r":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"p":{"docs":{},"s":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0038461538461538464},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"'":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"(":{"docs":{},"[":{"docs":{},"c":{"docs":{},"o":{"docs":{},"n":{"docs":{},"f":{"docs":{},"i":{"docs":{},"g":{"docs":{},"u":{"docs":{},"r":{"docs":{},"a":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"]":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}}}}}}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0013846153846153845}},"_":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"c":{"docs":{},"h":{"docs":{},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{},"(":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}},"a":{"docs":{},"s":{"docs":{},"m":{"docs":{},"e":{"docs":{},"r":{"docs":{},"k":{"docs":{},"l":{"docs":{},"e":{"docs":{},"t":{"docs":{},"r":{"docs":{},"e":{"docs":{},"e":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}},"c":{"docs":{},"r":{"docs":{},"e":{"docs":{},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},"(":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},"i":{"docs":{},"t":{"docs":{},"y":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}},"f":{"docs":{},"i":{"docs":{},"n":{"docs":{},"d":{"docs":{},"b":{"docs":{},"y":{"docs":{},"f":{"docs":{},"i":{"docs":{},"e":{"docs":{},"l":{"docs":{},"d":{"docs":{},"(":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{},"e":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{},"e":{"docs":{},"(":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"s":{"docs":{},"y":{"docs":{},"m":{"docs":{},"b":{"docs":{},"o":{"docs":{},"l":{"docs":{},"(":{"docs":{},"s":{"docs":{},"y":{"docs":{},"m":{"docs":{},"b":{"docs":{},"o":{"docs":{},"l":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}}},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"b":{"docs":{},"y":{"docs":{},"i":{"docs":{},"d":{"docs":{},"(":{"docs":{},"i":{"docs":{},"d":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"l":{"docs":{},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}},"i":{"docs":{},"m":{"docs":{},"p":{"docs":{},"o":{"docs":{},"r":{"docs":{},"t":{"docs":{},"(":{"docs":{},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}},"l":{"docs":{},"i":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"m":{"docs":{},"a":{"docs":{},"p":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"p":{"docs":{},"u":{"docs":{},"s":{"docs":{},"h":{"docs":{},"(":{"docs":{},"d":{"docs":{},"a":{"docs":{},"t":{"docs":{},"a":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"t":{"docs":{},"o":{"docs":{},"t":{"docs":{},"y":{"docs":{},"p":{"docs":{},"e":{"docs":{},"d":{"docs":{},"a":{"docs":{},"r":{"docs":{},"r":{"docs":{},"a":{"docs":{},"y":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}},"e":{"docs":{},"m":{"docs":{},"i":{"docs":{},"t":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}},"s":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}}},"m":{"docs":{},"m":{"docs":{},"a":{"docs":{},"n":{"docs":{},"d":{"docs":{"./":{"ref":"./","tf":0.005494505494505495},"API.html":{"ref":"API.html","tf":0.00046153846153846153}}}}},"o":{"docs":{},"n":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"i":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0013846153846153845},"whitepaper.html":{"ref":"whitepaper.html","tf":0.002635046113306983},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.004240282685512367}},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"t":{"docs":{},"e":{"docs":{},"d":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},")":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"u":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"p":{"docs":{},"l":{"docs":{},"e":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"x":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00230566534914361},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"i":{"docs":{},"t":{"docs":{},"y":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"o":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},"s":{"docs":{},",":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},";":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"s":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692},"whitepaper.html":{"ref":"whitepaper.html","tf":0.002635046113306983},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}},"i":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}},"a":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"i":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.0018461538461538461},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"r":{"docs":{},"'":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"(":{"docs":{},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"s":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"_":{"docs":{},"f":{"docs":{},"r":{"docs":{},"o":{"docs":{},"m":{"docs":{},"j":{"docs":{},"a":{"docs":{},"v":{"docs":{},"a":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{},"(":{"docs":{},"b":{"docs":{},"o":{"docs":{},"d":{"docs":{},"y":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}}},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"j":{"docs":{},"a":{"docs":{},"v":{"docs":{},"a":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{},"a":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}},"u":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00691699604743083},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.008480565371024734}},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"a":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"\"":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},".":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"”":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"s":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"”":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}},"e":{"docs":{},"d":{"docs":{},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"e":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"i":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"r":{"docs":{},"o":{"docs":{},"m":{"docs":{},"i":{"docs":{},"s":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"b":{"docs":{},"i":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"n":{"docs":{},"j":{"docs":{},"u":{"docs":{},"r":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}},"s":{"docs":{},"o":{"docs":{},"l":{"docs":{},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"l":{"docs":{},"o":{"docs":{},"g":{"docs":{},"(":{"docs":{},"'":{"docs":{},"r":{"docs":{},"e":{"docs":{},"c":{"docs":{},"e":{"docs":{},"i":{"docs":{},"v":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}}}},"m":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},"a":{"docs":{},"g":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}}}}}}}}}}}}},"e":{"docs":{},"r":{"docs":{},"r":{"docs":{},"o":{"docs":{},"r":{"docs":{},"(":{"docs":{},"'":{"docs":{},"[":{"docs":{},"q":{"docs":{},"u":{"docs":{},"i":{"docs":{},"c":{"docs":{},"k":{"docs":{},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{},"]":{"docs":{},"'":{"docs":{},",":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}}}}}}}}}}}}}}}}}}}}}},"t":{"docs":{"./":{"ref":"./","tf":0.005494505494505495},"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.015267175572519083},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.049019607843137254},"SERVICES.html":{"ref":"SERVICES.html","tf":0.05}},"r":{"docs":{},"u":{"docs":{},"c":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0032938076416337285},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}},"o":{"docs":{},"r":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"e":{"docs":{},"d":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"i":{"docs":{},"v":{"docs":{},"e":{"docs":{},"l":{"docs":{},"y":{"docs":{},"?":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}},"a":{"docs":{},"i":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}}}}}}}},"e":{"docs":{},"n":{"docs":{},"s":{"docs":{},"u":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.007067137809187279}},"s":{"docs":{},"(":{"docs":{},"[":{"docs":{},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"s":{"docs":{},"]":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"i":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}},"u":{"docs":{},"m":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"SERVICES.html":{"ref":"SERVICES.html","tf":0.025},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"p":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}}}}}}}},"e":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"r":{"docs":{},"s":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"t":{"docs":{},"a":{"docs":{},"i":{"docs":{},"n":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"s":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0009230769230769231},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0029644268774703555},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"\"":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"x":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"u":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"r":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0013846153846153845},"whitepaper.html":{"ref":"whitepaper.html","tf":0.006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0063604240282685515}},"'":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"s":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}},"\"":{"docs":{},")":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}}}}},"s":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"o":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}}}},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915}}},"u":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"d":{"docs":{},"i":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"s":{"docs":{},"\"":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}},"f":{"docs":{},"i":{"docs":{},"g":{"docs":{"API.html":{"ref":"API.html","tf":0.0015384615384615385}},".":{"docs":{},"v":{"docs":{},"e":{"docs":{},"r":{"docs":{},"b":{"docs":{},"o":{"docs":{},"s":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"u":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.005846153846153846}},"a":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0010769230769230769}}}}}}}}}}},"r":{"docs":{},"m":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"l":{"docs":{},"i":{"docs":{},"c":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}}}}}}},"n":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.002},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}}}}}}}}}}},"v":{"docs":{},"e":{"docs":{},"r":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0015384615384615385}}},"s":{"docs":{},"a":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"?":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}},"n":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"c":{"docs":{},"e":{"docs":{},"p":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"r":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"l":{"docs":{},"u":{"docs":{},"s":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"r":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},",":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}},"/":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}},"r":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"l":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}},"u":{"docs":{},"n":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"e":{"docs":{},"r":{"docs":{},"p":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{},"y":{"docs":{},")":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},".":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}}}},"p":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"f":{"docs":{},"f":{"docs":{},"e":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}}}}},"v":{"docs":{},"e":{"docs":{},"r":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}}}}},"h":{"docs":{},"e":{"docs":{},"n":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"o":{"docs":{},"r":{"docs":{},"d":{"docs":{},"i":{"docs":{},"n":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"a":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}}},"p":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"s":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"i":{"docs":{},"n":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"r":{"docs":{},"e":{"docs":{},"a":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.013736263736263736},"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542},"API.html":{"ref":"API.html","tf":0.006},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643}},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"a":{"docs":{},"w":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"f":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"o":{"docs":{},"w":{"docs":{},"d":{"docs":{},"f":{"docs":{},"u":{"docs":{},"n":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"s":{"docs":{},"s":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}},"y":{"docs":{},"p":{"docs":{},"t":{"docs":{},"o":{"docs":{},"g":{"docs":{},"r":{"docs":{},"a":{"docs":{},"p":{"docs":{},"h":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.001976284584980237},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"l":{"docs":{},"o":{"docs":{},"g":{"docs":{},"y":{"docs":{},"c":{"docs":{},"r":{"docs":{},"y":{"docs":{},"p":{"docs":{},"t":{"docs":{},"o":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}}}},"s":{"docs":{},"y":{"docs":{},"s":{"docs":{},"t":{"docs":{},"e":{"docs":{},"m":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}}},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"l":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"u":{"docs":{},"r":{"docs":{},"r":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0035384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"c":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"y":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"i":{"docs":{},"o":{"docs":{},"u":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"l":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"a":{"docs":{},"l":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"e":{"docs":{},"d":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"c":{"docs":{},"u":{"docs":{},"l":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"s":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}},"h":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"r":{"docs":{},"r":{"docs":{},"i":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}}}},"s":{"docs":{},"t":{"docs":{},"e":{"docs":{},"n":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"m":{"docs":{},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}},"n":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"p":{"docs":{},"a":{"docs":{},"b":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"i":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"t":{"docs":{},"a":{"docs":{},"l":{"docs":{},"y":{"docs":{},"s":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"z":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"e":{"docs":{},"r":{"docs":{},"t":{"docs":{},"a":{"docs":{},"i":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"a":{"docs":{},"s":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}},"n":{"docs":{},"t":{"docs":{},"r":{"docs":{},"a":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915}}}}}}}},"i":{"docs":{},"r":{"docs":{},"c":{"docs":{},"u":{"docs":{},"i":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}},"t":{"docs":{},"a":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}},"s":{"docs":{},"s":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}},"y":{"docs":{},"c":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}}}}}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"d":{"docs":{},"e":{"docs":{},"c":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},"r":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0003076923076923077},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}}}}}},"i":{"docs":{},"s":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}},"r":{"docs":{},"y":{"docs":{},"p":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"p":{"docs":{},"l":{"docs":{},"o":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"y":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"r":{"docs":{},"e":{"docs":{},"c":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}},"t":{"docs":{},"h":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"b":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"p":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.02676923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},")":{"docs":{},".":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}}}},"i":{"docs":{},"g":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"s":{"docs":{},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},"d":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"e":{"docs":{},"r":{"docs":{},"v":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"p":{"docs":{},"i":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"t":{"docs":{},"r":{"docs":{},"o":{"docs":{},"y":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"v":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}},"e":{"docs":{},"l":{"docs":{},"o":{"docs":{},"p":{"docs":{"./":{"ref":"./","tf":0.005494505494505495},"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":3.3431372549019605},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}},"e":{"docs":{},"p":{"docs":{},"e":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"l":{"docs":{},"i":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"f":{"docs":{},"a":{"docs":{},"u":{"docs":{},"l":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0038461538461538464}}}}}},"e":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"n":{"docs":{},"s":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"i":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.0010769230769230769},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"i":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"e":{"docs":{},"d":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"l":{"docs":{},"e":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"i":{"docs":{},"v":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"e":{"docs":{},"r":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"t":{"docs":{},"a":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"m":{"docs":{},"o":{"docs":{},"n":{"docs":{},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"a":{"docs":{},"n":{"docs":{},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"r":{"docs":{},"i":{"docs":{},"v":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}}}}},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{},"m":{"docs":{},"i":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"i":{"docs":{},"s":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"i":{"docs":{},"c":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}}},"c":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"a":{"docs":{},"i":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"b":{"docs":{},"u":{"docs":{},"g":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"g":{"docs":{},"r":{"docs":{},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"n":{"docs":{},"o":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"i":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"o":{"docs":{},"r":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}}}}},"l":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{},"i":{"docs":{},"b":{"docs":{},"u":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.001976284584980237},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}}}}}}},"i":{"docs":{},"n":{"docs":{},"c":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}},"c":{"docs":{},"l":{"docs":{},"o":{"docs":{},"s":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}},"o":{"docs":{},"n":{"docs":{},"n":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"v":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"u":{"docs":{},"s":{"docs":{},"s":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"e":{"docs":{},"d":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"e":{"docs":{},"r":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"k":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}}}},"p":{"docs":{},"a":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}},"s":{"docs":{},"i":{"docs":{},"m":{"docs":{},"i":{"docs":{},"l":{"docs":{},"a":{"docs":{},"r":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}},"g":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"e":{"docs":{},"s":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}},"i":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}}}}},"f":{"docs":{},"f":{"docs":{},"i":{"docs":{},"c":{"docs":{},"u":{"docs":{},"l":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}}}}}},"l":{"docs":{},"l":{"docs":{},"e":{"docs":{},"y":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}},"v":{"docs":{},"e":{"docs":{},"r":{"docs":{},"g":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"i":{"docs":{},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}},"o":{"docs":{},"c":{"docs":{"./":{"ref":"./","tf":0.005494505494505495}},"s":{"docs":{},",":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}},"u":{"docs":{},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0036231884057971015},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"a":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},".":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}}}},"s":{"docs":{},".":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}},"'":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}},"o":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"m":{"docs":{},"a":{"docs":{},"n":{"docs":{},",":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}}}},"w":{"docs":{},"n":{"docs":{},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{},"e":{"docs":{},"a":{"docs":{},"m":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}}},"a":{"docs":{},"m":{"docs":{},"p":{"docs":{},"l":{"docs":{},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"m":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"a":{"docs":{},"i":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"e":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"i":{"docs":{},"n":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"u":{"docs":{},"r":{"docs":{},"e":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}},"a":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}},"p":{"docs":{},"l":{"docs":{},"e":{"docs":{},"x":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"i":{"docs":{},"c":{"docs":{},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}}},"a":{"docs":{},"t":{"docs":{},"a":{"docs":{"API.html":{"ref":"API.html","tf":0.0018461538461538461},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0032938076416337285},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.004240282685512367}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0010769230769230769},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}},"s":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"b":{"docs":{},"a":{"docs":{},"s":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}}}}}},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"m":{"docs":{},"g":{"docs":{},"r":{"docs":{},"d":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"v":{"docs":{},"i":{"docs":{},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"r":{"docs":{},"o":{"docs":{},"p":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"a":{"docs":{},"f":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}},"w":{"docs":{},"b":{"docs":{},"a":{"docs":{},"c":{"docs":{},"k":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"i":{"docs":{},"v":{"docs":{},"e":{"docs":{},"c":{"docs":{},"h":{"docs":{},"a":{"docs":{},"i":{"docs":{},"n":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"y":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"e":{"docs":{},"a":{"docs":{},"g":{"docs":{},"e":{"docs":{},"r":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}},"c":{"docs":{},"h":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}}}},"r":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"l":{"docs":{},"i":{"docs":{},"e":{"docs":{},"r":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"s":{"docs":{},"i":{"docs":{},"l":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}}},"d":{"docs":{},"i":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}},"u":{"docs":{},"c":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}},"g":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"m":{"docs":{},"p":{"docs":{},"a":{"docs":{},"s":{"docs":{},"s":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}},"o":{"docs":{},"w":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}},"i":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}}}},"u":{"docs":{},"l":{"docs":{},"a":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}},"e":{"docs":{},"r":{"docs":{},"g":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"e":{"docs":{},"d":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"b":{"docs":{},"e":{"docs":{},"d":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"n":{"docs":{},"a":{"docs":{},"b":{"docs":{},"l":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper.html":{"ref":"whitepaper.html","tf":0.001976284584980237}}}}},"v":{"docs":{},"i":{"docs":{},"r":{"docs":{},"o":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},"s":{"docs":{},",":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}}},"c":{"docs":{},"o":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.0021538461538461538}}},"u":{"docs":{},"r":{"docs":{},"a":{"docs":{},"g":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"n":{"docs":{},"t":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"r":{"docs":{},"y":{"docs":{},"p":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0029644268774703555},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}}}}}}},"g":{"docs":{},"i":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"t":{"docs":{},"i":{"docs":{},"t":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.0018461538461538461}}},"y":{"docs":{},"(":{"docs":{},"[":{"docs":{},"d":{"docs":{},"a":{"docs":{},"t":{"docs":{},"a":{"docs":{},"]":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}},"_":{"docs":{},"d":{"docs":{},"o":{"docs":{},"w":{"docs":{},"n":{"docs":{},"s":{"docs":{},"a":{"docs":{},"m":{"docs":{},"p":{"docs":{},"l":{"docs":{},"e":{"docs":{},"(":{"docs":{},"[":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},"]":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}}},"t":{"docs":{},"o":{"docs":{},"j":{"docs":{},"s":{"docs":{},"o":{"docs":{},"n":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"r":{"docs":{},"a":{"docs":{},"w":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},"t":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"r":{"docs":{},"o":{"docs":{},"p":{"docs":{},"y":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"u":{"docs":{},"m":{"docs":{},"e":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"a":{"docs":{},"n":{"docs":{},"g":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"e":{"docs":{},"r":{"docs":{},"g":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}},"f":{"docs":{},"o":{"docs":{},"r":{"docs":{},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"e":{"docs":{},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}}},"s":{"docs":{},"u":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"i":{"docs":{},"g":{"docs":{},"m":{"docs":{},"a":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"s":{"6":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"docs":{},"t":{"docs":{},"a":{"docs":{},"b":{"docs":{},"l":{"docs":{},"i":{"docs":{},"s":{"docs":{},"h":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}}}}}}}}}},"v":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"e":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"t":{"docs":{"./":{"ref":"./","tf":0.008241758241758242},"API.html":{"ref":"API.html","tf":0.0021538461538461538},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},",":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}},".":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}},"e":{"docs":{},"m":{"docs":{},"i":{"docs":{},"t":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0018461538461538461},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}},"e":{"docs":{},"r":{"docs":{},"p":{"docs":{},"r":{"docs":{},"o":{"docs":{},"p":{"docs":{},"e":{"docs":{},"r":{"docs":{},"t":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}}}}}},":":{"docs":{},"m":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},"a":{"docs":{},"g":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}},"{":{"docs":{},"m":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},"a":{"docs":{},"g":{"docs":{},"e":{"docs":{},"}":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}},"a":{"docs":{},"l":{"docs":{},"u":{"docs":{},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"x":{"docs":{},"a":{"docs":{},"m":{"docs":{},"p":{"docs":{},"l":{"docs":{"./":{"ref":"./","tf":0.01098901098901099},"whitepaper.html":{"ref":"whitepaper.html","tf":0.003952569169960474},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},"s":{"docs":{},",":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}},".":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"e":{"docs":{},"c":{"docs":{},"u":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}},"p":{"docs":{},"e":{"docs":{},"r":{"docs":{},"i":{"docs":{},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}}}},"c":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"e":{"docs":{},"d":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"n":{"docs":{},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"s":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"i":{"docs":{},"v":{"docs":{},"e":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},".":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"o":{"docs":{},"s":{"docs":{"./":{"ref":"./","tf":0.005494505494505495},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"a":{"docs":{},"n":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"s":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"l":{"docs":{},"i":{"docs":{},"c":{"docs":{},"i":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"l":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"o":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}},"e":{"docs":{},"r":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"t":{"docs":{},"e":{"docs":{},"n":{"docs":{},"s":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"r":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"r":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}},"e":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"c":{"docs":{},"e":{"docs":{},"p":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},")":{"docs":{},";":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}}}}},"h":{"docs":{},"a":{"docs":{},"n":{"docs":{},"g":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0029644268774703555},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},"(":{"docs":{},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"s":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}}}}}}}},"i":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"i":{"docs":{},"s":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0016923076923076924},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"h":{"docs":{},"i":{"docs":{},"b":{"docs":{},"i":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"g":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"f":{"docs":{},"f":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}},"s":{"docs":{},")":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}},"^":{"docs":{},"[":{"docs":{},"c":{"docs":{},"i":{"docs":{},"t":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}},"i":{"docs":{},"c":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}},"o":{"docs":{},"r":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"s":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"l":{"docs":{},"e":{"docs":{},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0012307692307692308}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"s":{"docs":{},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"c":{"docs":{},"o":{"docs":{},"n":{"docs":{},"o":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"c":{"docs":{},"s":{"docs":{},")":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}},"p":{"docs":{},"h":{"docs":{},"e":{"docs":{},"m":{"docs":{},"e":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"a":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"o":{"docs":{},"n":{"docs":{},"y":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"q":{"docs":{},"u":{"docs":{},"a":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"i":{"docs":{},"v":{"docs":{},"a":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"r":{"docs":{},"a":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"c":{"docs":{},".":{"docs":{},")":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"f":{"docs":{},"a":{"docs":{},"b":{"docs":{},"r":{"docs":{},"i":{"docs":{},"c":{"docs":{"./":{"ref":"./","tf":0.06043956043956044},"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.015267175572519083},"API.html":{"ref":"API.html","tf":0.006},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.0196078431372549},"SERVICES.html":{"ref":"SERVICES.html","tf":0.025},"whitepaper.html":{"ref":"whitepaper.html","tf":0.009881422924901186},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.009893992932862191}},"(":{"docs":{},")":{"docs":{},";":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}},"c":{"docs":{},"o":{"docs":{},"n":{"docs":{},"f":{"docs":{},"i":{"docs":{},"g":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}},",":{"docs":{"./":{"ref":"./","tf":0.01098901098901099},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"m":{"docs":{},"i":{"docs":{},"n":{"docs":{},".":{"docs":{},"j":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}}},"o":{"docs":{},"n":{"docs":{},"(":{"docs":{},"'":{"docs":{},"m":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},"a":{"docs":{},"g":{"docs":{},"e":{"docs":{},"'":{"docs":{},",":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}}}}}}}}}}},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{},"(":{"docs":{},")":{"docs":{},";":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}}}}}},"c":{"docs":{},"o":{"docs":{},"m":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},"e":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"p":{"docs":{},"u":{"docs":{},"s":{"docs":{},"h":{"docs":{},"(":{"docs":{},"v":{"docs":{},"a":{"docs":{},"l":{"docs":{},"u":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"g":{"docs":{},"i":{"docs":{},"s":{"docs":{},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{},"(":{"docs":{},"s":{"docs":{},"e":{"docs":{},"r":{"docs":{},"v":{"docs":{},"i":{"docs":{},"c":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}},"t":{"docs":{},"r":{"docs":{},"u":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},"s":{"docs":{},"o":{"docs":{},"u":{"docs":{},"r":{"docs":{},"c":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}},":":{"docs":{},"'":{"docs":{},",":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}},"'":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}}},"m":{"docs":{},"i":{"docs":{},"l":{"docs":{},"i":{"docs":{},"a":{"docs":{},"r":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0003076923076923077},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}},"i":{"docs":{},"t":{"docs":{},"y":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}},"o":{"docs":{},"u":{"docs":{},"s":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"i":{"docs":{},"l":{"docs":{},"e":{"docs":{},"d":{"docs":{},":":{"docs":{},"'":{"docs":{},",":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}},"u":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"e":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"s":{"docs":{},"]":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}}}},"l":{"docs":{},"s":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}},"e":{"docs":{},",":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.015267175572519083}}}}}},"c":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}}},"i":{"docs":{},"l":{"docs":{},"i":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"s":{"docs":{},"h":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"v":{"docs":{},"o":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"e":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"l":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}},"d":{"docs":{},"b":{"docs":{},"a":{"docs":{},"c":{"docs":{},"k":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"a":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}}},"i":{"docs":{},"l":{"docs":{},"e":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}},"n":{"docs":{},"a":{"docs":{},"n":{"docs":{},"c":{"docs":{},"i":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"l":{"docs":{},"y":{"docs":{},",":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}},"g":{"docs":{},"e":{"docs":{},"r":{"docs":{},"p":{"docs":{},"r":{"docs":{},"i":{"docs":{},"n":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"i":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"e":{"docs":{},"l":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"r":{"docs":{},"s":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"\"":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"a":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"g":{"docs":{},"u":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"x":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"b":{"docs":{},"o":{"docs":{},"n":{"docs":{},"a":{"docs":{},"c":{"docs":{},"c":{"docs":{},"i":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}}}}}},"o":{"docs":{},"l":{"docs":{},"l":{"docs":{},"o":{"docs":{},"w":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542},"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"s":{"docs":{},":":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"r":{"docs":{},"k":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}}},"w":{"docs":{},"a":{"docs":{},"r":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}},"\"":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.002635046113306983},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0035335689045936395}},"a":{"docs":{},"t":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}}},"l":{"docs":{},"l":{"docs":{},"y":{"docs":{},"v":{"docs":{},"e":{"docs":{},"r":{"docs":{},"i":{"docs":{},"f":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}}},"u":{"docs":{},"l":{"docs":{},"a":{"docs":{},"e":{"docs":{},".":{"docs":{},"”":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"u":{"docs":{},"n":{"docs":{},"d":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"a":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"c":{"docs":{},"i":{"docs":{},"i":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"r":{"docs":{},"a":{"docs":{},"m":{"docs":{},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"w":{"docs":{},"o":{"docs":{},"r":{"docs":{},"k":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0003076923076923077}},",":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}}}}},"g":{"docs":{},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"n":{"docs":{},"k":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"u":{"docs":{},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}},"e":{"docs":{},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"n":{"docs":{},"o":{"docs":{},"d":{"docs":{},"e":{"docs":{},")":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}}},"d":{"docs":{},"o":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"s":{"docs":{},"h":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"i":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{},"l":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"s":{"docs":{},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}},"o":{"docs":{},"m":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"u":{"docs":{},"l":{"docs":{},"l":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0009230769230769231}},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}},"f":{"docs":{},"i":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}}}}},"n":{"docs":{},"c":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542},"API.html":{"ref":"API.html","tf":0.0006153846153846154},"SERVICES.html":{"ref":"SERVICES.html","tf":0.025},"whitepaper.html":{"ref":"whitepaper.html","tf":0.005270092226613966},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"s":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153},"whitepaper.html":{"ref":"whitepaper.html","tf":0.001976284584980237},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"a":{"docs":{},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"a":{"docs":{},"l":{"docs":{},"l":{"docs":{},"y":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}}}},"s":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"r":{"docs":{},"t":{"docs":{},"h":{"docs":{},"e":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.001976284584980237}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"m":{"docs":{},"o":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}}}},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}},"z":{"docs":{},"z":{"docs":{},"c":{"docs":{},"h":{"docs":{},"a":{"docs":{},"i":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}}}}}},"l":{"docs":{},"u":{"docs":{},"s":{"docs":{},"h":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"o":{"docs":{},"w":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}},"h":{"docs":{},"e":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"g":{"docs":{},"a":{"docs":{},"m":{"docs":{},"e":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}},"i":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"r":{"docs":{},"n":{"docs":{},"e":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"b":{"docs":{},"l":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"v":{"docs":{},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}},"e":{"docs":{},"n":{"docs":{},"e":{"docs":{},"r":{"docs":{"./":{"ref":"./","tf":0.005494505494505495},"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542},"API.html":{"ref":"API.html","tf":0.002307692307692308},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}},"a":{"docs":{},"l":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"'":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"s":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}},"i":{"docs":{},"t":{"docs":{},"h":{"docs":{},"u":{"docs":{},"b":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}},"l":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"v":{"docs":{},"e":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"o":{"docs":{},"a":{"docs":{},"l":{"docs":{},"s":{"docs":{},".":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}},"\"":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"n":{"docs":{},"e":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"r":{"docs":{},"e":{"docs":{},"a":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}},"!":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"e":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"s":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"g":{"docs":{},"o":{"docs":{},"r":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"a":{"docs":{},"p":{"docs":{},"h":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"s":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"b":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}}},"y":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"o":{"docs":{},"u":{"docs":{},"p":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"w":{"docs":{},"t":{"docs":{},"h":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"l":{"docs":{},"o":{"docs":{},"b":{"docs":{},"a":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.00676923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}}}}}}},"u":{"docs":{},"i":{"docs":{},"d":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":3.333333333333333}}}},"a":{"docs":{},"r":{"docs":{},"a":{"docs":{},"n":{"docs":{},"t":{"docs":{},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},"s":{"docs":{},")":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}},"y":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"h":{"docs":{},"e":{"docs":{},"a":{"docs":{},"d":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}},"l":{"docs":{},"t":{"docs":{},"h":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"l":{"docs":{},"p":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"r":{"docs":{},"e":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}},"i":{"docs":{},"g":{"docs":{},"h":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"d":{"docs":{},"e":{"docs":{},"l":{"docs":{},"b":{"docs":{},"e":{"docs":{},"r":{"docs":{},"g":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}}},"x":{"docs":{"API.html":{"ref":"API.html","tf":0.0010769230769230769}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"a":{"docs":{},"d":{"docs":{},"e":{"docs":{},"c":{"docs":{},"i":{"docs":{},"m":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"t":{"docs":{},"m":{"docs":{},"l":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"t":{"docs":{},"p":{"docs":{"./":{"ref":"./","tf":0.005494505494505495},"API.html":{"ref":"API.html","tf":0.0018461538461538461}},".":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}},"s":{"docs":{},":":{"docs":{},"/":{"docs":{},"/":{"docs":{},"n":{"docs":{},"v":{"docs":{},"m":{"docs":{},".":{"docs":{},"s":{"docs":{},"h":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}}},"w":{"docs":{},"w":{"docs":{},"w":{"docs":{},".":{"docs":{},"w":{"3":{"docs":{},".":{"docs":{},"o":{"docs":{},"r":{"docs":{},"g":{"docs":{},"/":{"docs":{},"t":{"docs":{},"r":{"docs":{},"/":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{},"i":{"docs":{},"v":{"docs":{},"i":{"docs":{},"t":{"docs":{},"y":{"docs":{},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{},"e":{"docs":{},"a":{"docs":{},"m":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}}}}}}}}}}}}}},"docs":{}}}}}}}}}},":":{"docs":{},"/":{"docs":{},"/":{"docs":{},"b":{"docs":{},"i":{"docs":{},"t":{"docs":{},"c":{"docs":{},"o":{"docs":{},"i":{"docs":{},"n":{"docs":{},".":{"docs":{},"o":{"docs":{},"r":{"docs":{},"g":{"docs":{},"/":{"docs":{},"b":{"docs":{},"i":{"docs":{},"t":{"docs":{},"c":{"docs":{},"o":{"docs":{},"i":{"docs":{},"n":{"docs":{},".":{"docs":{},"p":{"docs":{},"d":{"docs":{},"f":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}}}}}}}}}}}}}}}},"w":{"docs":{},"w":{"docs":{},"w":{"docs":{},".":{"docs":{},"c":{"docs":{},"y":{"docs":{},"p":{"docs":{},"h":{"docs":{},"e":{"docs":{},"r":{"docs":{},"p":{"docs":{},"u":{"docs":{},"n":{"docs":{},"k":{"docs":{},"s":{"docs":{},".":{"docs":{},"t":{"docs":{},"o":{"docs":{},"/":{"docs":{},"e":{"docs":{},"r":{"docs":{},"i":{"docs":{},"g":{"docs":{},"h":{"docs":{},"t":{"docs":{},"s":{"docs":{},"/":{"docs":{},"e":{"docs":{},"l":{"docs":{},"i":{"docs":{},"b":{"docs":{},"/":{"docs":{},"c":{"docs":{},"a":{"docs":{},"p":{"docs":{},"a":{"docs":{},"b":{"docs":{},"i":{"docs":{},"l":{"docs":{},"i":{"docs":{},"t":{"docs":{},"y":{"docs":{},"/":{"docs":{},"o":{"docs":{},"d":{"docs":{},"e":{"docs":{},"/":{"docs":{},"o":{"docs":{},"d":{"docs":{},"e":{"docs":{},".":{"docs":{},"p":{"docs":{},"d":{"docs":{},"f":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"l":{"docs":{},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"+":{"1":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"2":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"docs":{}},"s":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"y":{"docs":{},"p":{"docs":{},"e":{"docs":{},"r":{"docs":{},"l":{"docs":{},"e":{"docs":{},"d":{"docs":{},"g":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}},"i":{"docs":{},"n":{"docs":{},"k":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"s":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"t":{"docs":{},"e":{"docs":{},"x":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}},"d":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}},"a":{"docs":{},"n":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.0012307692307692308}}}}},"s":{"docs":{},"h":{"docs":{},"a":{"docs":{},"k":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"s":{"docs":{},"h":{"2":{"5":{"6":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}},"(":{"docs":{},")":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"s":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}},".":{"docs":{},"d":{"docs":{},"i":{"docs":{},"g":{"docs":{},"e":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"v":{"docs":{},"e":{"docs":{},"r":{"docs":{},"s":{"docs":{},"e":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"docs":{}},"docs":{}},"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.002635046113306983},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"m":{"docs":{},"a":{"docs":{},"p":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"t":{"docs":{},"a":{"docs":{},"b":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}},"e":{"docs":{},"s":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"p":{"docs":{},"p":{"docs":{},"e":{"docs":{},"n":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"v":{"docs":{},"e":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"i":{"docs":{},"g":{"docs":{},"h":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},"s":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"l":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}},"v":{"docs":{},"o":{"docs":{},"l":{"docs":{},"u":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"d":{"docs":{},"d":{"docs":{},"e":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"e":{"docs":{},"r":{"docs":{},"a":{"docs":{},"r":{"docs":{},"c":{"docs":{},"h":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"y":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}},"s":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"y":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"k":{"docs":{},"d":{"docs":{},"f":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}},"(":{"docs":{},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"s":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}},".":{"docs":{},"d":{"docs":{},"e":{"docs":{},"r":{"docs":{},"i":{"docs":{},"v":{"docs":{},"e":{"docs":{},"(":{"docs":{},"[":{"docs":{},"i":{"docs":{},"n":{"docs":{},"f":{"docs":{},"o":{"docs":{},"]":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}},"m":{"docs":{},"a":{"docs":{},"c":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}},"o":{"docs":{},"l":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"s":{"docs":{},"t":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"m":{"docs":{},"o":{"docs":{},"m":{"docs":{},"o":{"docs":{},"r":{"docs":{},"p":{"docs":{},"h":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"n":{"docs":{},"e":{"docs":{},"s":{"docs":{},"t":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}}},"u":{"docs":{},"s":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"w":{"docs":{},"e":{"docs":{},"v":{"docs":{},"e":{"docs":{},"r":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}}}}}}}}},"u":{"docs":{},"m":{"docs":{},"a":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}},"n":{"docs":{},"d":{"docs":{},"r":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"i":{"docs":{},"b":{"docs":{},"m":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692},"whitepaper.html":{"ref":"whitepaper.html","tf":0.001976284584980237}},"l":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}},"e":{"docs":{},"r":{"docs":{},"p":{"docs":{},"g":{"docs":{},",":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}}}},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"i":{"docs":{},"f":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"e":{"docs":{},"r":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0013846153846153845}}}}}}},"t":{"docs":{},"y":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"a":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"m":{"docs":{},"p":{"docs":{},"l":{"docs":{},"e":{"docs":{},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0015384615384615385},"SERVICES.html":{"ref":"SERVICES.html","tf":0.025},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00461133069828722},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0049469964664310955}},"a":{"docs":{},"t":{"docs":{},"o":{"docs":{},"n":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"s":{"docs":{},")":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}}}}}},"i":{"docs":{},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"i":{"docs":{},"t":{"docs":{},"l":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}},"o":{"docs":{},"r":{"docs":{},"t":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"r":{"docs":{},"o":{"docs":{},"v":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"e":{"docs":{},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}},"u":{"docs":{},"l":{"docs":{},"s":{"docs":{},"e":{"docs":{},".":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"m":{"docs":{},"u":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231}}}}}},"n":{"docs":{},"c":{"docs":{},"l":{"docs":{},"u":{"docs":{},"d":{"docs":{"./":{"ref":"./","tf":0.01098901098901099},"API.html":{"ref":"API.html","tf":0.0012307692307692308},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0032938076416337285},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.005653710247349823}},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},":":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}},"e":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"s":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"o":{"docs":{},"m":{"docs":{"API.html":{"ref":"API.html","tf":0.0012307692307692308}}},"n":{"docs":{},"v":{"docs":{},"e":{"docs":{},"n":{"docs":{},"i":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},"l":{"docs":{},"y":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"a":{"docs":{},"s":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}},"i":{"docs":{},"v":{"docs":{},"e":{"docs":{},"s":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"l":{"docs":{"./":{"ref":"./","tf":0.005494505494505495},"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.022900763358778626}}},"n":{"docs":{},"c":{"docs":{"./":{"ref":"./","tf":0.005494505494505495},"API.html":{"ref":"API.html","tf":0.040615384615384616}},"e":{"docs":{},"'":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}}}}},"t":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"e":{"docs":{},"a":{"docs":{},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}},".":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"r":{"docs":{},"u":{"docs":{},"c":{"docs":{},"t":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542},"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"e":{"docs":{},"r":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}},"t":{"docs":{},"e":{"docs":{},"g":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}},"r":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"a":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"e":{"docs":{},"r":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"l":{"docs":{},"l":{"docs":{},"i":{"docs":{},"g":{"docs":{"./":{"ref":"./","tf":0.005494505494505495}}}}}},"r":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0024615384615384616},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.0196078431372549},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}},"e":{"docs":{},"s":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"f":{"docs":{},"a":{"docs":{},"c":{"docs":{"./":{"ref":"./","tf":0.008241758241758242},"API.html":{"ref":"API.html","tf":0.0036923076923076922},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},"'":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"(":{"docs":{},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"s":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}},"c":{"docs":{},"y":{"docs":{},"c":{"docs":{},"l":{"docs":{},"e":{"docs":{},"(":{"docs":{},"v":{"docs":{},"a":{"docs":{},"l":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"l":{"docs":{},"o":{"docs":{},"g":{"docs":{},"(":{"docs":{},".":{"docs":{},".":{"docs":{},".":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},"s":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}},"n":{"docs":{},"o":{"docs":{},"w":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"o":{"docs":{},"p":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}},"a":{"docs":{},"l":{"docs":{},"l":{"docs":{},"y":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}},"p":{"docs":{},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"c":{"docs":{},"o":{"docs":{},"n":{"docs":{},"n":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"o":{"docs":{},"p":{"docs":{},"e":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"a":{"docs":{},"b":{"docs":{},"i":{"docs":{},"l":{"docs":{},"i":{"docs":{},"t":{"docs":{},"y":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}}}}}}},"n":{"docs":{},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"s":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"r":{"docs":{},"o":{"docs":{},"d":{"docs":{},"u":{"docs":{},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.002635046113306983},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}},"t":{"docs":{"./":{"ref":"./","tf":5},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}}},"i":{"docs":{},"n":{"docs":{},"s":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"a":{"docs":{},"n":{"docs":{},"g":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"i":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.002307692307692308},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"a":{"docs":{},"l":{"docs":{},"i":{"docs":{},"z":{"docs":{},"e":{"docs":{},"d":{"docs":{},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}}},"t":{"docs":{},"i":{"docs":{},"v":{"docs":{},"e":{"docs":{},"s":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}}},"d":{"docs":{},"i":{"docs":{},"c":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"v":{"docs":{},"i":{"docs":{},"d":{"docs":{},"u":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}}}}}}},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"p":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"l":{"docs":{},"y":{"docs":{},"s":{"docs":{},"e":{"docs":{},"c":{"docs":{},"u":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}}}}}}},"x":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"u":{"docs":{},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"f":{"docs":{},"o":{"docs":{},"r":{"docs":{},"m":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00461133069828722},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0063604240282685515}},"a":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}},",":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}}}}}}},"r":{"docs":{},"a":{"docs":{},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{},"u":{"docs":{},"c":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}}},"l":{"docs":{},"u":{"docs":{},"e":{"docs":{},"n":{"docs":{},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"n":{"docs":{},"e":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00676923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}}}}}},".":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}}},"e":{"docs":{},"f":{"docs":{},"f":{"docs":{},"i":{"docs":{},"c":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"j":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"k":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}},")":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"\"":{"docs":{},"]":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"v":{"docs":{},"a":{"docs":{},"l":{"docs":{},"i":{"docs":{},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"r":{"docs":{},"s":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}},"s":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"o":{"docs":{},"l":{"docs":{},"v":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"t":{"docs":{},"'":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}},"e":{"docs":{},"m":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}},"s":{"docs":{},"e":{"docs":{},"l":{"docs":{},"f":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"/":{"docs":{},"o":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}},"e":{"docs":{},"e":{"docs":{},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"r":{"docs":{},"r":{"docs":{},"a":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"s":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"o":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}},"m":{"docs":{},"o":{"docs":{},"r":{"docs":{},"p":{"docs":{},"h":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}}}},"s":{"docs":{},"u":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}},"a":{"docs":{},"n":{"docs":{},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"v":{"docs":{},"a":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"j":{"docs":{},"u":{"docs":{},"k":{"docs":{},"e":{"docs":{},"b":{"docs":{},"o":{"docs":{},"x":{"docs":{"./":{"ref":"./","tf":0.005494505494505495}}}}}}}},"a":{"docs":{},"v":{"docs":{},"a":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}}}}}}}}}}},"o":{"docs":{},"b":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"s":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}},"s":{"docs":{},"o":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.0013846153846153845}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.001976284584980237},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"l":{"1":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"2":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}},"3":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}},"docs":{},"a":{"docs":{},"u":{"docs":{},"n":{"docs":{},"c":{"docs":{},"h":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"b":{"docs":{},"e":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}}}},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"s":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"n":{"docs":{},"g":{"docs":{},"u":{"docs":{},"a":{"docs":{},"g":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"r":{"docs":{},"g":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"e":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"y":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0035335689045936395}}}}}},"e":{"docs":{},"a":{"docs":{},"r":{"docs":{},"n":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}},"v":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"g":{"docs":{},"a":{"docs":{},"c":{"docs":{},"i":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"d":{"docs":{},"g":{"docs":{},"e":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.0013846153846153845},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"'":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}},"a":{"docs":{},"p":{"docs":{},"p":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{},"(":{"docs":{},"i":{"docs":{},"t":{"docs":{},"e":{"docs":{},"m":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}},"c":{"docs":{},"o":{"docs":{},"m":{"docs":{},"m":{"docs":{},"i":{"docs":{},"t":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"d":{"docs":{},"e":{"docs":{},"s":{"docs":{},"e":{"docs":{},"r":{"docs":{},"i":{"docs":{},"a":{"docs":{},"l":{"docs":{},"i":{"docs":{},"z":{"docs":{},"e":{"docs":{},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}},"f":{"docs":{},"o":{"docs":{},"r":{"docs":{},"k":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"i":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"n":{"docs":{},"h":{"docs":{},"e":{"docs":{},"r":{"docs":{},"i":{"docs":{},"t":{"docs":{},"s":{"docs":{},"(":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"b":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}},"n":{"docs":{},"o":{"docs":{},"w":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"r":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{},"e":{"docs":{},"r":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"s":{"docs":{},"e":{"docs":{},"r":{"docs":{},"i":{"docs":{},"a":{"docs":{},"l":{"docs":{},"i":{"docs":{},"z":{"docs":{},"e":{"docs":{},"(":{"docs":{},"[":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},"]":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}},"t":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"t":{"docs":{},"o":{"docs":{},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"r":{"docs":{},"u":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},"s":{"docs":{},"o":{"docs":{},"u":{"docs":{},"r":{"docs":{},"c":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}},"o":{"docs":{},"v":{"docs":{},"e":{"docs":{},"r":{"docs":{},"r":{"docs":{},"i":{"docs":{},"d":{"docs":{},"e":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.0010769230769230769}}}}}}}}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}}},"n":{"docs":{},"g":{"docs":{},"t":{"docs":{},"h":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}}}}},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"t":{"docs":{},"'":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"v":{"docs":{},"e":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}},"r":{"docs":{},"a":{"docs":{},"g":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}}}},"i":{"docs":{},"b":{"docs":{},"r":{"docs":{},"a":{"docs":{},"r":{"docs":{},"i":{"docs":{"./":{"ref":"./","tf":0.008241758241758242}}}}}}},"n":{"docs":{},"e":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"a":{"docs":{},"r":{"docs":{},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"k":{"docs":{"./":{"ref":"./","tf":0.005494505494505495},"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"a":{"docs":{},"b":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"d":{"docs":{},"i":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"s":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0024615384615384616},"SERVICES.html":{"ref":"SERVICES.html","tf":0.025},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},",":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}},"e":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}}}}}},"f":{"docs":{},"e":{"docs":{},"c":{"docs":{},"y":{"docs":{},"c":{"docs":{},"l":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}},"t":{"docs":{},"i":{"docs":{},"m":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}},"v":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}},"g":{"docs":{},"h":{"docs":{},"t":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"m":{"docs":{},"i":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"i":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"k":{"docs":{},"e":{"docs":{},"l":{"docs":{},"i":{"docs":{},"h":{"docs":{},"o":{"docs":{},"o":{"docs":{},"d":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}}},"o":{"docs":{},"c":{"docs":{},"a":{"docs":{},"l":{"docs":{"./":{"ref":"./","tf":0.01098901098901099},"API.html":{"ref":"API.html","tf":0.0009230769230769231}},"h":{"docs":{},"o":{"docs":{},"s":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}}}},"k":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"o":{"docs":{},"k":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"a":{"docs":{},"h":{"docs":{},"e":{"docs":{},"a":{"docs":{},"d":{"docs":{},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}}}},"p":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"a":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"g":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"i":{"docs":{},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"n":{"docs":{},"g":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"e":{"docs":{},"r":{"docs":{},")":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"t":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}}},"w":{"docs":{},"e":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"m":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},"a":{"docs":{},"g":{"docs":{"./":{"ref":"./","tf":0.016483516483516484},"API.html":{"ref":"API.html","tf":0.007230769230769231},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.0392156862745098},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0029644268774703555},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}},";":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}},"(":{"docs":{},"m":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},"a":{"docs":{},"g":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0016923076923076924}},"a":{"docs":{},"s":{"docs":{},"r":{"docs":{},"a":{"docs":{},"w":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"s":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}},"}":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"t":{"docs":{},"h":{"docs":{},"o":{"docs":{},"d":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.029846153846153845},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}},"e":{"docs":{},"m":{"docs":{},"i":{"docs":{},"t":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},":":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}}}}}}},"e":{"docs":{},"t":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}},"c":{"docs":{},"h":{"docs":{},"a":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper.html":{"ref":"whitepaper.html","tf":0.001976284584980237},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}},"i":{"docs":{},"c":{"docs":{},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}},"s":{"docs":{},"m":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}},"s":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}},"m":{"docs":{},"b":{"docs":{},"e":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}},"o":{"docs":{},"r":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.0010769230769230769}}},"y":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"p":{"docs":{},"o":{"docs":{},"o":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231}},"(":{"docs":{},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"s":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}},"r":{"docs":{},"k":{"docs":{},"l":{"docs":{},"e":{"docs":{},"t":{"docs":{},"r":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"a":{"docs":{},"n":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915}}}}}},"s":{"docs":{},"u":{"docs":{},"r":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}},"d":{"docs":{},"i":{"docs":{},"u":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"o":{"docs":{},"d":{"docs":{},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.002635046113306983},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}},",":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"s":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"^":{"docs":{},"[":{"docs":{},"c":{"docs":{},"i":{"docs":{},"t":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"i":{"docs":{},"f":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"y":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"u":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"e":{"docs":{},":":{"docs":{},"m":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},"a":{"docs":{},"g":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0003076923076923077},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.001976284584980237},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},".":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}},"r":{"docs":{},"i":{"docs":{},"s":{"docs":{},"o":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}}}}},"n":{"docs":{},"i":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"e":{"docs":{},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}},"y":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"o":{"docs":{},"p":{"docs":{},"o":{"docs":{},"l":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"e":{"docs":{},"s":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}},"v":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},"u":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}},"a":{"docs":{},"i":{"docs":{},"n":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"(":{"docs":{},")":{"docs":{},".":{"docs":{},"c":{"docs":{},"a":{"docs":{},"t":{"docs":{},"c":{"docs":{},"h":{"docs":{},"(":{"docs":{},"(":{"docs":{},"e":{"docs":{},"x":{"docs":{},"c":{"docs":{},"e":{"docs":{},"p":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},")":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}}}}}}}}}}}}}}}}},"n":{"docs":{},"e":{"docs":{},"t":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"t":{"docs":{},"a":{"docs":{},"i":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915}}}}}}}},"r":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"d":{"docs":{},"a":{"docs":{},"l":{"docs":{},"e":{"docs":{},"/":{"docs":{},"f":{"docs":{},"a":{"docs":{},"b":{"docs":{},"r":{"docs":{},"i":{"docs":{},"c":{"docs":{},"#":{"docs":{},"f":{"docs":{},"a":{"docs":{},"b":{"docs":{},"r":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}}}}}}}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}},"k":{"docs":{},"e":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00230566534914361},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0035335689045936395}},"\"":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"s":{"docs":{},"\"":{"docs":{},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"u":{"docs":{},"p":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"s":{"docs":{},"h":{"docs":{},"a":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"t":{"docs":{},"c":{"docs":{},"h":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542},"API.html":{"ref":"API.html","tf":0.0003076923076923077}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"e":{"docs":{},"r":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"a":{"docs":{},"l":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"r":{"docs":{},"i":{"docs":{},"x":{"docs":{"API.html":{"ref":"API.html","tf":0.0010769230769230769}},"(":{"docs":{},"[":{"docs":{},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"s":{"docs":{},"]":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}},"_":{"docs":{},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"g":{"docs":{},"i":{"docs":{},"s":{"docs":{},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{},"(":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{},"(":{"docs":{},"m":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},"a":{"docs":{},"g":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}},"c":{"docs":{},"o":{"docs":{},"n":{"docs":{},"n":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{},"(":{"docs":{},"n":{"docs":{},"o":{"docs":{},"t":{"docs":{},"i":{"docs":{},"f":{"docs":{},"y":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}},"h":{"docs":{},"a":{"docs":{},"n":{"docs":{},"d":{"docs":{},"l":{"docs":{},"e":{"docs":{},"r":{"docs":{},"(":{"docs":{},"m":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},"a":{"docs":{},"g":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}},"r":{"docs":{},"o":{"docs":{},"u":{"docs":{},"t":{"docs":{},"e":{"docs":{},"(":{"docs":{},"m":{"docs":{},"s":{"docs":{},"g":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"s":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{},"(":{"docs":{},"c":{"docs":{},"h":{"docs":{},"a":{"docs":{},"n":{"docs":{},"n":{"docs":{},"e":{"docs":{},"l":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"o":{"docs":{},"p":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"t":{"docs":{},"i":{"docs":{},"c":{"docs":{},"k":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"o":{"docs":{},"v":{"docs":{},"e":{"docs":{},"r":{"docs":{},"r":{"docs":{},"i":{"docs":{},"d":{"docs":{},"e":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231}}}}}}}}}}}}},"h":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"e":{"docs":{},"m":{"docs":{},"a":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"c":{"docs":{},"h":{"docs":{},"i":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.0012307692307692308},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"e":{"docs":{},"(":{"docs":{},"c":{"docs":{},"o":{"docs":{},"n":{"docs":{},"f":{"docs":{},"i":{"docs":{},"g":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"c":{"docs":{},"o":{"docs":{},"m":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},"e":{"docs":{},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}},"s":{"docs":{},"i":{"docs":{},"p":{"docs":{},"(":{"docs":{},"[":{"docs":{},"n":{"docs":{},"]":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"s":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"k":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"i":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"n":{"docs":{},"a":{"docs":{},"g":{"docs":{"API.html":{"ref":"API.html","tf":0.0013846153846153845}},"e":{"docs":{},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}},"f":{"docs":{},"e":{"docs":{},"s":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"p":{"docs":{},"u":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"p":{"docs":{"API.html":{"ref":"API.html","tf":0.0035384615384615385}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"d":{"docs":{},"e":{"docs":{"SERVICES.html":{"ref":"SERVICES.html","tf":0.025},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"j":{"docs":{},"o":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"l":{"docs":{},"i":{"docs":{},"c":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"x":{"docs":{},"i":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"w":{"docs":{},"e":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"i":{"docs":{},"l":{"docs":{},"l":{"docs":{},"i":{"docs":{},"s":{"docs":{},"e":{"docs":{},"c":{"docs":{},"o":{"docs":{},"n":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}}}}}}}}}}}}},"n":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"i":{"docs":{},"m":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"u":{"docs":{},"m":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}},"u":{"docs":{},"t":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"x":{"docs":{"API.html":{"ref":"API.html","tf":0.009076923076923076}}},"c":{"docs":{},"r":{"docs":{},"o":{"docs":{},"f":{"docs":{},"o":{"docs":{},"r":{"docs":{},"m":{"docs":{},"a":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"s":{"docs":{},"o":{"docs":{},"f":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"d":{"docs":{},"d":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"n":{"docs":{},"e":{"docs":{},"m":{"docs":{},"o":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}}}}}}},"s":{"docs":{},"g":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231}},")":{"docs":{},";":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}}}}}},"t":{"docs":{},"x":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"u":{"docs":{},"t":{"docs":{},"u":{"docs":{},"a":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"a":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"c":{"docs":{},"h":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"l":{"docs":{},"t":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00230566534914361},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0035335689045936395}},"p":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"i":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"p":{"docs":{},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"y":{"docs":{},"s":{"docs":{},"p":{"docs":{},"a":{"docs":{},"c":{"docs":{},"e":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"a":{"docs":{},"m":{"docs":{},"e":{"docs":{"./":{"ref":"./","tf":0.005494505494505495},"API.html":{"ref":"API.html","tf":0.0063076923076923076},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"s":{"docs":{},"p":{"docs":{},"a":{"docs":{},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"t":{"docs":{},"i":{"docs":{},"v":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}},"h":{"docs":{},"a":{"docs":{},"n":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"k":{"docs":{},"a":{"docs":{},"m":{"docs":{},"o":{"docs":{},"t":{"docs":{},"o":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"v":{"docs":{},"i":{"docs":{},"g":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"e":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}},"w":{"docs":{},"o":{"docs":{},"r":{"docs":{},"k":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0026153846153846153},"whitepaper.html":{"ref":"whitepaper.html","tf":0.010540184453227932},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.01342756183745583}},".":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.003076923076923077},"SERVICES.html":{"ref":"SERVICES.html","tf":0.025},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}}},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.001976284584980237},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0035335689045936395}}},"s":{"docs":{},".":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"w":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.015267175572519083},"API.html":{"ref":"API.html","tf":0.015076923076923076},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.0196078431372549},"SERVICES.html":{"ref":"SERVICES.html","tf":0.025},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00461133069828722},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.007067137809187279}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"l":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"s":{"docs":{},"t":{"docs":{},"e":{"docs":{},"d":{"docs":{},"a":{"docs":{},"d":{"docs":{},"d":{"docs":{},"r":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}}}}},"d":{"docs":{},"e":{"docs":{},"p":{"docs":{},"t":{"docs":{},"h":{"docs":{},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}}}}}}},"c":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},"a":{"docs":{},"r":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"l":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}}},"e":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},"d":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"]":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0035335689045936395}}}}}}}},"x":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"v":{"docs":{},"e":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"g":{"docs":{},"a":{"docs":{},"t":{"docs":{},"i":{"docs":{},"v":{"docs":{},"e":{"docs":{},")":{"docs":{},".":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}}},"o":{"docs":{},"d":{"docs":{},"e":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.022900763358778626},"API.html":{"ref":"API.html","tf":0.0006153846153846154},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},".":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"w":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"t":{"docs":{},"e":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}},"i":{"docs":{},"f":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}},"o":{"docs":{},"r":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"i":{"docs":{},"s":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"y":{"docs":{},"?":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}},"r":{"docs":{},"m":{"docs":{},"a":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"l":{"docs":{},"y":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"v":{"docs":{},"e":{"docs":{},"l":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"p":{"docs":{},"m":{"docs":{"./":{"ref":"./","tf":0.027472527472527472},"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.015267175572519083}}}},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}},"u":{"docs":{},"l":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}},",":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}},"m":{"docs":{},"b":{"docs":{},"e":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.0063076923076923076},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"s":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},".":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"e":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"SERVICES.html":{"ref":"SERVICES.html","tf":0.025}}}}}},"v":{"docs":{},"m":{"docs":{},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}},"+":{"1":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915}}},"2":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915}}},"docs":{}},"_":{"docs":{},"t":{"docs":{},"h":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"i":{"docs":{},"c":{"docs":{},"k":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"o":{"docs":{},"f":{"docs":{},"f":{"docs":{},"e":{"docs":{},"r":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"SERVICES.html":{"ref":"SERVICES.html","tf":0.025},"whitepaper.html":{"ref":"whitepaper.html","tf":0.002635046113306983},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}},"i":{"docs":{},"c":{"docs":{},"i":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}},":":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"n":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0013846153846153845},"whitepaper.html":{"ref":"whitepaper.html","tf":0.004940711462450593},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.005653710247349823}},"c":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}},"e":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"t":{"docs":{},"o":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}},"e":{"docs":{},"'":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"v":{"docs":{},"e":{"docs":{},"r":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0007692307692307692},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0036231884057971015},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"v":{"docs":{},"i":{"docs":{},"e":{"docs":{},"w":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"SERVICES.html":{"ref":"SERVICES.html","tf":3.333333333333333},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}},"h":{"docs":{},"e":{"docs":{},"a":{"docs":{},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},".":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}},"u":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542},"API.html":{"ref":"API.html","tf":0.0007692307692307692},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"b":{"docs":{},"o":{"docs":{},"u":{"docs":{},"n":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}}}}}}},"c":{"docs":{},"o":{"docs":{},"m":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}},"g":{"docs":{},"o":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"s":{"docs":{},"i":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}},"t":{"docs":{},"a":{"docs":{},"n":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"r":{"docs":{},"i":{"docs":{},"g":{"docs":{},"h":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"b":{"docs":{},"j":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.017076923076923076},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.002769230769230769}}},"s":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}},"p":{"docs":{},"r":{"docs":{},"o":{"docs":{},"p":{"docs":{},"e":{"docs":{},"r":{"docs":{},"t":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},")":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"s":{"docs":{},"e":{"docs":{},"r":{"docs":{},"v":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"v":{"docs":{},"i":{"docs":{},"a":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"p":{"docs":{},"e":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"d":{"docs":{},"i":{"docs":{},"f":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.002635046113306983},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0035335689045936395}},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},"s":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"s":{"docs":{},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}}}}}}},"p":{"docs":{},"o":{"docs":{},"r":{"docs":{},"t":{"docs":{},"u":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}},"s":{"docs":{},".":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}}}},"a":{"docs":{},"l":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"m":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"_":{"docs":{},"c":{"docs":{},"h":{"docs":{},"e":{"docs":{},"c":{"docs":{},"k":{"docs":{},"l":{"docs":{},"o":{"docs":{},"c":{"docs":{},"k":{"docs":{},"t":{"docs":{},"i":{"docs":{},"m":{"docs":{},"e":{"docs":{},"v":{"docs":{},"e":{"docs":{},"r":{"docs":{},"i":{"docs":{},"f":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}}}}}}}}}}}}}}},"s":{"docs":{},"i":{"docs":{},"g":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915}}}}}}}}}},"d":{"docs":{},"r":{"docs":{},"o":{"docs":{},"p":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}},"u":{"docs":{},"p":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"e":{"docs":{},"l":{"docs":{},"s":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}}},"n":{"docs":{},"d":{"docs":{},"i":{"docs":{},"f":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}},"q":{"docs":{},"u":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}},"a":{"docs":{},"l":{"docs":{},"v":{"docs":{},"e":{"docs":{},"r":{"docs":{},"i":{"docs":{},"f":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}}}}}}}}},"h":{"docs":{},"a":{"docs":{},"s":{"docs":{},"h":{"1":{"6":{"0":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"docs":{}},"docs":{}},"docs":{}}}}},"i":{"docs":{},"f":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}}},"s":{"docs":{},"h":{"docs":{},"a":{"2":{"5":{"6":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}},"docs":{}},"docs":{}},"docs":{}}}}},"c":{"docs":{},"o":{"docs":{},"d":{"docs":{},"e":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"r":{"docs":{},"a":{"docs":{},"c":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.0010769230769230769},"SERVICES.html":{"ref":"SERVICES.html","tf":0.05}},"e":{"docs":{},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"i":{"docs":{},"t":{"docs":{},"i":{"docs":{},"a":{"docs":{},"l":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}},".":{"docs":{},"_":{"docs":{},"p":{"docs":{},"o":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"g":{"docs":{},"i":{"docs":{},"s":{"docs":{},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{},"(":{"docs":{},"o":{"docs":{},"b":{"docs":{},"j":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}},"b":{"docs":{},"r":{"docs":{},"o":{"docs":{},"a":{"docs":{},"d":{"docs":{},"c":{"docs":{},"a":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},"m":{"docs":{},"s":{"docs":{},"g":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}},"d":{"docs":{},"e":{"docs":{},"l":{"docs":{},"(":{"docs":{},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"f":{"docs":{},"l":{"docs":{},"u":{"docs":{},"s":{"docs":{},"h":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"(":{"docs":{},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"(":{"docs":{},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"t":{"docs":{},"r":{"docs":{},"u":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},"s":{"docs":{},"o":{"docs":{},"u":{"docs":{},"r":{"docs":{},"c":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}},"o":{"docs":{},"v":{"docs":{},"e":{"docs":{},"r":{"docs":{},"r":{"docs":{},"i":{"docs":{},"d":{"docs":{},"e":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}}}}}}}}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"c":{"docs":{},"h":{"docs":{},"e":{"docs":{},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}},"d":{"docs":{},"e":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00230566534914361},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"a":{"docs":{},"m":{"docs":{},"o":{"docs":{},"u":{"docs":{},"n":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"s":{"docs":{},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"s":{"docs":{},"\"":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"i":{"docs":{},"g":{"docs":{},"i":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"a":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}},"g":{"docs":{},"a":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"l":{"docs":{},"a":{"docs":{},"n":{"docs":{},"d":{"docs":{},"i":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"t":{"docs":{},"h":{"docs":{},"e":{"docs":{},"r":{"docs":{},"s":{"docs":{},"!":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"w":{"docs":{},"i":{"docs":{},"s":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}}}}}}}},"s":{"docs":{},"t":{"docs":{},"e":{"docs":{},"n":{"docs":{},"s":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"w":{"docs":{},"n":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"z":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"p":{"2":{"docs":{},"p":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"s":{"docs":{},"h":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}},"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"a":{"docs":{},"c":{"docs":{},"k":{"docs":{},"a":{"docs":{},"g":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}},"s":{"docs":{},"s":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0003076923076923077},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"c":{"docs":{},"a":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"t":{"docs":{},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{},"n":{"docs":{},",":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},":":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}}}}}}},"c":{"docs":{},"h":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}},"e":{"docs":{},"s":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"s":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"h":{"docs":{"API.html":{"ref":"API.html","tf":0.008923076923076922},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}},"i":{"docs":{},"s":{"docs":{},"v":{"docs":{},"a":{"docs":{},"l":{"docs":{},"i":{"docs":{},"d":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"g":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"i":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"l":{"docs":{},"l":{"docs":{},"i":{"docs":{},"e":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}}}},"r":{"docs":{},"a":{"docs":{},"m":{"docs":{"API.html":{"ref":"API.html","tf":0.026615384615384614}},"e":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0012307692307692308},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}}},"s":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0012307692307692308}}}}},"l":{"docs":{},"l":{"docs":{},"e":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0012307692307692308}}}}}},"s":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"t":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.003952569169960474},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.004240282685512367}},"c":{"docs":{},"u":{"docs":{},"l":{"docs":{},"a":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.0013846153846153845},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"l":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"i":{"docs":{},"p":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.004940711462450593},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}},"a":{"docs":{},"n":{"docs":{},"t":{"docs":{},"s":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}},"a":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"e":{"docs":{},"s":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"y":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"y":{"docs":{"SERVICES.html":{"ref":"SERVICES.html","tf":0.025},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00230566534914361},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0049469964664310955}},"s":{"docs":{},",":{"docs":{"SERVICES.html":{"ref":"SERVICES.html","tf":0.025},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"\"":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"]":{"docs":{},"[":{"docs":{},"z":{"docs":{},"k":{"docs":{},"c":{"docs":{},"p":{"docs":{},"]":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}}}}}},"l":{"docs":{},"l":{"docs":{},"i":{"docs":{},"e":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"p":{"docs":{},"e":{"docs":{},"r":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"u":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}}}},"e":{"docs":{},"e":{"docs":{},"r":{"docs":{"./":{"ref":"./","tf":0.005494505494505495},"API.html":{"ref":"API.html","tf":0.003384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0036231884057971015},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0077738515901060075}},"#":{"docs":{},"e":{"docs":{},"v":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},":":{"docs":{},"r":{"docs":{},"e":{"docs":{},"a":{"docs":{},"d":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}},"(":{"docs":{},"[":{"docs":{},"c":{"docs":{},"o":{"docs":{},"n":{"docs":{},"f":{"docs":{},"i":{"docs":{},"g":{"docs":{},"]":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0010769230769230769}},"l":{"docs":{},"i":{"docs":{},"s":{"docs":{},"t":{"docs":{},"e":{"docs":{},"n":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"o":{"docs":{},"p":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"p":{"docs":{},"a":{"docs":{},"c":{"docs":{},"k":{"docs":{},"e":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"i":{"docs":{},"o":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"s":{"docs":{},"i":{"docs":{},"s":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}},"f":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"o":{"docs":{},"r":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}},"e":{"docs":{},"d":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"h":{"docs":{},"a":{"docs":{},"p":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"n":{"docs":{},"t":{"docs":{},"l":{"docs":{},"a":{"docs":{},"n":{"docs":{},"d":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}},"l":{"docs":{},"a":{"docs":{},"c":{"docs":{},"e":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"h":{"docs":{},"o":{"docs":{},"l":{"docs":{},"d":{"docs":{},"e":{"docs":{},"r":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"t":{"docs":{},"f":{"docs":{},"o":{"docs":{},"r":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"e":{"docs":{},"a":{"docs":{},"s":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}},"u":{"docs":{},"g":{"docs":{},"i":{"docs":{},"n":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0003076923076923077}},"s":{"docs":{},".":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"r":{"docs":{},"i":{"docs":{},"m":{"docs":{},"a":{"docs":{},"r":{"docs":{},"i":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"l":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"i":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"i":{"docs":{},"v":{"docs":{},"e":{"docs":{},"s":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}},"c":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"o":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"i":{"docs":{},"t":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}},"v":{"docs":{},"a":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"c":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915}}},"y":{"docs":{},"\"":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"n":{"docs":{},"c":{"docs":{},"i":{"docs":{},"p":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}}}},"o":{"docs":{},"c":{"docs":{},"e":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}},"s":{"docs":{},"s":{"docs":{"API.html":{"ref":"API.html","tf":0.0012307692307692308},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}}}}}}},"d":{"docs":{},"u":{"docs":{},"c":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"t":{"docs":{"./":{"ref":"./","tf":0.005494505494505495},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"j":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.013736263736263736},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"p":{"docs":{},"e":{"docs":{},"r":{"docs":{},"t":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.002307692307692308},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"e":{"docs":{},"s":{"docs":{},":":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"o":{"docs":{},"s":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"a":{"docs":{},"l":{"docs":{},"?":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"r":{"docs":{},"i":{"docs":{},"e":{"docs":{},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}},"t":{"docs":{},"o":{"docs":{},"t":{"docs":{},"y":{"docs":{},"p":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}},"c":{"docs":{},"o":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0029644268774703555},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"v":{"docs":{},"i":{"docs":{},"d":{"docs":{"./":{"ref":"./","tf":0.005494505494505495},"API.html":{"ref":"API.html","tf":0.0021538461538461538},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"SERVICES.html":{"ref":"SERVICES.html","tf":0.05},"whitepaper.html":{"ref":"whitepaper.html","tf":0.005599472990777339},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.007067137809187279}},"e":{"docs":{},"d":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},")":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"r":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"s":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"a":{"docs":{},"b":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}},"e":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"g":{"docs":{},"r":{"docs":{},"a":{"docs":{},"m":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542},"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.005928853754940711},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"s":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}},".":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"m":{"docs":{},"i":{"docs":{},"s":{"docs":{"API.html":{"ref":"API.html","tf":0.009230769230769232},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"o":{"docs":{},"f":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"b":{"docs":{},"a":{"docs":{},"b":{"docs":{},"i":{"docs":{},"l":{"docs":{},"i":{"docs":{},"s":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"l":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"l":{"docs":{},"e":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"f":{"docs":{},"i":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"h":{"docs":{},"i":{"docs":{},"b":{"docs":{},"i":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"s":{"docs":{},"p":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"r":{"docs":{},"e":{"docs":{},"q":{"docs":{},"u":{"docs":{},"i":{"docs":{},"s":{"docs":{},"i":{"docs":{},"t":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.015267175572519083}}}}}}}}}},"p":{"docs":{},"a":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"s":{"docs":{},"e":{"docs":{},"n":{"docs":{},"c":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}}}},"r":{"docs":{},"v":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643}}}}}},"v":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"i":{"docs":{},"o":{"docs":{},"u":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"s":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"d":{"docs":{},"i":{"docs":{},"c":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"i":{"docs":{},"m":{"docs":{},"a":{"docs":{},"g":{"docs":{},"e":{"docs":{},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}}}}}},"u":{"docs":{},"b":{"docs":{},"l":{"docs":{},"i":{"docs":{},"c":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0009230769230769231},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},":":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"l":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}},"s":{"docs":{},"h":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00230566534914361}},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"r":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"p":{"docs":{},"o":{"docs":{},"s":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"c":{"docs":{},"h":{"docs":{},"a":{"docs":{},"s":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"s":{"docs":{},"h":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"z":{"docs":{},"z":{"docs":{},"l":{"docs":{},"e":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"y":{"docs":{},"t":{"docs":{},"h":{"docs":{},"o":{"docs":{},"n":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}}},"h":{"docs":{},"r":{"docs":{},"a":{"docs":{},"s":{"docs":{},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"a":{"docs":{},"s":{"docs":{},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00230566534914361},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"i":{"docs":{},"l":{"docs":{},"o":{"docs":{},"s":{"docs":{},"o":{"docs":{},"p":{"docs":{},"h":{"docs":{},"y":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}}},"o":{"docs":{},"i":{"docs":{},"n":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}},"r":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"s":{"docs":{},"i":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"s":{"docs":{},"i":{"docs":{},"b":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"w":{"docs":{},"e":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"]":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"l":{"docs":{},"y":{"docs":{},"n":{"docs":{},"o":{"docs":{},"m":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"t":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}}}}}}}}},"r":{"docs":{},"a":{"docs":{},"p":{"docs":{},"i":{"docs":{},"d":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}},"l":{"docs":{},"i":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"n":{"docs":{},"d":{"docs":{},"o":{"docs":{},"m":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"g":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"k":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"t":{"docs":{},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"a":{"docs":{},"d":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}},"i":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"a":{"docs":{},"b":{"docs":{},"l":{"docs":{},"e":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"e":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"s":{"docs":{},"o":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"c":{"docs":{},"o":{"docs":{},"m":{"docs":{},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}}},"r":{"docs":{},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"k":{"docs":{},"e":{"docs":{},"e":{"docs":{},"p":{"docs":{},"e":{"docs":{},"r":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}}}}}}}}}}}},"e":{"docs":{},"i":{"docs":{},"v":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"e":{"docs":{},"a":{"docs":{},"d":{"docs":{},"d":{"docs":{},"r":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}}}}},"d":{"docs":{},"e":{"docs":{},"p":{"docs":{},"t":{"docs":{},"h":{"docs":{},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}}}}}},"n":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}},"l":{"docs":{},"a":{"docs":{},"i":{"docs":{},"m":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"i":{"docs":{},"p":{"docs":{},"i":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}},"f":{"docs":{},"e":{"docs":{},"r":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":2.500153846153846},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},"n":{"docs":{},"c":{"docs":{},"e":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"l":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"e":{"docs":{},"a":{"docs":{},"s":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}},"e":{"docs":{},"s":{"docs":{},",":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}}},"a":{"docs":{},"y":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"s":{"docs":{},"h":{"docs":{},"i":{"docs":{},"p":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}}}}}}},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}},"a":{"docs":{},"b":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}},"e":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"m":{"docs":{},"a":{"docs":{},"i":{"docs":{},"n":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"o":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.002}},"e":{"docs":{},"(":{"docs":{},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}},".":{"docs":{},"_":{"docs":{},"d":{"docs":{},"e":{"docs":{},"l":{"docs":{},"e":{"docs":{},"t":{"docs":{},"e":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"o":{"docs":{},"p":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"s":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"c":{"docs":{},"h":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"o":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"u":{"docs":{},"t":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"e":{"docs":{},"n":{"docs":{},"u":{"docs":{},"m":{"docs":{},"e":{"docs":{},"r":{"docs":{},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231}}}}}}}}}}}},"v":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}},"p":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"o":{"docs":{},"s":{"docs":{},"i":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{},"i":{"docs":{"./":{"ref":"./","tf":0.005494505494505495}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"s":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0013846153846153845}}}}}}},"i":{"docs":{},"e":{"docs":{},"v":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"a":{"docs":{},"i":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"l":{"docs":{},"a":{"docs":{},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"i":{"docs":{},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"q":{"docs":{},"u":{"docs":{},"i":{"docs":{},"r":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.00015384615384615385},"SERVICES.html":{"ref":"SERVICES.html","tf":0.025},"whitepaper.html":{"ref":"whitepaper.html","tf":0.005270092226613966},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.004240282685512367}},"e":{"docs":{},"(":{"docs":{},"'":{"docs":{},"@":{"docs":{},"f":{"docs":{},"a":{"docs":{},"b":{"docs":{},"r":{"docs":{},"i":{"docs":{},"c":{"docs":{},"/":{"docs":{},"c":{"docs":{},"o":{"docs":{},"r":{"docs":{},"e":{"docs":{},"'":{"docs":{},")":{"docs":{},";":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}},"/":{"docs":{},"s":{"docs":{},"e":{"docs":{},"r":{"docs":{},"v":{"docs":{},"i":{"docs":{},"c":{"docs":{},"e":{"docs":{},"s":{"docs":{},"/":{"docs":{},"b":{"docs":{},"i":{"docs":{},"t":{"docs":{},"c":{"docs":{},"o":{"docs":{},"i":{"docs":{},"n":{"docs":{},"'":{"docs":{},")":{"docs":{},";":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542},"SERVICES.html":{"ref":"SERVICES.html","tf":0.025}}}}}}}}}}}}}}}}}}}}},"t":{"docs":{},"y":{"docs":{},"p":{"docs":{},"e":{"docs":{},"s":{"docs":{},"/":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{},"'":{"docs":{},")":{"docs":{},";":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.0196078431372549}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},"s":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}},"s":{"docs":{},"i":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"e":{"docs":{},"s":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"SERVICES.html":{"ref":"SERVICES.html","tf":0.025},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0012307692307692308}}},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"s":{"docs":{},"e":{"docs":{},"a":{"docs":{},"r":{"docs":{},"c":{"docs":{},"h":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"o":{"docs":{},"l":{"docs":{},"v":{"docs":{"API.html":{"ref":"API.html","tf":0.003076923076923077}}},"u":{"docs":{},"t":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"u":{"docs":{},"r":{"docs":{},"c":{"docs":{"API.html":{"ref":"API.html","tf":0.0013846153846153845},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.004281949934123847},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.005653710247349823}},"e":{"docs":{},"'":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"(":{"docs":{},"d":{"docs":{},"e":{"docs":{},"f":{"docs":{},"i":{"docs":{},"n":{"docs":{},"i":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0012307692307692308}},"c":{"docs":{},"r":{"docs":{},"e":{"docs":{},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},"(":{"docs":{},"o":{"docs":{},"b":{"docs":{},"j":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}},"u":{"docs":{},"p":{"docs":{},"d":{"docs":{},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},"(":{"docs":{},"i":{"docs":{},"d":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}},"s":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"p":{"docs":{},"o":{"docs":{},"n":{"docs":{},"s":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"r":{"docs":{},"i":{"docs":{},"c":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}}},"u":{"docs":{},"l":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0021538461538461538},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}}},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"r":{"docs":{},"g":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"i":{"docs":{},"l":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"s":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"t":{"docs":{},"r":{"docs":{},"i":{"docs":{},"e":{"docs":{},"v":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0018461538461538461},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"a":{"docs":{},"l":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0024615384615384616}}}}}},"v":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}}}}},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.0012307692307692308},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643}},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"a":{"docs":{},"i":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"w":{"docs":{},"a":{"docs":{},"r":{"docs":{},"d":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"d":{"docs":{},"e":{"docs":{},"e":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}},"u":{"docs":{},"c":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"g":{"docs":{},"i":{"docs":{},"s":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}},"e":{"docs":{},"r":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"r":{"docs":{},"a":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"t":{"docs":{},"e":{"docs":{},"s":{"docs":{},"t":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"a":{"docs":{},"r":{"docs":{},"d":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}},"n":{"docs":{},"d":{"docs":{},"e":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}},"s":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"v":{"docs":{},"e":{"docs":{},"a":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"r":{"docs":{},"s":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"a":{"docs":{},"l":{"docs":{},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"i":{"docs":{},"e":{"docs":{},"w":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"e":{"docs":{},"r":{"docs":{},"s":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}},"i":{"docs":{},"n":{"docs":{},"f":{"docs":{},"o":{"docs":{},"r":{"docs":{},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"k":{"docs":{},"n":{"docs":{},"o":{"docs":{},"w":{"docs":{},"n":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"i":{"docs":{},"s":{"docs":{},"k":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},".":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}},"!":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"o":{"docs":{},"b":{"docs":{},"u":{"docs":{},"s":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}},"u":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"a":{"docs":{},"b":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.0016923076923076924}},"(":{"docs":{},"m":{"docs":{},"a":{"docs":{},"p":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}},"c":{"docs":{},"o":{"docs":{},"m":{"docs":{},"m":{"docs":{},"i":{"docs":{},"t":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"d":{"docs":{},"e":{"docs":{},"s":{"docs":{},"e":{"docs":{},"r":{"docs":{},"i":{"docs":{},"a":{"docs":{},"l":{"docs":{},"i":{"docs":{},"z":{"docs":{},"e":{"docs":{},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}},"f":{"docs":{},"o":{"docs":{},"r":{"docs":{},"k":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"i":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"n":{"docs":{},"h":{"docs":{},"e":{"docs":{},"r":{"docs":{},"i":{"docs":{},"t":{"docs":{},"s":{"docs":{},"(":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"b":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}},"n":{"docs":{},"o":{"docs":{},"w":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"r":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{},"e":{"docs":{},"r":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"o":{"docs":{},"u":{"docs":{},"t":{"docs":{},"e":{"docs":{},"(":{"docs":{},"m":{"docs":{},"s":{"docs":{},"g":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"s":{"docs":{},"e":{"docs":{},"r":{"docs":{},"i":{"docs":{},"a":{"docs":{},"l":{"docs":{},"i":{"docs":{},"z":{"docs":{},"e":{"docs":{},"(":{"docs":{},"[":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},"]":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}},"t":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"t":{"docs":{},"o":{"docs":{},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"r":{"docs":{},"u":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},"s":{"docs":{},"o":{"docs":{},"u":{"docs":{},"r":{"docs":{},"c":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}},"u":{"docs":{},"s":{"docs":{},"e":{"docs":{},"(":{"docs":{},"p":{"docs":{},"l":{"docs":{},"u":{"docs":{},"g":{"docs":{},"i":{"docs":{},"n":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.0013846153846153845}}}}}}}}}}},"s":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"g":{"docs":{},"h":{"docs":{},"l":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"l":{"docs":{},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"o":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.001976284584980237}}}},"t":{"docs":{},"a":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"p":{"docs":{},"g":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}},"u":{"docs":{},"n":{"docs":{"./":{"ref":"./","tf":0.024725274725274724},"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.015267175572519083},"API.html":{"ref":"API.html","tf":0.0010769230769230769},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915}}},"l":{"docs":{},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"f":{"docs":{},"c":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}},"s":{"docs":{},"a":{"docs":{},"v":{"docs":{},"e":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.015267175572519083}}}},"m":{"docs":{},"p":{"docs":{},"l":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"l":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"f":{"docs":{},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"k":{"docs":{},"e":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"\"":{"docs":{},"]":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"o":{"docs":{},"s":{"docs":{},"h":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}}},"y":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"e":{"docs":{},"c":{"docs":{},"u":{"docs":{},"r":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.008234519104084322},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.012014134275618375}},"e":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"i":{"docs":{},"t":{"docs":{},"y":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}},"o":{"docs":{},"n":{"docs":{},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}},"e":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542},"API.html":{"ref":"API.html","tf":0.00046153846153846153},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}}},"k":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},":":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"r":{"docs":{},"v":{"docs":{"./":{"ref":"./","tf":0.005494505494505495},"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"e":{"docs":{},"r":{"docs":{"./":{"ref":"./","tf":0.008241758241758242},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"i":{"docs":{},"c":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.005230769230769231},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.029411764705882353},"SERVICES.html":{"ref":"SERVICES.html","tf":3.408333333333333},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}},"e":{"docs":{},"'":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231}}},"(":{"docs":{},"c":{"docs":{},"o":{"docs":{},"n":{"docs":{},"f":{"docs":{},"i":{"docs":{},"g":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0015384615384615385}},"_":{"docs":{},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"g":{"docs":{},"i":{"docs":{},"s":{"docs":{},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{},"(":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{},"(":{"docs":{},"m":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},"a":{"docs":{},"g":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}},"c":{"docs":{},"o":{"docs":{},"n":{"docs":{},"n":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{},"(":{"docs":{},"n":{"docs":{},"o":{"docs":{},"t":{"docs":{},"i":{"docs":{},"f":{"docs":{},"y":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}},"h":{"docs":{},"a":{"docs":{},"n":{"docs":{},"d":{"docs":{},"l":{"docs":{},"e":{"docs":{},"r":{"docs":{},"(":{"docs":{},"m":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},"a":{"docs":{},"g":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}},"r":{"docs":{},"o":{"docs":{},"u":{"docs":{},"t":{"docs":{},"e":{"docs":{},"(":{"docs":{},"m":{"docs":{},"s":{"docs":{},"g":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"s":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{},"(":{"docs":{},"c":{"docs":{},"h":{"docs":{},"a":{"docs":{},"n":{"docs":{},"n":{"docs":{},"e":{"docs":{},"l":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"t":{"docs":{},"i":{"docs":{},"c":{"docs":{},"k":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.0010769230769230769}}}}}}}}}},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"SERVICES.html":{"ref":"SERVICES.html","tf":0.025}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"a":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231}},"i":{"docs":{},"z":{"docs":{},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231}}}}}}}}}},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.005846153846153846},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}},"b":{"docs":{},"o":{"docs":{},"d":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"f":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"e":{"docs":{},"s":{"docs":{},".":{"docs":{},"m":{"docs":{},"i":{"docs":{},"n":{"docs":{},"i":{"docs":{},"m":{"docs":{},"u":{"docs":{},"m":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}},"i":{"docs":{},"n":{"docs":{},"i":{"docs":{},"t":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"e":{"docs":{},"d":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"s":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"v":{"docs":{},"e":{"docs":{},"r":{"docs":{"./":{"ref":"./","tf":0.005494505494505495},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"a":{"docs":{},"r":{"docs":{},"c":{"docs":{},"h":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"l":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"o":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"f":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"l":{"docs":{},"e":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}}}}},"m":{"docs":{},"a":{"docs":{},"n":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}},"i":{"docs":{},"c":{"docs":{},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}},"n":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}}},"e":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}},"s":{"docs":{},"s":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.0012307692307692308},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"(":{"docs":{},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"s":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"o":{"docs":{},"p":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}},"p":{"docs":{},"a":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"q":{"docs":{},"u":{"docs":{},"e":{"docs":{},"n":{"docs":{},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},".":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}},"i":{"docs":{},"m":{"docs":{},"p":{"docs":{},"l":{"docs":{"./":{"ref":"./","tf":0.01098901098901099},"API.html":{"ref":"API.html","tf":0.0010769230769230769},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0036231884057971015},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}},"e":{"docs":{},"!":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"s":{"docs":{},"t":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}},"c":{"docs":{},"i":{"docs":{},"t":{"docs":{},"y":{"docs":{},"'":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"y":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"u":{"docs":{},"l":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"t":{"docs":{},"a":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"i":{"docs":{},"l":{"docs":{},"a":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"l":{"docs":{},"y":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}},"g":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"(":{"docs":{},")":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}}}},"a":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},"s":{"docs":{},",":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"o":{"docs":{},"r":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"i":{"docs":{},"f":{"docs":{},"i":{"docs":{},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}}}}}}},"n":{"docs":{},"g":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"u":{"docs":{},"l":{"docs":{},"a":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"z":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"]":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"d":{"docs":{},"e":{"docs":{},"c":{"docs":{},"h":{"docs":{},"a":{"docs":{},"i":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"l":{"docs":{},"o":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"o":{"docs":{},"u":{"docs":{},"n":{"docs":{},"d":{"docs":{},"t":{"docs":{},"r":{"docs":{},"a":{"docs":{},"c":{"docs":{},"k":{"docs":{},".":{"docs":{},"i":{"docs":{},"o":{"docs":{},",":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}}}}}}}}},"r":{"docs":{},"c":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.002},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}},"e":{"docs":{},".":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0015384615384615385}}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"m":{"docs":{},"e":{"docs":{},"t":{"docs":{},"h":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}},"f":{"docs":{},"t":{"docs":{},"w":{"docs":{},"a":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"l":{"docs":{},"u":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"v":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}},"r":{"docs":{},"t":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.008241758241758242},"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":3.3409669211195925},"API.html":{"ref":"API.html","tf":0.0018461538461538461},"SERVICES.html":{"ref":"SERVICES.html","tf":0.025},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"e":{"docs":{},"d":{"docs":{},",":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"!":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"t":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.013076923076923076},"whitepaper.html":{"ref":"whitepaper.html","tf":0.004281949934123847},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0035335689045936395}},".":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0038461538461538464},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"c":{"docs":{},"o":{"docs":{},"m":{"docs":{},"m":{"docs":{},"i":{"docs":{},"t":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"d":{"docs":{},"e":{"docs":{},"s":{"docs":{},"e":{"docs":{},"r":{"docs":{},"i":{"docs":{},"a":{"docs":{},"l":{"docs":{},"i":{"docs":{},"z":{"docs":{},"e":{"docs":{},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}},"f":{"docs":{},"o":{"docs":{},"r":{"docs":{},"k":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"r":{"docs":{},"o":{"docs":{},"m":{"docs":{},"j":{"docs":{},"s":{"docs":{},"o":{"docs":{},"n":{"docs":{},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"i":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"r":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{},"e":{"docs":{},"r":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"s":{"docs":{},"e":{"docs":{},"r":{"docs":{},"i":{"docs":{},"a":{"docs":{},"l":{"docs":{},"i":{"docs":{},"z":{"docs":{},"e":{"docs":{},"(":{"docs":{},"[":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},"]":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}},"t":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"t":{"docs":{},"o":{"docs":{},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}},"(":{"docs":{},"d":{"docs":{},"a":{"docs":{},"t":{"docs":{},"a":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"p":{"docs":{},"r":{"docs":{},"o":{"docs":{},"p":{"docs":{},"e":{"docs":{},"r":{"docs":{},"t":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}}}}}}}}}}},"u":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"i":{"docs":{},"c":{"docs":{"API.html":{"ref":"API.html","tf":0.0018461538461538461}}}}},"c":{"docs":{},"k":{"docs":{"API.html":{"ref":"API.html","tf":0.0021538461538461538},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"#":{"docs":{},"f":{"docs":{},"r":{"docs":{},"a":{"docs":{},"m":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"i":{"docs":{},"d":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"(":{"docs":{},"[":{"docs":{},"l":{"docs":{},"i":{"docs":{},"s":{"docs":{},"t":{"docs":{},"]":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0010769230769230769}},"p":{"docs":{},"u":{"docs":{},"s":{"docs":{},"h":{"docs":{},"(":{"docs":{},"d":{"docs":{},"a":{"docs":{},"t":{"docs":{},"a":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"n":{"docs":{},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"a":{"docs":{},"r":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"s":{"docs":{},"h":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"b":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"e":{"docs":{},"p":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"o":{"docs":{},"p":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}}},"r":{"docs":{},"a":{"docs":{},"g":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"e":{"docs":{},"(":{"docs":{},"c":{"docs":{},"o":{"docs":{},"n":{"docs":{},"f":{"docs":{},"i":{"docs":{},"g":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0013846153846153845}},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.005692307692307693},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"(":{"docs":{},"[":{"docs":{},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"s":{"docs":{},"]":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0010769230769230769}},"_":{"docs":{},"p":{"docs":{},"o":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"g":{"docs":{},"i":{"docs":{},"s":{"docs":{},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{},"(":{"docs":{},"o":{"docs":{},"b":{"docs":{},"j":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}},"d":{"docs":{},"e":{"docs":{},"l":{"docs":{},"(":{"docs":{},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"f":{"docs":{},"l":{"docs":{},"u":{"docs":{},"s":{"docs":{},"h":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"(":{"docs":{},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"(":{"docs":{},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"t":{"docs":{},"r":{"docs":{},"u":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},"s":{"docs":{},"o":{"docs":{},"u":{"docs":{},"r":{"docs":{},"c":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"a":{"docs":{},"m":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}}}}}},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{"API.html":{"ref":"API.html","tf":0.02}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0013846153846153845}}}}}},"u":{"docs":{},"c":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},"g":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"u":{"docs":{},"b":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"b":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}},"p":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"s":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}}},"e":{"docs":{},"q":{"docs":{},"u":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"t":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"i":{"docs":{},"d":{"docs":{},"i":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},"s":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"y":{"docs":{},"\"":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"t":{"docs":{},"r":{"docs":{},"a":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"g":{"docs":{},"r":{"docs":{},"a":{"docs":{},"p":{"docs":{},"h":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}}}}}},"j":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"m":{"docs":{},"i":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"c":{"docs":{},"c":{"docs":{},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"s":{"docs":{},"s":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.00046153846153846153},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"h":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.004940711462450593},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0049469964664310955}},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"p":{"docs":{},"p":{"docs":{},"o":{"docs":{},"r":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"s":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"l":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"y":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231}}},")":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"d":{"docs":{},"o":{"docs":{},"k":{"docs":{},"u":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"g":{"docs":{},"a":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"r":{"docs":{},"r":{"docs":{},"o":{"docs":{},"u":{"docs":{},"n":{"docs":{},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}}}},"f":{"docs":{},"f":{"docs":{},"i":{"docs":{},"c":{"docs":{},"i":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0012307692307692308},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643}},"s":{"docs":{},"/":{"docs":{},"q":{"docs":{},"u":{"docs":{},"i":{"docs":{},"c":{"docs":{},"k":{"docs":{},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{},".":{"docs":{},"j":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.015267175572519083}}}}}}}}}}}}}}}},"(":{"docs":{},"c":{"docs":{},"o":{"docs":{},"n":{"docs":{},"f":{"docs":{},"i":{"docs":{},"g":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"'":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"b":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.009076923076923076}},"(":{"docs":{},"c":{"docs":{},"o":{"docs":{},"n":{"docs":{},"f":{"docs":{},"i":{"docs":{},"g":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0013846153846153845}},"c":{"docs":{},"o":{"docs":{},"m":{"docs":{},"m":{"docs":{},"i":{"docs":{},"t":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"d":{"docs":{},"e":{"docs":{},"s":{"docs":{},"e":{"docs":{},"r":{"docs":{},"i":{"docs":{},"a":{"docs":{},"l":{"docs":{},"i":{"docs":{},"z":{"docs":{},"e":{"docs":{},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}},"f":{"docs":{},"o":{"docs":{},"r":{"docs":{},"k":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"i":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"n":{"docs":{},"h":{"docs":{},"e":{"docs":{},"r":{"docs":{},"i":{"docs":{},"t":{"docs":{},"s":{"docs":{},"(":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"b":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}},"n":{"docs":{},"o":{"docs":{},"w":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"r":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{},"e":{"docs":{},"r":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"s":{"docs":{},"e":{"docs":{},"r":{"docs":{},"i":{"docs":{},"a":{"docs":{},"l":{"docs":{},"i":{"docs":{},"z":{"docs":{},"e":{"docs":{},"(":{"docs":{},"[":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},"]":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}},"t":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"t":{"docs":{},"o":{"docs":{},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"r":{"docs":{},"u":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},"s":{"docs":{},"o":{"docs":{},"u":{"docs":{},"r":{"docs":{},"c":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}},"p":{"docs":{},"r":{"docs":{},"o":{"docs":{},"p":{"docs":{},"e":{"docs":{},"r":{"docs":{},"t":{"docs":{},"i":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.0010769230769230769}}}}}}}}}}}}}},"a":{"docs":{},"l":{"docs":{},"a":{"docs":{},"b":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"i":{"docs":{},"l":{"docs":{},"i":{"docs":{},"t":{"docs":{},"y":{"docs":{},".":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"r":{"docs":{},"c":{"docs":{},"e":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"h":{"docs":{},"e":{"docs":{},"m":{"docs":{},"a":{"docs":{},".":{"docs":{},"o":{"docs":{},"r":{"docs":{},"g":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"i":{"docs":{},"e":{"docs":{},"n":{"docs":{},"c":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"o":{"docs":{},"p":{"docs":{},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"h":{"docs":{},"a":{"2":{"5":{"6":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"docs":{}},"docs":{}},"docs":{},"r":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"d":{"docs":{},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"e":{"docs":{},"e":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":2.5}}}}}},"l":{"docs":{},"i":{"docs":{},"c":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"g":{"docs":{},"h":{"docs":{},"t":{"docs":{},"l":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"n":{"docs":{},"a":{"docs":{},"p":{"docs":{},"s":{"docs":{},"h":{"docs":{},"o":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0010769230769230769}},"(":{"docs":{},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"s":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"c":{"docs":{},"o":{"docs":{},"m":{"docs":{},"m":{"docs":{},"i":{"docs":{},"t":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"}":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"p":{"docs":{},"a":{"docs":{},"c":{"docs":{},"e":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}},"e":{"docs":{},"c":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"i":{"docs":{},"f":{"docs":{"API.html":{"ref":"API.html","tf":0.0010769230769230769},"whitepaper.html":{"ref":"whitepaper.html","tf":0.001976284584980237},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"c":{"docs":{},"a":{"docs":{},"l":{"docs":{},"l":{"docs":{},"y":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}},"a":{"docs":{},"l":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}}}}},"t":{"docs":{},"r":{"docs":{},"u":{"docs":{},"m":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"n":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"a":{"docs":{},"b":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"a":{"docs":{},"k":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"e":{"docs":{},"c":{"docs":{},"h":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"v":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}},"s":{"docs":{},"o":{"docs":{},"u":{"docs":{},"r":{"docs":{},"c":{"docs":{},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"l":{"docs":{},"i":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"r":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"e":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}}}}},"w":{"docs":{},"a":{"docs":{},"p":{"docs":{"API.html":{"ref":"API.html","tf":0.0013846153846153845}},"(":{"docs":{},"[":{"docs":{},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"s":{"docs":{},"]":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}},"e":{"docs":{},"x":{"docs":{},"t":{"docs":{},"r":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{},"s":{"docs":{},"e":{"docs":{},"c":{"docs":{},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"(":{"docs":{},"t":{"docs":{},"x":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"r":{"docs":{},"m":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231}},"(":{"docs":{},"c":{"docs":{},"o":{"docs":{},"n":{"docs":{},"f":{"docs":{},"i":{"docs":{},"g":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"t":{"docs":{},"r":{"docs":{},"u":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},"s":{"docs":{},"o":{"docs":{},"u":{"docs":{},"r":{"docs":{},"c":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}},"y":{"docs":{},"m":{"docs":{},"b":{"docs":{},"o":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"p":{"docs":{},"o":{"docs":{},"s":{"docs":{},"i":{"docs":{},"u":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"n":{"docs":{},"t":{"docs":{},"a":{"docs":{},"x":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"c":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"s":{"docs":{},"t":{"docs":{},"e":{"docs":{},"m":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0036231884057971015},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}},"'":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"s":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"]":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}}}},"m":{"docs":{},"a":{"docs":{},"l":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"r":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}}}}},"p":{"docs":{},"c":{"docs":{},".":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"z":{"docs":{},"a":{"docs":{},"b":{"docs":{},"o":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},"c":{"docs":{},"h":{"docs":{},"n":{"docs":{},"o":{"docs":{},"l":{"docs":{},"o":{"docs":{},"g":{"docs":{},"y":{"docs":{},".":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}}}},"i":{"docs":{},"q":{"docs":{},"u":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"m":{"docs":{},"p":{"docs":{},"l":{"docs":{},"a":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"r":{"docs":{},"m":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}},"i":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}}}}}},"s":{"docs":{},"t":{"docs":{},"n":{"docs":{},"e":{"docs":{},"t":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"n":{"docs":{},"e":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"h":{"docs":{},"e":{"docs":{},"m":{"docs":{},",":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}},"s":{"docs":{},"e":{"docs":{},"l":{"docs":{},"v":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"r":{"docs":{},"e":{"docs":{},"i":{"docs":{},"n":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"'":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}}}},"m":{"docs":{},"o":{"docs":{},"d":{"docs":{},"y":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}},"y":{"docs":{},"'":{"docs":{},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}},"s":{"docs":{},",":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}},"k":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"s":{"docs":{},".":{"docs":{},"c":{"docs":{},"h":{"docs":{},"a":{"docs":{},"i":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"r":{"docs":{},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"o":{"docs":{},"u":{"docs":{},"g":{"docs":{},"h":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}},"s":{"docs":{},"a":{"docs":{},"n":{"docs":{},"d":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"r":{"docs":{},"o":{"docs":{},"u":{"docs":{},"g":{"docs":{},"h":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}},"w":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"e":{"docs":{},"s":{"docs":{},"h":{"docs":{},"o":{"docs":{},"l":{"docs":{},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"e":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"o":{"docs":{},"o":{"docs":{},"l":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0003076923076923077},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231}}},"p":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"o":{"docs":{},"l":{"docs":{},"o":{"docs":{},"g":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"y":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}},"d":{"docs":{},"a":{"docs":{},"y":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"o":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"k":{"docs":{},"e":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"s":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}}},"w":{"docs":{},"a":{"docs":{},"r":{"docs":{},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"l":{"docs":{},"e":{"docs":{},"r":{"docs":{},"a":{"docs":{},"b":{"docs":{},"l":{"docs":{},"e":{"docs":{},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}}},"r":{"docs":{},"a":{"docs":{},"n":{"docs":{},"s":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0024615384615384616},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.004940711462450593},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.009187279151943463}},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"s":{"docs":{},".":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0012307692307692308}}}}}}}}},"i":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0010769230769230769}},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"(":{"docs":{},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"s":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}},"m":{"docs":{},"i":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"f":{"docs":{},"e":{"docs":{},"r":{"docs":{},"s":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"c":{"docs":{},"k":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"d":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"i":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}},"i":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"g":{"docs":{},"g":{"docs":{},"e":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"p":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"v":{"docs":{},"i":{"docs":{},"a":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"u":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}},",":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}},"s":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0036231884057971015},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"l":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},"l":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}},"t":{"docs":{},"h":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}},"e":{"docs":{},"a":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"w":{"docs":{},"i":{"docs":{},"t":{"docs":{},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}},":":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"o":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}}}},"y":{"docs":{},"p":{"docs":{},"e":{"docs":{"./":{"ref":"./","tf":0.005494505494505495},"API.html":{"ref":"API.html","tf":0.030307692307692306},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},".":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.0007692307692307692}}},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"s":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"i":{"docs":{},"c":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}},"a":{"docs":{},"g":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"k":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0028268551236749115}}}},"r":{"docs":{},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"h":{"docs":{},"o":{"docs":{},"s":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"s":{"docs":{},"e":{"docs":{},"c":{"docs":{},"u":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"s":{"docs":{},"k":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"c":{"docs":{},"k":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"n":{"docs":{},"g":{"docs":{},"i":{"docs":{},"b":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"i":{"docs":{},"c":{"docs":{},"k":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"m":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.001976284584980237},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}}},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"m":{"docs":{},"p":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"f":{"docs":{},"r":{"docs":{},"a":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"o":{"docs":{},"u":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"o":{"docs":{},"t":{"docs":{},"h":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"p":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"g":{"docs":{},"h":{"docs":{},"t":{"docs":{},"l":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"x":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}}},"^":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"u":{"docs":{},"n":{"docs":{},"i":{"docs":{},"v":{"docs":{},"e":{"docs":{},"r":{"docs":{},"s":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}}},"q":{"docs":{},"u":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}}}},"f":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"x":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"r":{"docs":{},"e":{"docs":{},"l":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}},"d":{"docs":{},"e":{"docs":{},"f":{"docs":{},"i":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"r":{"docs":{},"l":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}}}}}}},"m":{"docs":{},"a":{"docs":{},"r":{"docs":{},"s":{"docs":{},"h":{"docs":{},"a":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}}}}}}}}},"e":{"docs":{},"n":{"docs":{},"c":{"docs":{},"r":{"docs":{},"y":{"docs":{},"p":{"docs":{},"t":{"docs":{},"e":{"docs":{},"d":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}}},"k":{"docs":{},"n":{"docs":{},"o":{"docs":{},"w":{"docs":{},"a":{"docs":{},"b":{"docs":{},"l":{"docs":{},"e":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"s":{"docs":{},"p":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"t":{"docs":{},"i":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"r":{"docs":{},"u":{"docs":{},"s":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}}}},"p":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"!":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}},"d":{"docs":{},"a":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"s":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"n":{"docs":{},"p":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"o":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643}}}},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"s":{"docs":{"./":{"ref":"./","tf":0.024725274725274724},"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.015267175572519083},"API.html":{"ref":"API.html","tf":0.0043076923076923075},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.0196078431372549},"whitepaper.html":{"ref":"whitepaper.html","tf":0.007575757575757576},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.005653710247349823}},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}}},"d":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.0012307692307692308},"whitepaper.html":{"ref":"whitepaper.html","tf":0.001976284584980237},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0035335689045936395}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"s":{"docs":{},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"t":{"docs":{},"i":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}},"i":{"docs":{},"z":{"docs":{},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"d":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}}},"v":{"docs":{},"a":{"docs":{},"r":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},"t":{"docs":{},"i":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}}}}},"o":{"docs":{},"u":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"i":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692},"whitepaper.html":{"ref":"whitepaper.html","tf":0.001976284584980237},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"u":{"docs":{"API.html":{"ref":"API.html","tf":0.005076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00230566534914361},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0035335689045936395}},"e":{"docs":{},"(":{"docs":{},"d":{"docs":{},"a":{"docs":{},"t":{"docs":{},"a":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0015384615384615385}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0021538461538461538},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"v":{"docs":{},"a":{"docs":{},"l":{"docs":{},"u":{"docs":{},"e":{"docs":{},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}},"s":{"docs":{},")":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"a":{"docs":{},"b":{"docs":{},"l":{"docs":{},"e":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}},"e":{"docs":{},"r":{"docs":{},"s":{"docs":{},"e":{"docs":{},",":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542},"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"b":{"docs":{},"o":{"docs":{},"s":{"docs":{},"i":{"docs":{},"t":{"docs":{},"y":{"docs":{},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}}},"a":{"docs":{},"t":{"docs":{},"i":{"docs":{},"m":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"f":{"docs":{},"i":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542},"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}},"e":{"docs":{},"r":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"d":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"y":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"c":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.005076923076923077}},"(":{"docs":{},"o":{"docs":{},"r":{"docs":{},"i":{"docs":{},"g":{"docs":{},"i":{"docs":{},"n":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}},"_":{"docs":{},"s":{"docs":{},"e":{"docs":{},"r":{"docs":{},"i":{"docs":{},"a":{"docs":{},"l":{"docs":{},"i":{"docs":{},"z":{"docs":{},"e":{"docs":{},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}},"t":{"docs":{},"o":{"docs":{},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}},"i":{"docs":{},"e":{"docs":{},"w":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}},"r":{"docs":{},"t":{"docs":{},"u":{"docs":{},"a":{"docs":{},"l":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"a":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"b":{"docs":{},"l":{"docs":{},"e":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"s":{"docs":{},"u":{"docs":{},"a":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"o":{"docs":{},"l":{"docs":{},"u":{"docs":{},"n":{"docs":{},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"m":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"t":{"docs":{},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}},"w":{"docs":{},"a":{"docs":{},"i":{"docs":{},"t":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}},"y":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"?":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"l":{"docs":{},"l":{"docs":{},"e":{"docs":{},"t":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542},"API.html":{"ref":"API.html","tf":0.002}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}},".":{"docs":{},".":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}},"_":{"docs":{},"c":{"docs":{},"r":{"docs":{},"e":{"docs":{},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},"c":{"docs":{},"r":{"docs":{},"o":{"docs":{},"w":{"docs":{},"d":{"docs":{},"f":{"docs":{},"u":{"docs":{},"n":{"docs":{},"d":{"docs":{},"(":{"docs":{},"f":{"docs":{},"u":{"docs":{},"n":{"docs":{},"d":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}}}},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"r":{"docs":{},"e":{"docs":{},"f":{"docs":{},"u":{"docs":{},"n":{"docs":{},"d":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{},"(":{"docs":{},"r":{"docs":{},"e":{"docs":{},"d":{"docs":{},"e":{"docs":{},"e":{"docs":{},"m":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"w":{"docs":{},"a":{"docs":{},"p":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{},"(":{"docs":{},"r":{"docs":{},"e":{"docs":{},"d":{"docs":{},"e":{"docs":{},"e":{"docs":{},"m":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"l":{"docs":{},"o":{"docs":{},"a":{"docs":{},"d":{"docs":{},"(":{"docs":{},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"s":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}},"s":{"docs":{},"i":{"docs":{},"g":{"docs":{},"n":{"docs":{},"(":{"docs":{},"t":{"docs":{},"x":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"c":{"docs":{},"r":{"docs":{},"e":{"docs":{},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},"p":{"docs":{},"r":{"docs":{},"i":{"docs":{},"c":{"docs":{},"e":{"docs":{},"d":{"docs":{},"o":{"docs":{},"r":{"docs":{},"d":{"docs":{},"e":{"docs":{},"r":{"docs":{},"(":{"docs":{},"o":{"docs":{},"r":{"docs":{},"d":{"docs":{},"e":{"docs":{},"r":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}}}}}}},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"a":{"docs":{},"d":{"docs":{},"d":{"docs":{},"r":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},"f":{"docs":{},"o":{"docs":{},"r":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{},"(":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}},"r":{"docs":{},"o":{"docs":{},"m":{"docs":{},"r":{"docs":{},"e":{"docs":{},"d":{"docs":{},"e":{"docs":{},"e":{"docs":{},"m":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{},"(":{"docs":{},"r":{"docs":{},"e":{"docs":{},"d":{"docs":{},"e":{"docs":{},"e":{"docs":{},"m":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"p":{"docs":{},"u":{"docs":{},"b":{"docs":{},"l":{"docs":{},"i":{"docs":{},"c":{"docs":{},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{},"f":{"docs":{},"r":{"docs":{},"o":{"docs":{},"m":{"docs":{},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"(":{"docs":{},"[":{"docs":{},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"s":{"docs":{},"]":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}},"k":{"docs":{},"e":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"i":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}},".":{"docs":{},"_":{"docs":{},"d":{"docs":{},"e":{"docs":{},"f":{"docs":{},"i":{"docs":{},"n":{"docs":{},"e":{"docs":{},"(":{"docs":{},"d":{"docs":{},"i":{"docs":{},"r":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}},"e":{"docs":{},"x":{"docs":{},"p":{"docs":{},"l":{"docs":{},"o":{"docs":{},"r":{"docs":{},"e":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}}},"t":{"docs":{},"c":{"docs":{},"h":{"docs":{},"o":{"docs":{},"n":{"docs":{},"l":{"docs":{},"y":{"docs":{},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}}}}},"n":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"r":{"docs":{},"n":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"!":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"v":{"docs":{},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"e":{"docs":{},"b":{"docs":{"./":{"ref":"./","tf":0.005494505494505495},"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00230566534914361},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"s":{"docs":{},".":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"l":{"docs":{},"l":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"'":{"docs":{},"v":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}},"a":{"docs":{},"l":{"docs":{},"t":{"docs":{},"h":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"e":{"docs":{},"k":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},")":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"o":{"docs":{},"r":{"docs":{},"k":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0029644268774703555},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.005653710247349823}},".":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"e":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"(":{"docs":{},"m":{"docs":{},"e":{"docs":{},"t":{"docs":{},"h":{"docs":{},"o":{"docs":{},"d":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}},".":{"docs":{},"c":{"docs":{},"o":{"docs":{},"m":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},"e":{"docs":{},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"u":{"docs":{},"r":{"docs":{},"n":{"docs":{},"s":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"f":{"docs":{},"l":{"docs":{},"o":{"docs":{},"w":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}},"\"":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"l":{"docs":{},"o":{"docs":{},"a":{"docs":{},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}}},"l":{"docs":{},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"'":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"i":{"docs":{},"d":{"docs":{},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}},"e":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}},"s":{"docs":{},"p":{"docs":{},"r":{"docs":{},"e":{"docs":{},"a":{"docs":{},"d":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"t":{"docs":{},"n":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}},"h":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"i":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153},"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"o":{"docs":{},"u":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0036231884057971015},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0049469964664310955}}}}}}},"p":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}},"s":{"docs":{},"e":{"docs":{},"l":{"docs":{},"y":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"h":{"docs":{},"e":{"docs":{},"t":{"docs":{},"h":{"docs":{},"e":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"r":{"docs":{},"e":{"docs":{},"b":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}},"i":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}}},"i":{"docs":{},"t":{"docs":{},"e":{"docs":{},"p":{"docs":{},"a":{"docs":{},"p":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":3.333333333333333},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":3.333333333333333}}}}}}}}},"r":{"docs":{},"i":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}},"y":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}},"o":{"docs":{},"u":{"docs":{},"'":{"docs":{},"r":{"docs":{"./":{"ref":"./","tf":0.005494505494505495}}}},".":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}}}},"a":{"docs":{},"o":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"'":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}},"{":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.022900763358778626},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745},"whitepaper.html":{"ref":"whitepaper.html","tf":0.004940711462450593}},"@":{"docs":{},"l":{"docs":{},"i":{"docs":{},"n":{"docs":{},"k":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}},"}":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"}":{"docs":{"API.html":{"ref":"API.html","tf":0.0012307692307692308}}}},"}":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.015267175572519083},"whitepaper.html":{"ref":"whitepaper.html","tf":0.003952569169960474}},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},";":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475},"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.015267175572519083},"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}}}},"\"":{"docs":{},"]":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}}}},"\ud83d":{"docs":{},"\udea8":{"docs":{"./":{"ref":"./","tf":0.0027472527472527475}}},"\udc40":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":3.333333333333333}}},"\udda8":{"docs":{},"️":{"docs":{"API.html":{"ref":"API.html","tf":2.5}}}},"\udcc4":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":3.333333333333333}}},"\udcc3":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":3.333333333333333}}}},"\ud83e":{"docs":{},"\udd14":{"docs":{"./":{"ref":"./","tf":5}}},"\udd2f":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":3.333333333333333}}}},"'":{"1":{"docs":{},"c":{"docs":{},"x":{"docs":{},"a":{"docs":{},"b":{"docs":{},"h":{"docs":{},"x":{"docs":{},"m":{"docs":{},"i":{"docs":{},"y":{"docs":{},"n":{"docs":{},"p":{"docs":{},"g":{"docs":{},"z":{"2":{"docs":{},"k":{"2":{"docs":{},"g":{"docs":{},"n":{"docs":{},"p":{"docs":{},"r":{"docs":{},"x":{"docs":{},"y":{"6":{"docs":{},"b":{"docs":{},"n":{"docs":{},"c":{"docs":{},"n":{"docs":{},"k":{"docs":{},"v":{"docs":{},"o":{"docs":{},"e":{"docs":{},"g":{"docs":{},"w":{"docs":{},"'":{"docs":{},",":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}}}}}}}}}},"docs":{}}}}}}}},"docs":{}}},"docs":{}}}}}}}}}}}}}},"l":{"3":{"docs":{},"l":{"docs":{},"y":{"docs":{},"a":{"docs":{},"p":{"docs":{},"m":{"docs":{},"h":{"docs":{},"f":{"docs":{},"u":{"docs":{},"h":{"docs":{},"l":{"docs":{},"d":{"docs":{},"t":{"docs":{},"s":{"docs":{},"j":{"docs":{},"z":{"docs":{},"w":{"7":{"7":{"docs":{},"b":{"docs":{},"s":{"docs":{},"q":{"docs":{},"h":{"docs":{},"z":{"docs":{},"c":{"5":{"docs":{},"e":{"docs":{},"s":{"docs":{},"x":{"9":{"docs":{},"q":{"docs":{},"f":{"docs":{},"'":{"docs":{},",":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}},"docs":{}}}}},"docs":{}}}}}}}},"docs":{}},"docs":{}}}}}}}}}}}}}}}}}},"docs":{}}},"docs":{},"d":{"docs":{},"e":{"docs":{},"f":{"docs":{},"a":{"docs":{},"u":{"docs":{},"l":{"docs":{},"t":{"docs":{},"'":{"docs":{},",":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}}}},"a":{"docs":{},"d":{"docs":{},"b":{"docs":{},"e":{"docs":{},"e":{"docs":{},"f":{"docs":{},".":{"docs":{},".":{"docs":{},".":{"docs":{},"'":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}},"m":{"docs":{},"a":{"docs":{},"i":{"docs":{},"n":{"docs":{},"'":{"docs":{},",":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}}},"p":{"docs":{},"u":{"docs":{},"b":{"docs":{},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{},"h":{"docs":{},"a":{"docs":{},"s":{"docs":{},"h":{"docs":{},"'":{"docs":{},",":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}}}}}}}}},"q":{"docs":{},"u":{"docs":{},"i":{"docs":{},"c":{"docs":{},"k":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}},"w":{"docs":{},"l":{"docs":{},"t":{"docs":{},"t":{"docs":{},"t":{"docs":{},"u":{"docs":{},"q":{"docs":{},"a":{"docs":{},"m":{"docs":{},"t":{"docs":{},"x":{"docs":{},"m":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"3":{"3":{"docs":{},"g":{"docs":{},"l":{"docs":{},"f":{"1":{"docs":{},"b":{"docs":{},"n":{"2":{"docs":{},"j":{"docs":{},"s":{"5":{"docs":{},"h":{"docs":{},"e":{"docs":{},"s":{"docs":{},"w":{"docs":{},"x":{"docs":{},"h":{"docs":{},"e":{"docs":{},"h":{"docs":{},"e":{"docs":{},"'":{"docs":{},",":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}}}}}}}}},"docs":{}}}},"docs":{}}}},"docs":{}}}}},"docs":{}},"docs":{}}}}}}}}}}}}}}}},"x":{"docs":{},"p":{"docs":{},"u":{"docs":{},"b":{"6":{"docs":{},"c":{"docs":{},"n":{"1":{"docs":{},"n":{"6":{"docs":{},"i":{"docs":{},"w":{"docs":{},"a":{"docs":{},"p":{"docs":{},"y":{"docs":{},"r":{"docs":{},"q":{"docs":{},"o":{"docs":{},"d":{"4":{"docs":{},"s":{"docs":{},"s":{"9":{"docs":{},"s":{"docs":{},"x":{"4":{"docs":{},"i":{"2":{"docs":{},"f":{"docs":{},"l":{"docs":{},"m":{"docs":{},"d":{"docs":{},"z":{"4":{"docs":{},"z":{"docs":{},"s":{"docs":{},"w":{"docs":{},"b":{"5":{"docs":{},"n":{"docs":{},"u":{"docs":{},"l":{"docs":{},"g":{"6":{"docs":{},"d":{"docs":{},"g":{"docs":{},"c":{"docs":{},"n":{"docs":{},"x":{"docs":{},"m":{"docs":{},"v":{"docs":{},"i":{"docs":{},"k":{"docs":{},"a":{"docs":{},"o":{"docs":{},"r":{"docs":{},"k":{"3":{"docs":{},"k":{"docs":{},"f":{"docs":{},"r":{"docs":{},"i":{"docs":{},"h":{"docs":{},"q":{"docs":{},"r":{"docs":{},"q":{"docs":{},"l":{"docs":{},"s":{"docs":{},"p":{"docs":{},"i":{"docs":{},"n":{"docs":{},"t":{"docs":{},"d":{"docs":{},"m":{"docs":{},"v":{"docs":{},"h":{"docs":{},"g":{"docs":{},"j":{"7":{"docs":{},"f":{"docs":{},"f":{"1":{"docs":{},"l":{"docs":{},"m":{"docs":{},"l":{"docs":{},"i":{"docs":{},"d":{"docs":{},"c":{"docs":{},"v":{"docs":{},"e":{"docs":{},"m":{"docs":{},"f":{"8":{"docs":{},"k":{"docs":{},"p":{"docs":{},"h":{"docs":{},"s":{"docs":{},"x":{"5":{"1":{"docs":{},"c":{"docs":{},"j":{"docs":{},"b":{"docs":{},"t":{"docs":{},"z":{"docs":{},"t":{"docs":{},"c":{"docs":{},"q":{"docs":{},"i":{"docs":{},"d":{"docs":{},"u":{"docs":{},"'":{"docs":{},",":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}}}}}}}}}}},"docs":{}},"docs":{}}}}}}},"docs":{}}}}}}}}}}}},"docs":{}}}},"docs":{}}}}}}}}}}}}}}}}}}}}}},"docs":{}}}}}}}}}}}}}}},"docs":{}}}}}},"docs":{}}}}}},"docs":{}}}}}}},"docs":{}}},"docs":{}}}},"docs":{}}}},"docs":{}}}}}}}}}}},"docs":{}}},"docs":{}}}},"docs":{}}}}},"/":{"docs":{},"i":{"docs":{},"t":{"docs":{},"e":{"docs":{},"m":{"docs":{},"s":{"docs":{},"{":{"docs":{},"i":{"docs":{},"d":{"docs":{},"}":{"docs":{},"'":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}}}}}}}}}}}}},">":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542},"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"[":{"1":{"docs":{},"b":{"5":{"8":{"7":{"9":{"docs":{},"d":{"6":{"8":{"3":{"8":{"1":{"9":{"docs":{},"f":{"2":{"docs":{},"a":{"6":{"2":{"3":{"0":{"4":{"9":{"docs":{},"e":{"9":{"docs":{},"d":{"0":{"docs":{},"e":{"4":{"docs":{},"b":{"docs":{},"d":{"9":{"5":{"4":{"docs":{},"d":{"9":{"docs":{},"f":{"2":{"2":{"8":{"docs":{},"d":{"docs":{},"a":{"0":{"0":{"0":{"docs":{},"d":{"2":{"7":{"7":{"4":{"docs":{},"f":{"5":{"8":{"6":{"5":{"2":{"docs":{},"a":{"docs":{},"f":{"1":{"docs":{},"f":{"3":{"docs":{},"c":{"8":{"8":{"2":{"docs":{},"]":{"docs":{},"…":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"docs":{}},"docs":{}},"docs":{}}},"docs":{}}},"docs":{}}}},"docs":{}},"docs":{}},"docs":{}},"docs":{}},"docs":{}}},"docs":{}},"docs":{}},"docs":{}},"docs":{}}},"docs":{}},"docs":{}},"docs":{}}}},"docs":{}},"docs":{}},"docs":{}}},"docs":{}}},"docs":{}},"docs":{}},"docs":{}}}},"docs":{}}},"docs":{}}},"docs":{}}},"docs":{}},"docs":{}},"docs":{}},"docs":{}},"docs":{}},"docs":{}}},"docs":{}}},"docs":{}},"docs":{}},"docs":{}},"docs":{}},"docs":{}},"docs":{}}},"docs":{}},"docs":{}},"docs":{}},"docs":{}}},"8":{"docs":{},"e":{"docs":{},"e":{"8":{"9":{"7":{"1":{"1":{"3":{"3":{"0":{"docs":{},"c":{"1":{"docs":{},"c":{"docs":{},"c":{"docs":{},"f":{"3":{"9":{"docs":{},"a":{"2":{"docs":{},"e":{"6":{"5":{"docs":{},"a":{"docs":{},"d":{"1":{"2":{"docs":{},"b":{"docs":{},"b":{"docs":{},"d":{"7":{"docs":{},"d":{"docs":{},"f":{"4":{"docs":{},"a":{"4":{"docs":{},"a":{"2":{"docs":{},"e":{"docs":{},"e":{"8":{"5":{"7":{"docs":{},"f":{"5":{"3":{"docs":{},"b":{"4":{"8":{"2":{"3":{"docs":{},"f":{"0":{"0":{"docs":{},"f":{"docs":{},"e":{"docs":{},"c":{"docs":{},"b":{"7":{"docs":{},"b":{"docs":{},"d":{"2":{"5":{"2":{"docs":{},"]":{"docs":{},"…":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"docs":{}},"docs":{}},"docs":{}}}},"docs":{}}}}}},"docs":{}},"docs":{}}},"docs":{}},"docs":{}},"docs":{}},"docs":{}}},"docs":{}},"docs":{}}},"docs":{}},"docs":{}},"docs":{}}}},"docs":{}}},"docs":{}}},"docs":{}}}},"docs":{}}}}},"docs":{}},"docs":{}}}},"docs":{}},"docs":{}}},"docs":{}}},"docs":{}},"docs":{}}}}},"docs":{}}},"docs":{}},"docs":{}},"docs":{}},"docs":{}},"docs":{}},"docs":{}},"docs":{}},"docs":{}}}},"docs":{},"]":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542},"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"a":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"u":{"docs":{},"d":{"docs":{},"i":{"docs":{},"t":{"docs":{},"]":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.015267175572519083}}}}}}},"c":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{},".":{"docs":{},"p":{"docs":{},"r":{"docs":{},"i":{"docs":{},"v":{"docs":{},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"u":{"docs":{},"b":{"docs":{},"l":{"docs":{},"i":{"docs":{},"c":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"s":{"docs":{},"e":{"docs":{},"e":{"docs":{},"d":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"!":{"docs":{},"!":{"docs":{},"!":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"c":{"docs":{},"o":{"docs":{},"m":{"docs":{},"m":{"docs":{},"i":{"docs":{},"t":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}}}}}}}},"n":{"docs":{},"f":{"docs":{},"i":{"docs":{},"g":{"docs":{},".":{"docs":{},"@":{"docs":{},"d":{"docs":{},"a":{"docs":{},"t":{"docs":{},"a":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"l":{"docs":{},"i":{"docs":{},"s":{"docs":{},"t":{"docs":{},"e":{"docs":{},"n":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"n":{"docs":{},"e":{"docs":{},"t":{"docs":{},"w":{"docs":{},"o":{"docs":{},"r":{"docs":{},"k":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}},"p":{"docs":{},"e":{"docs":{},"e":{"docs":{},"r":{"docs":{},"s":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"o":{"docs":{},"r":{"docs":{},"t":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"u":{"docs":{},"p":{"docs":{},"n":{"docs":{},"p":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"u":{"docs":{},"r":{"docs":{},"a":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}},"a":{"docs":{},"p":{"docs":{},"a":{"docs":{},"b":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}}},"i":{"docs":{},"t":{"docs":{},"a":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0035335689045936395}}}},"e":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0021201413427561835}}}}}}},"d":{"docs":{},"a":{"docs":{},"t":{"docs":{},"a":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"e":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.0024615384615384616}}}}}}}}}}}}}},"i":{"docs":{},"n":{"docs":{},"f":{"docs":{},"o":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231}}}}}}}},"j":{"docs":{},"s":{"docs":{},"o":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"l":{"docs":{},"i":{"docs":{},"s":{"docs":{},"t":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"a":{"docs":{},"b":{"docs":{},"e":{"docs":{},"l":{"docs":{},"=":{"docs":{},"\"":{"1":{"0":{"0":{"0":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"docs":{}},"docs":{}},"docs":{}},"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643}}}}}}}}},"m":{"docs":{},"a":{"docs":{},"p":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}}}}}}},"n":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"s":{"docs":{},".":{"docs":{},"a":{"docs":{},"l":{"docs":{},"g":{"docs":{},"o":{"docs":{},"r":{"docs":{},"i":{"docs":{},"t":{"docs":{},"h":{"docs":{},"m":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"c":{"docs":{},"u":{"docs":{},"r":{"docs":{},"r":{"docs":{},"e":{"docs":{},"n":{"docs":{},"c":{"docs":{},"i":{"docs":{},"e":{"docs":{},"s":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}},"f":{"docs":{},"u":{"docs":{},"l":{"docs":{},"l":{"docs":{},"n":{"docs":{},"o":{"docs":{},"d":{"docs":{},"e":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{},".":{"docs":{},"s":{"docs":{},"e":{"docs":{},"e":{"docs":{},"d":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"n":{"docs":{},"e":{"docs":{},"t":{"docs":{},"w":{"docs":{},"o":{"docs":{},"r":{"docs":{},"k":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}}}}}}}}},"o":{"docs":{},"d":{"docs":{},"e":{"docs":{},"s":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"p":{"docs":{},"r":{"docs":{},"i":{"docs":{},"v":{"docs":{},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"o":{"docs":{},"v":{"docs":{},"i":{"docs":{},"d":{"docs":{},"e":{"docs":{},"r":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"u":{"docs":{},"b":{"docs":{},"l":{"docs":{},"i":{"docs":{},"c":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"s":{"docs":{},"a":{"docs":{},"l":{"docs":{},"t":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"e":{"docs":{},"e":{"docs":{},"d":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"s":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"v":{"docs":{},"e":{"docs":{},"r":{"docs":{},"b":{"docs":{},"o":{"docs":{},"s":{"docs":{},"i":{"docs":{},"t":{"docs":{},"y":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.0013846153846153845}}}}}}}}}},"i":{"docs":{},"z":{"docs":{},"e":{"docs":{},"]":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}},"?":{"docs":{},"?":{"docs":{},"?":{"docs":{},"]":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"b":{"docs":{},"i":{"docs":{},"t":{"docs":{},"c":{"docs":{},"o":{"docs":{},"i":{"docs":{},"n":{"docs":{},"]":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}},"g":{"docs":{},"r":{"docs":{},"a":{"docs":{},"y":{"7":{"8":{"docs":{},"]":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"docs":{}},"docs":{}}}}},"z":{"docs":{},"e":{"docs":{},"r":{"docs":{},"o":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542},"API.html":{"ref":"API.html","tf":0.008},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"s":{"docs":{},":":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"[":{"docs":{},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"s":{"docs":{},"]":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}},"{":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0013846153846153845}}},"p":{"docs":{},"a":{"docs":{},"i":{"docs":{},"r":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"r":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"e":{"docs":{},"p":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"i":{"docs":{},"n":{"docs":{},"d":{"docs":{},":":{"docs":{"API.html":{"ref":"API.html","tf":0.038}}}}}},"n":{"docs":{},"o":{"docs":{},"w":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"l":{"docs":{},"e":{"docs":{},"d":{"docs":{},"g":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643}},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.003952569169960474},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0049469964664310955}}}}}},"a":{"docs":{},"y":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"q":{"docs":{},"u":{"docs":{},"i":{"docs":{},"c":{"docs":{},"k":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":3.333333333333333},"SERVICES.html":{"ref":"SERVICES.html","tf":0.025}},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{"QUICKSTART.html":{"ref":"QUICKSTART.html","tf":0.007633587786259542}}}}}}},"l":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"a":{"docs":{},"d":{"docs":{},"r":{"docs":{},"a":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"i":{"docs":{},"c":{"docs":{},",":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"n":{"docs":{},"t":{"docs":{},"i":{"docs":{},"t":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"o":{"docs":{},"r":{"docs":{},"u":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"\"":{"docs":{},"b":{"docs":{},"i":{"docs":{},"t":{"docs":{},"c":{"docs":{},"o":{"docs":{},"i":{"docs":{},"n":{"docs":{},"\"":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"s":{"docs":{},"\"":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}}}}}}}},"l":{"docs":{},"o":{"docs":{},"c":{"docs":{},"k":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"\"":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"c":{"docs":{},"h":{"docs":{},"a":{"docs":{},"i":{"docs":{},"n":{"docs":{},"\"":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"s":{"docs":{},"\"":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}},"c":{"docs":{},"h":{"docs":{},"a":{"docs":{},"i":{"docs":{},"n":{"docs":{},"c":{"docs":{},"o":{"docs":{},"d":{"docs":{},"e":{"docs":{},"\"":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}},"a":{"docs":{},"r":{"docs":{},"r":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"o":{"docs":{},"m":{"docs":{},"m":{"docs":{},"i":{"docs":{},"t":{"docs":{},"\"":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"n":{"docs":{},"v":{"docs":{},"e":{"docs":{},"r":{"docs":{},"g":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"f":{"docs":{},"u":{"docs":{},"l":{"docs":{},"f":{"docs":{},"i":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}},"z":{"docs":{},"z":{"docs":{},"c":{"docs":{},"h":{"docs":{},"a":{"docs":{},"i":{"docs":{},"n":{"docs":{},"\"":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"y":{"docs":{},"\"":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"a":{"docs":{},"i":{"docs":{},"l":{"docs":{},"o":{"docs":{},"v":{"docs":{},"e":{"docs":{},"r":{"docs":{},"\"":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}},"g":{"docs":{},"e":{"docs":{},"n":{"docs":{},"e":{"docs":{},"s":{"docs":{},"i":{"docs":{},"s":{"docs":{},"\"":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"i":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"i":{"docs":{},"t":{"docs":{},"i":{"docs":{},"a":{"docs":{},"l":{"docs":{},"i":{"docs":{},"z":{"docs":{},"a":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"\"":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}},"f":{"docs":{},"o":{"docs":{},"r":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{},"\"":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"l":{"docs":{},"o":{"docs":{},"c":{"docs":{},"a":{"docs":{},"l":{"docs":{},"h":{"docs":{},"o":{"docs":{},"s":{"docs":{},"t":{"docs":{},"\"":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"i":{"docs":{},"n":{"docs":{},"k":{"docs":{},"e":{"docs":{},"d":{"docs":{},"\"":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"m":{"docs":{},"a":{"docs":{},"p":{"docs":{},"\"":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"p":{"docs":{},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{},"e":{"docs":{},"\"":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"b":{"docs":{},"e":{"docs":{},"\"":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"e":{"docs":{},"r":{"docs":{},"v":{"docs":{},"i":{"docs":{},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"e":{"docs":{},"\"":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}},"t":{"docs":{},"t":{"docs":{},"l":{"docs":{},"e":{"docs":{},"\"":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"t":{"docs":{},"e":{"docs":{},"p":{"docs":{},"\"":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"y":{"docs":{},"m":{"docs":{},"b":{"docs":{},"o":{"docs":{},"l":{"docs":{},"\"":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"h":{"docs":{},"e":{"docs":{},"l":{"docs":{},"l":{"docs":{},"\"":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"p":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{},"\"":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}},"t":{"docs":{},"h":{"docs":{},"r":{"docs":{},"e":{"docs":{},"a":{"docs":{},"d":{"docs":{},"s":{"docs":{},"\"":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}},"y":{"docs":{},"p":{"docs":{},"e":{"docs":{},"\"":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"r":{"docs":{},"a":{"docs":{},"n":{"docs":{},"s":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"s":{"docs":{},"\"":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}}}}}},"u":{"docs":{},"s":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"t":{"docs":{},"h":{"docs":{},"\"":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"v":{"docs":{},"a":{"docs":{},"l":{"docs":{},"u":{"docs":{},"e":{"docs":{},"\"":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"/":{"docs":{},"a":{"docs":{},"s":{"docs":{},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"s":{"docs":{},"\"":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}}}}},"i":{"docs":{},"n":{"docs":{},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"n":{"docs":{},"c":{"docs":{},"e":{"docs":{},"s":{"docs":{},"\"":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}}}}}}}}}},"t":{"docs":{},"e":{"docs":{},"m":{"docs":{},"s":{"docs":{},"\"":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915}}}}}}}},"p":{"docs":{},"l":{"docs":{},"a":{"docs":{},"y":{"docs":{},"e":{"docs":{},"r":{"docs":{},"s":{"docs":{},"\"":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}}}}}}}}},"t":{"docs":{},"r":{"docs":{},"a":{"docs":{},"n":{"docs":{},"s":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"s":{"docs":{},"\"":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}}}}}}}}}}}}}},"u":{"docs":{},"s":{"docs":{},"e":{"docs":{},"r":{"docs":{},"s":{"docs":{},"\"":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}}}}}}}},"a":{"docs":{},"r":{"docs":{},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"t":{"docs":{},"o":{"docs":{},"m":{"docs":{},"i":{"docs":{},"c":{"docs":{},"\"":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"d":{"docs":{},"u":{"docs":{},"p":{"docs":{},"l":{"docs":{},"e":{"docs":{},"x":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"e":{"docs":{},"n":{"docs":{},"i":{"docs":{},"g":{"docs":{},"m":{"docs":{},"a":{"docs":{},":":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"h":{"docs":{},"o":{"docs":{},"m":{"docs":{},"o":{"docs":{},"m":{"docs":{},"o":{"docs":{},"r":{"docs":{},"p":{"docs":{},"h":{"docs":{},"i":{"docs":{},"c":{"docs":{},"\"":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}}}}},"o":{"docs":{},"f":{"docs":{},"f":{"docs":{},"l":{"docs":{},"i":{"docs":{},"n":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"p":{"docs":{},"c":{"docs":{},"o":{"docs":{},"d":{"docs":{},"e":{"docs":{},"s":{"docs":{},"\"":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}},"p":{"docs":{},"a":{"docs":{},"g":{"docs":{},"e":{"docs":{},"\"":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"e":{"docs":{},"r":{"docs":{},"s":{"docs":{},"p":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{},"i":{"docs":{},"v":{"docs":{},"e":{"docs":{},"\"":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}}}},"r":{"docs":{},"o":{"docs":{},"o":{"docs":{},"f":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}},"u":{"docs":{},"r":{"docs":{},"i":{"docs":{},"t":{"docs":{},"y":{"docs":{},"\"":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"q":{"docs":{},"u":{"docs":{},"e":{"docs":{},"s":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"w":{"docs":{},"o":{"docs":{},"r":{"docs":{},"k":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"z":{"docs":{},"e":{"docs":{},"r":{"docs":{},"o":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}},"$":{"docs":{},"b":{"docs":{},"t":{"docs":{},"c":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}},"*":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}},"i":{"docs":{},"n":{"docs":{},"s":{"docs":{},"p":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0016469038208168643}},".":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915}},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}},"_":{"docs":{},"c":{"docs":{},"o":{"docs":{},"n":{"docs":{},"n":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{},"s":{"docs":{},"p":{"docs":{},"v":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},"c":{"docs":{},"r":{"docs":{},"o":{"docs":{},"w":{"docs":{},"d":{"docs":{},"f":{"docs":{},"u":{"docs":{},"n":{"docs":{},"d":{"docs":{},"(":{"docs":{},"f":{"docs":{},"u":{"docs":{},"n":{"docs":{},"d":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}}}},"d":{"docs":{},"e":{"docs":{},"f":{"docs":{},"i":{"docs":{},"n":{"docs":{},"e":{"docs":{},"(":{"docs":{},"d":{"docs":{},"i":{"docs":{},"r":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"l":{"docs":{},"e":{"docs":{},"t":{"docs":{},"e":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}},"o":{"docs":{},"w":{"docs":{},"n":{"docs":{},"s":{"docs":{},"a":{"docs":{},"m":{"docs":{},"p":{"docs":{},"l":{"docs":{},"e":{"docs":{},"(":{"docs":{},"[":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},"]":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}},"e":{"docs":{},"x":{"docs":{},"p":{"docs":{},"l":{"docs":{},"o":{"docs":{},"r":{"docs":{},"e":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}},"f":{"docs":{},"r":{"docs":{},"o":{"docs":{},"m":{"docs":{},"j":{"docs":{},"a":{"docs":{},"v":{"docs":{},"a":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{},"(":{"docs":{},"b":{"docs":{},"o":{"docs":{},"d":{"docs":{},"y":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}}},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"j":{"docs":{},"a":{"docs":{},"v":{"docs":{},"a":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{},"a":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"f":{"docs":{},"u":{"docs":{},"n":{"docs":{},"d":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{},"(":{"docs":{},"r":{"docs":{},"e":{"docs":{},"d":{"docs":{},"e":{"docs":{},"e":{"docs":{},"m":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"w":{"docs":{},"a":{"docs":{},"p":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{},"(":{"docs":{},"r":{"docs":{},"e":{"docs":{},"d":{"docs":{},"e":{"docs":{},"e":{"docs":{},"m":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"h":{"docs":{},"a":{"docs":{},"n":{"docs":{},"d":{"docs":{},"l":{"docs":{},"e":{"docs":{},"b":{"docs":{},"l":{"docs":{},"o":{"docs":{},"c":{"docs":{},"k":{"docs":{},"f":{"docs":{},"r":{"docs":{},"o":{"docs":{},"m":{"docs":{},"s":{"docs":{},"p":{"docs":{},"v":{"docs":{},"(":{"docs":{},"m":{"docs":{},"s":{"docs":{},"g":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}}}}}}}},"c":{"docs":{},"o":{"docs":{},"m":{"docs":{},"m":{"docs":{},"i":{"docs":{},"t":{"docs":{},"t":{"docs":{},"e":{"docs":{},"d":{"docs":{},"b":{"docs":{},"l":{"docs":{},"o":{"docs":{},"c":{"docs":{},"k":{"docs":{},"(":{"docs":{},"b":{"docs":{},"l":{"docs":{},"o":{"docs":{},"c":{"docs":{},"k":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}}}}}}}}}}}},"p":{"docs":{},"e":{"docs":{},"e":{"docs":{},"r":{"docs":{},"p":{"docs":{},"a":{"docs":{},"c":{"docs":{},"k":{"docs":{},"e":{"docs":{},"t":{"docs":{},"(":{"docs":{},"m":{"docs":{},"s":{"docs":{},"g":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}}}}}},"t":{"docs":{},"r":{"docs":{},"a":{"docs":{},"n":{"docs":{},"s":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"f":{"docs":{},"r":{"docs":{},"o":{"docs":{},"m":{"docs":{},"s":{"docs":{},"p":{"docs":{},"v":{"docs":{},"(":{"docs":{},"t":{"docs":{},"x":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"l":{"docs":{},"o":{"docs":{},"a":{"docs":{},"d":{"docs":{},"(":{"docs":{},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{},"t":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"s":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}},"o":{"docs":{},"p":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"s":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"c":{"docs":{},"h":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}},"o":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"p":{"docs":{},"a":{"docs":{},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"r":{"docs":{},"a":{"docs":{},"n":{"docs":{},"s":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"(":{"docs":{},"o":{"docs":{},"b":{"docs":{},"j":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}}}}}}}}}}}}},"u":{"docs":{},"t":{"docs":{},"(":{"docs":{},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"g":{"docs":{},"i":{"docs":{},"s":{"docs":{},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{},"(":{"docs":{},"o":{"docs":{},"b":{"docs":{},"j":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{},"(":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{},"(":{"docs":{},"m":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},"a":{"docs":{},"g":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}},"r":{"docs":{},"i":{"docs":{},"a":{"docs":{},"l":{"docs":{},"i":{"docs":{},"z":{"docs":{},"e":{"docs":{},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}},"t":{"docs":{},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{},"(":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}},"i":{"docs":{},"g":{"docs":{},"n":{"docs":{},"(":{"docs":{},"t":{"docs":{},"x":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"u":{"docs":{},"b":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"b":{"docs":{},"e":{"docs":{},"t":{"docs":{},"o":{"docs":{},"s":{"docs":{},"h":{"docs":{},"a":{"docs":{},"r":{"docs":{},"d":{"docs":{},"(":{"docs":{},"s":{"docs":{},"h":{"docs":{},"a":{"docs":{},"r":{"docs":{},"d":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}}}}}}}}}}}}}}},"a":{"docs":{},"d":{"docs":{},"d":{"docs":{},"(":{"docs":{},"a":{"docs":{},"m":{"docs":{},"o":{"docs":{},"u":{"docs":{},"n":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"p":{"docs":{},"p":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{},"(":{"docs":{},"i":{"docs":{},"t":{"docs":{},"e":{"docs":{},"m":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}},"s":{"docs":{},"m":{"docs":{},"e":{"docs":{},"r":{"docs":{},"k":{"docs":{},"l":{"docs":{},"e":{"docs":{},"t":{"docs":{},"r":{"docs":{},"e":{"docs":{},"e":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}},"r":{"docs":{},"a":{"docs":{},"w":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"t":{"docs":{},"t":{"docs":{},"a":{"docs":{},"c":{"docs":{},"h":{"docs":{},"(":{"docs":{},"e":{"docs":{},"l":{"docs":{},"e":{"docs":{},"m":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}},"b":{"docs":{},"r":{"docs":{},"o":{"docs":{},"a":{"docs":{},"d":{"docs":{},"c":{"docs":{},"a":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},"m":{"docs":{},"s":{"docs":{},"g":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}},"c":{"docs":{},"o":{"docs":{},"m":{"docs":{},"m":{"docs":{},"i":{"docs":{},"t":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231}}}}}}},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},"e":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}}},"n":{"docs":{},"n":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{},"(":{"docs":{},"a":{"docs":{},"d":{"docs":{},"d":{"docs":{},"r":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}},"n":{"docs":{},"o":{"docs":{},"t":{"docs":{},"i":{"docs":{},"f":{"docs":{},"y":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}}},"s":{"docs":{},"u":{"docs":{},"m":{"docs":{},"e":{"docs":{},"(":{"docs":{},"r":{"docs":{},"e":{"docs":{},"s":{"docs":{},"o":{"docs":{},"u":{"docs":{},"r":{"docs":{},"c":{"docs":{},"e":{"docs":{},"s":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},"(":{"docs":{},"e":{"docs":{},"n":{"docs":{},"t":{"docs":{},"i":{"docs":{},"t":{"docs":{},"y":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"o":{"docs":{},"b":{"docs":{},"j":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"p":{"docs":{},"r":{"docs":{},"i":{"docs":{},"c":{"docs":{},"e":{"docs":{},"d":{"docs":{},"o":{"docs":{},"r":{"docs":{},"d":{"docs":{},"e":{"docs":{},"r":{"docs":{},"(":{"docs":{},"o":{"docs":{},"r":{"docs":{},"d":{"docs":{},"e":{"docs":{},"r":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}}}}}},"y":{"docs":{},"c":{"docs":{},"l":{"docs":{},"e":{"docs":{},"(":{"docs":{},"v":{"docs":{},"a":{"docs":{},"l":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"d":{"docs":{},"e":{"docs":{},"f":{"docs":{},"e":{"docs":{},"r":{"docs":{},"(":{"docs":{},"a":{"docs":{},"u":{"docs":{},"t":{"docs":{},"h":{"docs":{},"o":{"docs":{},"r":{"docs":{},"i":{"docs":{},"t":{"docs":{},"y":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}},"i":{"docs":{},"n":{"docs":{},"e":{"docs":{},"(":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{},"e":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"l":{"docs":{},"(":{"docs":{},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}},"r":{"docs":{},"i":{"docs":{},"v":{"docs":{},"e":{"docs":{},"(":{"docs":{},"[":{"docs":{},"i":{"docs":{},"n":{"docs":{},"f":{"docs":{},"o":{"docs":{},"]":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}},"s":{"docs":{},"e":{"docs":{},"r":{"docs":{},"i":{"docs":{},"a":{"docs":{},"l":{"docs":{},"i":{"docs":{},"z":{"docs":{},"e":{"docs":{},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}}}}}}}}}}}}}}}}}}},"i":{"docs":{},"g":{"docs":{},"e":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}},"e":{"docs":{},"n":{"docs":{},"u":{"docs":{},"m":{"docs":{},"e":{"docs":{},"r":{"docs":{},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"v":{"docs":{},"e":{"docs":{},"l":{"docs":{},"o":{"docs":{},"p":{"docs":{},"(":{"docs":{},"s":{"docs":{},"e":{"docs":{},"l":{"docs":{},"e":{"docs":{},"c":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}},"x":{"docs":{},"t":{"docs":{},"r":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{},"s":{"docs":{},"e":{"docs":{},"c":{"docs":{},"r":{"docs":{},"e":{"docs":{},"t":{"docs":{},"(":{"docs":{},"t":{"docs":{},"x":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}},"f":{"docs":{},"i":{"docs":{},"n":{"docs":{},"d":{"docs":{},"b":{"docs":{},"y":{"docs":{},"f":{"docs":{},"i":{"docs":{},"e":{"docs":{},"l":{"docs":{},"d":{"docs":{},"(":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{},"e":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{},"e":{"docs":{},"(":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"s":{"docs":{},"y":{"docs":{},"m":{"docs":{},"b":{"docs":{},"o":{"docs":{},"l":{"docs":{},"(":{"docs":{},"s":{"docs":{},"y":{"docs":{},"m":{"docs":{},"b":{"docs":{},"o":{"docs":{},"l":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}},"l":{"docs":{},"u":{"docs":{},"s":{"docs":{},"h":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}},"o":{"docs":{},"r":{"docs":{},"k":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}}}}}}},"r":{"docs":{},"o":{"docs":{},"m":{"docs":{},"j":{"docs":{},"s":{"docs":{},"o":{"docs":{},"n":{"docs":{},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}},"u":{"docs":{},"n":{"docs":{},"d":{"docs":{},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}},"g":{"docs":{},"e":{"docs":{},"t":{"docs":{},"(":{"docs":{},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231}}}}}}}},"a":{"docs":{},"d":{"docs":{},"d":{"docs":{},"r":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},"f":{"docs":{},"o":{"docs":{},"r":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{},"(":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}},"r":{"docs":{},"o":{"docs":{},"m":{"docs":{},"r":{"docs":{},"e":{"docs":{},"d":{"docs":{},"e":{"docs":{},"e":{"docs":{},"m":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{},"(":{"docs":{},"r":{"docs":{},"e":{"docs":{},"d":{"docs":{},"e":{"docs":{},"e":{"docs":{},"m":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"p":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"b":{"docs":{},"y":{"docs":{},"i":{"docs":{},"d":{"docs":{},"(":{"docs":{},"i":{"docs":{},"d":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"l":{"docs":{},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}},"h":{"docs":{},"a":{"docs":{},"n":{"docs":{},"d":{"docs":{},"l":{"docs":{},"e":{"docs":{},"r":{"docs":{},"(":{"docs":{},"m":{"docs":{},"e":{"docs":{},"s":{"docs":{},"s":{"docs":{},"a":{"docs":{},"g":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}}}}}},"e":{"docs":{},"i":{"docs":{},"g":{"docs":{},"h":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}},"i":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}}},"m":{"docs":{},"p":{"docs":{},"o":{"docs":{},"r":{"docs":{},"t":{"docs":{},"(":{"docs":{},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}},"n":{"docs":{},"h":{"docs":{},"e":{"docs":{},"r":{"docs":{},"i":{"docs":{},"t":{"docs":{},"s":{"docs":{},"(":{"docs":{},"s":{"docs":{},"c":{"docs":{},"r":{"docs":{},"i":{"docs":{},"b":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0006153846153846154}}}}}}}}}}}}}}}}},"s":{"docs":{},"v":{"docs":{},"a":{"docs":{},"l":{"docs":{},"i":{"docs":{},"d":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"l":{"docs":{},"i":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"e":{"docs":{},"n":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"o":{"docs":{},"g":{"docs":{},"(":{"docs":{},".":{"docs":{},".":{"docs":{},".":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},"s":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}},"m":{"docs":{},"a":{"docs":{},"p":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"u":{"docs":{},"t":{"docs":{},"a":{"docs":{},"b":{"docs":{},"l":{"docs":{},"e":{"docs":{},"t":{"docs":{},"r":{"docs":{},"a":{"docs":{},"n":{"docs":{},"s":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}}}}}},"n":{"docs":{},"o":{"docs":{},"w":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}}}}}}},"o":{"docs":{},"p":{"docs":{},"e":{"docs":{},"n":{"docs":{},"(":{"docs":{},"c":{"docs":{},"h":{"docs":{},"a":{"docs":{},"n":{"docs":{},"n":{"docs":{},"e":{"docs":{},"l":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}},"p":{"docs":{},"u":{"docs":{},"b":{"docs":{},"l":{"docs":{},"i":{"docs":{},"c":{"docs":{},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{},"f":{"docs":{},"r":{"docs":{},"o":{"docs":{},"m":{"docs":{},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"h":{"docs":{},"(":{"docs":{},"d":{"docs":{},"a":{"docs":{},"t":{"docs":{},"a":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}},"v":{"docs":{},"a":{"docs":{},"l":{"docs":{},"u":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}},"r":{"docs":{},"e":{"docs":{},"g":{"docs":{},"i":{"docs":{},"s":{"docs":{},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{},"(":{"docs":{},"s":{"docs":{},"e":{"docs":{},"r":{"docs":{},"v":{"docs":{},"i":{"docs":{},"c":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}}}},"n":{"docs":{},"d":{"docs":{},"e":{"docs":{},"r":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}}}}}}}},"v":{"docs":{},"e":{"docs":{},"r":{"docs":{},"s":{"docs":{},"e":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"o":{"docs":{},"u":{"docs":{},"t":{"docs":{},"e":{"docs":{},"(":{"docs":{},"m":{"docs":{},"s":{"docs":{},"g":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00046153846153846153}}}}}}}}}}}},"s":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{},"(":{"docs":{},"c":{"docs":{},"h":{"docs":{},"a":{"docs":{},"n":{"docs":{},"n":{"docs":{},"e":{"docs":{},"l":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}}}}},"r":{"docs":{},"i":{"docs":{},"a":{"docs":{},"l":{"docs":{},"i":{"docs":{},"z":{"docs":{},"e":{"docs":{},"(":{"docs":{},"[":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},"]":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}}}}}}}}}}}}}}}}}},"t":{"docs":{},"(":{"docs":{},"k":{"docs":{},"e":{"docs":{},"y":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}},"p":{"docs":{},"a":{"docs":{},"t":{"docs":{},"h":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0009230769230769231}}}}}}}}}},"i":{"docs":{},"g":{"docs":{},"n":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}},"p":{"docs":{},"(":{"docs":{},"[":{"docs":{},"n":{"docs":{},"]":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.002}}}}}},"t":{"docs":{},"e":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}},"o":{"docs":{},"p":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0012307692307692308}}}}}}}},"t":{"docs":{},"i":{"docs":{},"c":{"docs":{},"k":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}},"p":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}},"o":{"docs":{},"b":{"docs":{},"u":{"docs":{},"f":{"docs":{},"f":{"docs":{},"e":{"docs":{},"r":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}},"j":{"docs":{},"s":{"docs":{},"o":{"docs":{},"n":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}},"r":{"docs":{},"a":{"docs":{},"w":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{},"i":{"docs":{},"n":{"docs":{},"g":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0007692307692307692}}},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}},"t":{"docs":{},"y":{"docs":{},"p":{"docs":{},"e":{"docs":{},"d":{"docs":{},"a":{"docs":{},"r":{"docs":{},"r":{"docs":{},"a":{"docs":{},"y":{"docs":{},"(":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}},"r":{"docs":{},"a":{"docs":{},"n":{"docs":{},"s":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}},"u":{"docs":{},"s":{"docs":{},"t":{"docs":{},"(":{"docs":{},"s":{"docs":{},"o":{"docs":{},"u":{"docs":{},"r":{"docs":{},"c":{"docs":{},"e":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.0012307692307692308}}}}}}}}}}}}}}},"u":{"docs":{},"a":{"docs":{},"s":{"docs":{},"t":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}},"p":{"docs":{},"d":{"docs":{},"a":{"docs":{},"t":{"docs":{},"e":{"docs":{},"(":{"docs":{},"i":{"docs":{},"d":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}},"s":{"docs":{},"e":{"docs":{},"(":{"docs":{},"n":{"docs":{},"a":{"docs":{},"m":{"docs":{},"e":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}},"p":{"docs":{},"l":{"docs":{},"u":{"docs":{},"g":{"docs":{},"i":{"docs":{},"n":{"docs":{},",":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}},"v":{"docs":{},"a":{"docs":{},"l":{"docs":{},"u":{"docs":{},"e":{"docs":{},"(":{"docs":{},"i":{"docs":{},"n":{"docs":{},"p":{"docs":{},"u":{"docs":{},"t":{"docs":{},")":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}},":":{"docs":{"API.html":{"ref":"API.html","tf":0.0047692307692307695}}},"\\":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}},"_":{"docs":{},"r":{"docs":{},"e":{"docs":{},"g":{"docs":{},"i":{"docs":{},"s":{"docs":{},"t":{"docs":{},"e":{"docs":{},"r":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{},"o":{"docs":{},"r":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}}}}},"s":{"docs":{},"e":{"docs":{},"n":{"docs":{},"d":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}},"r":{"docs":{},"i":{"docs":{},"a":{"docs":{},"l":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}},"i":{"docs":{},"z":{"docs":{},"e":{"docs":{},".":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385}}}}}}}}}}}},"t":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"x":{"docs":{"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}},"~":{"docs":{},"b":{"docs":{},"i":{"docs":{},"t":{"docs":{},"c":{"docs":{},"o":{"docs":{},"i":{"docs":{},"n":{"docs":{"API.html":{"ref":"API.html","tf":0.0003076923076923077}}}}}}}}}},"—":{"docs":{"API.html":{"ref":"API.html","tf":0.00015384615384615385},"whitepaper.html":{"ref":"whitepaper.html","tf":0.00230566534914361}}},"⇐":{"docs":{"API.html":{"ref":"API.html","tf":0.004153846153846154}}},"⇒":{"docs":{"API.html":{"ref":"API.html","tf":0.038461538461538464},"whitepaper.html":{"ref":"whitepaper.html","tf":0.005270092226613966}}},"☕":{"docs":{"DEVELOPERS.html":{"ref":"DEVELOPERS.html","tf":0.00980392156862745}}},"\ud83c":{"docs":{},"\udfe6":{"docs":{"SERVICES.html":{"ref":"SERVICES.html","tf":3.333333333333333}}}},"&":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"/":{"docs":{},"/":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.001976284584980237}}},"a":{"docs":{},"s":{"docs":{},"s":{"docs":{},"e":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}}},"i":{"docs":{},"n":{"docs":{},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"n":{"docs":{},"c":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}}}},"t":{"docs":{},"e":{"docs":{},"m":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"s":{"docs":{},"/":{"docs":{},"{":{"docs":{},"i":{"docs":{},"d":{"docs":{},"}":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}}}}}}}}}}},"p":{"docs":{},"l":{"docs":{},"a":{"docs":{},"y":{"docs":{},"e":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}}}},"t":{"docs":{},"r":{"docs":{},"a":{"docs":{},"n":{"docs":{},"s":{"docs":{},"a":{"docs":{},"c":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}}}}}},"u":{"docs":{},"n":{"docs":{},"i":{"docs":{},"v":{"docs":{},"e":{"docs":{},"r":{"docs":{},"s":{"docs":{},"e":{"docs":{},"s":{"docs":{},"/":{"docs":{},"{":{"docs":{},"i":{"docs":{},"d":{"docs":{},"}":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"\"":{"docs":{},"]":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}}}}}}}},"s":{"docs":{},"e":{"docs":{},"r":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}}},"?":{"docs":{},"?":{"docs":{},"?":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0014134275618374558}}}}},"`":{"0":{"docs":{},"`":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}},"docs":{},"a":{"docs":{},"d":{"docs":{},"d":{"docs":{},"`":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"p":{"docs":{},"p":{"docs":{},"l":{"docs":{},"i":{"docs":{},"c":{"docs":{},"a":{"docs":{},"t":{"docs":{},"i":{"docs":{},"o":{"docs":{},"n":{"docs":{},"`":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}}}}}}},"e":{"docs":{},"x":{"docs":{},"a":{"docs":{},"m":{"docs":{},"p":{"docs":{},"l":{"docs":{},"e":{"docs":{},"`":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}}}}}},"s":{"docs":{},"t":{"docs":{},"a":{"docs":{},"r":{"docs":{},"t":{"docs":{},"`":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}}}}},"x":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}},"'":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"a":{"docs":{},"n":{"docs":{},"a":{"docs":{},"d":{"docs":{},"u":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}},"m":{"docs":{},"l":{"docs":{},"h":{"docs":{},"t":{"docs":{},"t":{"docs":{},"p":{"docs":{},"r":{"docs":{},"e":{"docs":{},"q":{"docs":{},"u":{"docs":{},"e":{"docs":{},"s":{"docs":{},"t":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}}}}}}}},"z":{"docs":{},"e":{"docs":{},"r":{"docs":{},"o":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}},"k":{"docs":{},"c":{"docs":{},"p":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"y":{"docs":{},"s":{"docs":{},"k":{"docs":{},"i":{"docs":{},"n":{"docs":{},"d":{"docs":{},",":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}},"|":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0009881422924901185}}},"§":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}},"ƒ":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}},"(":{"docs":{},"x":{"docs":{},")":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}}},"δ":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}},"x":{"docs":{},"'":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287}}}}},"φ":{"0":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}},"1":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}},"2":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}},"3":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0013175230566534915}}},"docs":{},".":{"docs":{},".":{"docs":{},".":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}}}},"–":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}},"’":{"docs":{},"s":{"docs":{},"a":{"docs":{},"n":{"docs":{},"d":{"docs":{},"y":{"docs":{},"’":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"”":{"docs":{},"e":{"docs":{},"f":{"docs":{},"f":{"docs":{},"i":{"docs":{},"c":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}},"p":{"docs":{},"r":{"docs":{},"o":{"docs":{},"t":{"docs":{},"o":{"docs":{},"c":{"docs":{},"o":{"docs":{},"l":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}},"u":{"docs":{},"b":{"docs":{},"l":{"docs":{},"i":{"docs":{},"c":{"docs":{},"l":{"docs":{},"i":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.00032938076416337287},"whitepaper-2015.html":{"ref":"whitepaper-2015.html","tf":0.0007067137809187279}}}}}}}}}}},"⚡":{"docs":{"whitepaper.html":{"ref":"whitepaper.html","tf":0.0006587615283267457}}}},"length":4115},"corpusTokens":["\"/assets\"","\"/instances\"","\"/items\"","\"/players\"","\"/transactions\"","\"/users\"","\"arc","\"atomic\"","\"bitcoin\"","\"bitcoins\",","\"block","\"block\".","\"blockchain\".","\"blocks\",","\"blocks\".","\"carri","\"chaincode\".","\"commit\",","\"comput","\"converg","\"duplex","\"enigma:","\"failover\"","\"fulfil","\"fuzzchain\",","\"fuzzchain\".","\"fuzzy\",","\"genesis\"","\"homomorphic\"","\"in","\"inform","\"initialization\"","\"key\"","\"linked\"","\"localhost\".","\"map\"","\"mpc","\"name\"","\"offlin","\"opcodes\",","\"page\"","\"perspective\"","\"proof","\"purity\".","\"request","\"scribe\"","\"servic","\"service\"","\"settle\"","\"shell\"","\"spend\"","\"step\"","\"symbol\"","\"threads\",","\"transactions\".","\"trust","\"truth\",","\"type\",","\"value\"","\"work","\"zero","#","#1","#learn","$btc","&","'/items{id}'","'1cxabhxmiynpgz2k2gnprxy6bncnkvoegw',","'1l3lyapmhfuhldtsjzw77bsqhzc5esx9qf',","'deadbeef...'","'default',","'main',","'pubkeyhash',","'quick","'wltttuqamtxmrip33glf1bn2js5heswxhehe',","'xpub6cn1n6iwapyrqod4ss9sx4i2flmdz4zswb5nulg6dgcnxmvikaork3kfrihqrqlspintdmvhgj7ff1lmlidcvemf8kphsx51cjbtztcqidu',","(\"commands\")","(\"zkcp\")","(#fabric","()","(...)","(1.00","(100","(2015)","(4096","(===","(a","(a)","(above)","(address:port).","(again,","(all","(and","(arc)","(ast).","(audit)","(block","(cli)","(creator","(debug),","(error),","(fhe)","(fsm)","(hkdf),","(http)","(key","(latest)","(layer","(limit","(max","(message)","(msg)","(none),","(not","(notice),","(operations)","(optional)","(or","(posit","(rfcs).","(rsk,","(satoshis).","(see","(side","(such","(term","(the","(thu","(uniform","(unit","(warning),","(will","(wip)","*","*inspect",".","...","....","...input","._connectspv()","._createcrowdfund(fund)","._define(dir,","._delete(path,","._downsample([input])","._explore(path,","._fromjavascript(body)","._get(path)","._get(path,","._getjavascriptast(input)","._getrefundinputscript(redeemscript)","._getswapinputscript(redeemscript,","._handleblockfromspv(msg)","._handlecommittedblock(block)","._handlepeerpacket(msg)","._handletransactionfromspv(tx)","._load(settings)","._options(path,","._patch(path,","._patchtarget(path,","._post(key,","._post(path,","._preparetransaction(obj)","._put(path,","._register(obj)","._registeractor(actor)","._send(message)","._serialize(input)","._setkey(name)","._sign(tx)","._subscribetoshard(shard)",".add(amount)",".append(item)",".asmerkletree()",".asraw()",".attach(element)",".broadcast(msg)",".commit()",".compute()",".compute(input)",".connect(addr)",".connect(notify)",".consume(resources)",".create(entity)",".create(obj)",".createpricedorder(order)",".cycle(val)",".defer(authority)",".define(name,",".del(key)",".derive([info],",".deserialize(input)",".digest(input)",".enumerate()",".envelop(selector)",".extractsecret(tx,",".findbyfield(name,",".findbyname(name)",".findbysymbol(symbol)",".flush()",".fork()",".fromjson(input)",".fund(input)",".get(key)",".get(path)",".getaddressforscript(script)",".getaddressfromredeemscript(redeemscript)",".getbyid(id)",".getlatest()",".handler(message)",".height",".id",".import(state,",".inherits(scribe)",".isvalid()",".list()",".listen()",".log(...inputs)",".map()",".mutabletransact",".now()",".open(channel)",".publickeyfromstring(input)",".push(data)",".push(value)",".register(service)",".render()",".reverse()",".route(msg)",".send(channel,",".serialize([input])",".set(key,",".set(path)",".sign()",".sip([n])",".start()",".state",".stop()",".tick()",".tip",".tobuffer()",".tojson()",".toraw()",".tostring()",".tostring(input)",".totypedarray()",".transact",".trust(source)",".uastr",".update(id,",".use(name,",".use(plugin,",".value(input)","//","/asset","/instanc","/item","/items/{id}","/player","/transact","/universes/{id}","/universes/{id}\"]","/user","0","0,","0.","0.1.0","0:","1","1)","1)\"","1)\\nto:","1,","1.","1.1.","1.1.1.","1.1.1.1.","1.1.1.2.","1.1.1.3:","1.1.2.","1.2.1:","1.2.2:","1.2.3:","1.2:","1.3.1:","1.3.2:","1.3:","1.4.1:","1.4:","10,","10.1:","100.00","1000","1008","10:","11:","12.16","12:","175","185","196.","1978.","1982.","198~","1999.","1:","2","2)","2)\"","2,","2.0","2.1:","2.2:","2001^[citat","2008","2008,","2009,","2013","2013.","2014.","202.","256","2:","3","3)","3)\"","3.1.1.1:","3.1.1:","3.1:","3.2:","3.3.1:","3.3.2:","3.3.3:","3.3.4:","3.3.5.1:","3.3.5.2:","3.3.5.3:","3.3.5.4.1:","3.3.5.4.2:","3.3.5.4.3:","3.3.5.4.4:","3.3.5.4:","3.3.5:","3.3.6:","3.3:","3.4.4:","3.4.5:","3.4:","30","32","32).","32gb.","3:","4","4:","4gb","5","54th","5869.","5:","6:","7777","7:","8.1","8:","9:",":","=","=>",">","???","@","@buffer","@data","@data.)","@entiti","@fabric/bitcoin","@fabric/cor","@fabric/core/services/bitcoin","@fabric/core/services/bitcoin~bitcoin","@fabric/doorman","@fabric/http","@fabric/lightn","@fabric/matrix","@fabric/soundtrack","@fabricprotocol","@id","@parent","@type","[!!!]","[1b5879d683819f2a623049e9d0e4bd954d9f228da000d2774f58652af1f3c882]…","[8ee89711330c1ccf39a2e65ad12bbd7df4a4a2ee857f53b4823f00fecb7bd252]…","[???]","[]","[a","[actor.private]","[actor.public]","[actor.seed]","[actor]","[audit]","[bitcoin]:","[capabl","[citat","[cite:","[commit]","[commit])","[config.@data]","[config.listen]","[config.networking]","[config.peers]","[config.port]","[config.upnp]","[config]","[configuration]","[data]","[description]","[gray78]","[info]","[input]","[json","[label=\"","[label=\"1000","[list]","[map]","[map])","[n]","[settings.algorithm]","[settings.currencies]","[settings.fullnode]","[settings.key.seed]","[settings.key]","[settings.network]","[settings.nodes]","[settings.private]","[settings.provider]","[settings.public]","[settings.salt]","[settings.seed]","[settings.seeds]","[settings.verbosity]","[settings]","[size]","[size])","[zero","\\","_registeractor","_send","_serial","_serialize.","_t,","_x","`0`","`add`","`application`","`example`","`start`","a:","abil","abov","above,","absolut","abstract","accept","access","accord","account","account:","accountindex:","accountkey:","accumul","accur","achiev","activ","actor","actor();","actor([actor])","actor,","actor.","actor.on('message',","actor.pubkey","actor.sign()","actor.sign().signature;","actor.tobuffer()","actor:',","actors,","acut","ad","add","add.","addit","addition","addr","address","address)","address.","address:port","addresses.","adopt","adoption.","advanc","advantag","adversari","advertis","against","agent","aggreg","aggregate,","agre","agreement","agreements,","ahead","aim","al","al.","alan","alex","algorithm","algorithm.","alic","align","alloc","allow","along","alreadi","altcoin","altern","alternatives,","alway","amount","amp.","analag","anchor","anchor,","and,","andrew","annual","anoth","another.","anothers'","any.","anyth","api","app","app(definition)","app.","app.attach(element)","app.commit()","app.consume(resources)","app.defer(authority)","app.define(name,","app.deserialize(input)","app.envelop(selector)","app.fork()","app.get(path)","app.id","app.inherits(scribe)","app.now()","app.render()","app.serialize([input])","app.set(path)","app.start()","app.stop()","app.tostring()","app.trust(source)","app.use(name,","appear","append","appendix","appli","applic","application'","application.","applications,","applications.","apply.","appoverrides:","appreturns:","approach","arbitrari","arc","arc:","architectur","arrang","array","artifici","assembl","assert","asset,","assign.","assist","assum","assumpt","assur","ast","ast.","asymmetri","async","asynchron","at.","atom","attach","attempt","attent","attribut","audit","author","author'","authority.","automat","avail","averag","await","awar","away","b","b)","b]","back","backdrop","background","balanc","balance.","balances.","bank","bare","barebon","base","basi","basic","basis.","baum'","baum,","bcoin'","bcointx","be","becam","bech32","becom","befor","before.","begin","behavior","behavior,","behavior.","behaviors,","behaviors.","berlin","berner","best","between","beyond","bind","bip24","birth","bit","bitcoin","bitcoin'","bitcoin();","bitcoin([settings])","bitcoin({","bitcoin,","bitcoin._connectspv()","bitcoin._handleblockfromspv(msg)","bitcoin._handlecommittedblock(block)","bitcoin._handlepeerpacket(msg)","bitcoin._handletransactionfromspv(tx)","bitcoin._preparetransaction(obj)","bitcoin._subscribetoshard(shard)","bitcoin.connect(addr)","bitcoin.height","bitcoin.mutabletransact","bitcoin.start()","bitcoin.start();","bitcoin.stop()","bitcoin.tip","bitcoin.transact","bitcoin.uastr","bitcoinaddress","bitcoinscript","bitcoinscript.","bitcointransact","bitcointransaction,","blind","blindli","blob.","block","block.","blockchain","blockchain)","blockchain,","blockchain.","blockmessag","blocks,","blossom","bodi","body)","bond","boolean","both","bound","boundari","brace","broadcast","brows","browser","browser.","btc","btc).","bubbl","buffer","buffer.","bug","build","built","bundl","bundle,","burgeon","buy","buyer","buyer.","byte","bytes).","bytes.","byzantin","c","c.","calcul","call","called,","came","can:","capabl","capac","capit","carri","carsten,","case","cash","cast","catalyst","catalyz","ceas","central","certain","chain","chain(genesis)","chain.","chainabl","chains,","challeng","chang","change.","changeaddress:","changedepth:","changes.","channel","channel'","channel([settings])","channel,","channel.","channel.add(amount)","channel.fund(input)","channel.open(channel)","channels\".","charli","check","child","choos","circuit","circuits.","citat","claim","class","class.","classemits:","classextends:","classproperti","claudio","clear","clever","cli","cli([settings])","cli.","cli.start()","cli.stop()","client","client,","client.","clock","clock,","clone","close","closure.","cluster_anchor","cluster_arc","cluster_mpc","code","code,","code.","code:","coffe","cohen,","coin","collabor","collaps","collect","collection'","collection([configuration])","collection.","collection._patchtarget(path,","collection._setkey(name)","collection.asmerkletree()","collection.create(entity)","collection.findbyfield(name,","collection.findbyname(name)","collection.findbysymbol(symbol)","collection.get(path)","collection.getbyid(id)","collection.getlatest()","collection.import(state,","collection.list()","collection.map()","collection.push(data)","collection.set(path)","collection.totypedarray()","collectionemits:","collectionreturns:","collections,","combin","command","comment","commit","commit)","commitment)","commitment,","committed.","common","commun","compat","compel","compet","competit","compil","compile.","compiler'","compiler(settings)","compiler.","compiler._fromjavascript(body)","compiler._getjavascriptast(input)","compilerreturns:","complet","complete,","complete.","complex","complexity,","compon","components,","components.","components;","compos","composit","composition,","compromis","comput","computation\":","computation,","computation.","computation.”","computations,","computations.","computations.”","computed,","computing.","concept","concern","conclus","conditions\"","config","config.verbos","configur","configuration.","confirm","conflict","conjur","connect","connections.","consensu","consensus([settings])","consensus,","consensus.","consid","console.","console.error('[quickstart]',","console.log('messag","console.log('receiv","const","constrain","constraint","construct","construct:","constructed.","constructively?","constructor.","consum","consume,","consumers.","consumption.","contain","contains.","content","contention\",","contents.","context","context:","contextu","conting","continu","contract","contract'","contract,","contract.","contracts\")","contracts,","contracts.","contrast","control","conveni","conversation?","convert","coordin","coordinator.","copi","core","core,","core/","core:","correct","correctli","correl","cost","count","counterparty)","counterparty.","coupl","cover","craft","crawl","creat","creation.","cross","crowdfund","cryptograph","cryptographi","cryptologycrypto","cryptosystem,","crystal","css","curiou","curli","currenc","currency,","current","cycl","cycle.","d,","damgrd,","data","data,","data.","databas","datastor","datastore.","date","date.","david","debug","decentr","decis","decrypt","deeper","deepli","default","defens","defer","defin","defined,","definit","definition)","definition.","definitions.","definitions:","degre","delet","deliv","deliveri","delta","demand","demonstr","denot","depend","deplo","deploy","deprec","depth","deriv","describ","descript","description).","deserv","design","designs,","desir","desired.","despit","destroy","detail","detect","determin","determinist","deterministic,","dev","develop","development,","difficult","difficult.","dig","digest","digest.","digit","dilley","dir","direct","directli","directori","discern","disclos","disconnect","discov","discret","discuss","discussed.","disk","disk.","dispar","dissimilar","distinct","distribut","diverg","divid","doc","docs,","document","document'","document.","documentation.","documents.","dom","domain","domain,","domel","domin","door","doorman,","downsample.","downstream","draft","drawback","drivechain,","drop","duplex","duplicate,","durat","dure","dynam","e.","e.g.","each","eager","earlier","earn","easili","econom","economi","economics)","edg","edit","educ","effect","effect^[cit","effects).","effici","effort","efforts.","element","element.","elements,","elements.","elment","else.","embed","emerg","emerged,","emit","empass","empow","emulator.","enabl","encod","encount","encourag","encrypt","encryption,","end","endang","energi","enforc","enforcement.","engin","engine.","enigma","ensur","entir","entireti","entiti","entity([data])","entity,","entity.","entity._downsample([input])","entity.tojson()","entity.toraw()","entityreturns:","entri","entropy.","enumer","environ","environment,","environments,","environments.","ephemer","ephemera","eponym","equal","equival","era","es6","establish","et","etc.)","ev","evaluate.","even","event","event,","event.","event:messag","event:{message}","eventemitt","eventemitterproperti","events.","exampl","example,","example:","examples,","examples.","exception);","exchang","exchange(settings)","exchange.","excit","execut","execution.","exhibit","exist","exist,","exit","expand","expans","expect","expected,","expend","expens","expensive,","expensive.","experiment","explicit","explicitli","explor","explorer,","expos","extend","extends:","extens","extent","extern","extract","extrem","fabric","fabric'","fabric();","fabric(config)","fabric,","fabric.","fabric.compute()","fabric.min.j","fabric.on('message',","fabric.push(value)","fabric.register(service)","fabric.start();","fabric.trust(source)","fabric:',","fabricreturns:","face","facilit","fact","failed:',","failur","failure,","failure.","failures].","fair","fals","false,","familiar","familiarity.","famous","fashion,","fashion.","favor","featur","fee","feedback,","feel","fhe,","fhe.","fiat","fibonacci","field","field.","figur","file","final","finally,","financi","find","fingerprint","finit","finite,","first","first\",","first,","first.","fix","flow","flush","focii.","follow","follows:","for.","forc","fork","form","formallyverifi","format","formulae.”","forward","forward\"","found.","foundat","fragment","frame","framework","framework,","frank","fraud","free","freedom","freenode)","fresh","friendli","friendster","from.","fulfil","full","fulli","function","function,","function.","functions,","functions.","fund","fundament","fundamentally,","funds.","further","further,","furthermor","furthermore,","futur","future.","fuzzchain","gain","game","garbl","garner","gave","gener","general'","general,","generator.","genesi","get","getter","getter.","gil,","github","given","global","goal\"","goals.","gone","grab","graph","graphs,","gray","great","great!","greater","greatest","gregori","group","group,","growth","guarante","guarantees)","guarantees.","guid","guy","hand","handl","handle.","handler","handshak","happen","hash","hash.","hash256","hash256(),","hash256(settings)","hash256.digest(input)","hash256.reverse()","hash256returns:","hashes,","hashmap","hashtabl","have","hd","head","healthi","heidelberg,","height","held","help","here","hex","hex.","hexadecim","hidden","hierarch","hierarchi","hierarchy.","high","highest","highli","highvolum","histor","histori","history,","hkdf","hkdf(settings)","hkdf.derive([info],","hmac","hold","homomorph","honest,","host,","host.","hostnam","hous","however,","htlc","htlc+1","htlc+2","htlcs.","html","html,","http","http.","http://bitcoin.org/bitcoin.pdf","http://www.cypherpunks.to/erights/elib/capability/ode/ode.pdf","https://nvm.sh","https://www.w3.org/tr/activitystream","human","hundr","hyperledg","hyperlink.","hyperlinks,","hypertext","i/o","ibm","id","id.","id:","idea","idea,","ident","identifi","identifier.","identity,","idl","idlerpg,","ieee","ieee,","immut","implement","implementation.","implementations).","implementaton.","implic","implicitli","import.","improv","improvement.","impulse.","in.","incent","incentives.","includ","include:","including:","inclus","incom","inconveniently,","increas","incred","increment","indent","independ","independent,","independentlysecur","index","indic","individu","industri","ineffici","influenc","inform","information,","information.","infrastructur","infrastructure.","init","initi","initialized:","initiatives.","injl","injr","ink","ink)","ink)\"]","inner","input","input.","insert","instal","instanc","instance'","instance,","instance.","instanti","instead","instead,","instead.","instruct","instructions,","instructions.","instrument","intang","integ","integer.","integr","integration,","intellig","intend","intens","intention","interact","interaction.","interactions.","interconnect","interest","interesting,","interfac","interface'","interface(settings)","interface,","interface.","interface.cycle(val)","interface.log(...inputs)","interface.now()","interface.start()","interface.stop()","intern","internally.","internet","interoper","interoperability,","interpret","intrins","introduc","introduct","invalid","invalid,","invent","invers","invest","involv","irrat","is,","isol","isomorph","issu","issuanc","it'","it.","item","items.","iter","itself","itself,","itself.","ivan","j.","javascript","job.","jobs,","json","json,","jukebox","kay","keep","key","key()","key([settings])","key({","key,","key.","keypair,","keyring.","keys:","kind:","know","knowledg","knowledge.","known","l1:","l2:","l3:","label","languag","language,","larg","large,","larger","later","later.","latest","launch","lay","layer","learn","leav","ledger","ledger'","ledger,","ledger.","ledger.append(item)","ledger.commit()","ledger.deserialize(input)","ledger.fork()","ledger.get(path)","ledger.id","ledger.inherits(scribe)","ledger.now()","ledger.render()","ledger.serialize([input])","ledger.set(path)","ledger.tostring()","ledger.trust(source)","ledgeroverrides:","ledgerreturns:","lee","legaci","lend","length","let'","level","leverag","librari","lifecycl","lifecycle.","lifetim","lightn","likelihood","limit","limitit","lindi","line","linear,","link","linkabl","list","list,","listen","live","load","local","localhost","lock","lock,","log","logic","long","long.","longer).","look","lookahead:","loop","lot","lower","m:","machin","machine(config)","machine,","machine.","machine.compute(input)","machine.sip([n])","machinereturns:","machines,","made","main","main().catch((exception)","mainnet.","maintain","major","make","maki,","malici","manag","management,","mani","manifest","manipul","map","map.","market","market\"","market,","market.","markets\",","markup","marshal","martindale,","martindale/fabric#fabr","match","match.","materi","material.","math.","mathemat","matrix","matrix([settings])","matrix.","matrix._get(path)","matrix._put(path,","matrix._registeractor(actor)","matrix._send(message)","matrix.connect(notify)","matrix.handler(message)","matrix.route(msg)","matrix.send(channel,","matrix.st","matrix.start()","matrix.stop()","matrix.tick()","matrixoverrides:","matrixreturns:","maxim","maxwel","meaning","measur","mechan","mechanics.","mechanism,","mechanism.","mechanisms,","medium","meet","member","memori","memory,","memory.","mempool","mempool(settings)","merkletre","merkletree.","messag","message(message)","message)","message);","message.","message.asraw()","messagereturns:","messages,","messages.","message}","method","method.","method.emits:","method:","microformat","microsoft","middl","millisecond","milliseconds.","mind","minim","minimum","mint","minut","mit","mix","mnemon","mode","model","model,","model^[cit","models.","moder","modern","modif","modifi","modify.","modul","module:messag","momentum","monetari","money,","monitor.","monopoli","monopolies,","more","more.","morrison","morrison,","move","mpc","msg","msg);","mtx","much","multi","multiparti","multipl","multipli","mutat","mutation,","mutual","myspace,","n","n+1","n+2","n:","n_th","nakamoto","nakamoto,","name","name)","name.","name:","namespac","nathan,","nativ","navig","necessari","necessarili","need","needed.","needed]","needed],","needed].","negative).","nestedaddress:","nesteddepth:","net","network","network,","network.","network:","networks,","networks.","never","new","new,","newli","next","next.","nick","node","node,","node.","nodes,","nodes.","nois","noisy?","non","none.","normal","normally.","not,","note","note:","notic","notifi","notori","novel","now","npm","null","null,","number","number.","numbers.","numer","nvm:","obj","object","object)","object,","object.","objects,","objects.","objects.properti","observ","obviat","of:","offer","offici","on","onc","once,","one'","onto","op_checklocktimeverifi","op_checksig","op_drop","op_dup","op_els","op_endif","op_equ","op_equalverifi","op_hash160","op_if","op_sha256","opcode,","open","opendif","oper","operates,","operations,","opportun","optim","option","optional,","options.","oracl","oracle(initial)","oracle,","oracle._post(key,","oracle._register(obj)","oracle.broadcast(msg)","oracle.del(key)","oracle.flush()","oracle.get(key)","oracle.set(key,","oracle.start()","oracle.trust(source)","oracleoverrides:","oraclereturns:","orchestr","order","order.","order.amount","order.asset","ordering.","orders\"","organ","orient","origin","originator.","orlandi.","ostens","other,","others!","otherwis","out","outbound","outcom","outcome.","outgo","output","output,","output.","outright","outsid","outstand","over","over.","overhead","overhead.","overview","own,","oz","p","p2p","p2sh","packag","page","pages,","pages.","paid","paillier","pair","pairs.","pallier","paper,","parallel","param","paramet","params)","parent.","pars","parse.","part","parti","partial","particip","participants.","particular","particularli","parties,","parties.","party.","pascal","pass","patch","patches)","patchsets,","path","path(input)","path,","path.","path.isvalid()","pathreturns:","pattern,","pattern.","pattern:","paul","pay","payment","payment\",","payment,","payment][zkcp],","payments,","peer","peer#event:readi","peer([config])","peer.","peer.listen()","peer.start()","peer.stop()","peerpacket","peerreturns:","peers,","peers.","pentland.","per","perfect","perform","performed,","perhap","period","persist","phase","phase,","philosophy,","philosophy.","phrase.","place","placeholder,","platform","pleas","plugin","plugin.","plugin.nam","plugins.","point","pointer","pointer.","polynomi","port","posit","position,","possibl","post","potenti","power","power,","power]","pre","predict","preimage,","prepar","prepare.","prerequisit","presenc","present","preserv","prevent","previou","previous","price","primari","primarili","primit","primitives,","principl","prior","prioriti","privaci","privacy\"","privacy,","privat","probabilist","probabl","problem","problem.","proce","process","process.","produc","product","product.","profil","program","program,","program.","program:","programs,","programs.","prohibit","project","promis","proof","proof.","properti","properties.","properties:","propos","proposal?","proprietari","prospect","protect","protocol","protocol,","protocol.","prototyp","prototype.","provabl","proven","provid","provided)","provided,","provided.","provider.","provis","pubkey.","public","public:","publicli","publish","publishing,","purchas","pure","purpos","push","put","puzzle,","python","quadrat","quadratic,","quantiti","quick","quickli","quickstart","quit","quorum","random","rang","rank","rapid","rapidli","rate","re","read","readable,","reader","readi","real","reason","reason,","receiv","receiveaddress:","receivedepth:","recent","recipient.","reclaim","recommend","record","recordkeeper.","redeem","redeemscript","reduc","refer","reference,","reference.","reflect","regard","regist","register.","registration.","regtest,","reinforc","reknown","rel","relationship","relay","releas","releases,","reli","reliabl","reliable,","remain","remot","remote(target)","remote._delete(path,","remote._get(path,","remote._options(path,","remote._patch(path,","remote._post(path,","remote._put(path,","remote.enumerate()","remotereturns:","remov","remove.","render","renderreturns:","renders)","rep","repair","replac","replic","repositori","repres","represent","repriev","request","request.","requests.","requir","require('@fabric/core');","require('@fabric/core/services/bitcoin');","require('@fabric/core/types/actor');","requirements,","requirements.","requisit","research","resili","resist","resolut","resolution,","resolv","resourc","resource'","resource(definition)","resource,","resource.","resource.create(obj)","resource.update(id,","resourcereturns:","resources,","resources.","respect","respons","restor","restrict","result","result.","results.","resurg","retain","retriev","retrieval.","retrieve.","retriv","return","returns:","reveal","revers","reversal,","review.","reviewers:","reward","rfc","risk","risk!","risk.","robust","role","roll","root","rotat","roughli","rout","routabl","route.","router","router(map)","router.","router.commit()","router.deserialize(input)","router.fork()","router.get(path)","router.id","router.inherits(scribe)","router.now()","router.render()","router.route(msg)","router.serialize([input])","router.set(path)","router.tostring()","router.trust(source)","router.use(plugin,","routerreturns:","routes.","rpg","rule","rule,","rules.","run","safe","sake,","salt","same","sampl","sat","sat\"]","satoshi","save","say,","scalability.","scalabl","scale","scale,","scarce.","schema.org","scheme","scheme,","scienc","science.","scope","scribe","scribe(config)","scribe.","scribe.commit()","scribe.deserialize(input)","scribe.fork()","scribe.get(path)","scribe.id","scribe.inherits(scribe)","scribe.now()","scribe.render()","scribe.serialize([input])","scribe.set(path)","scribe.tostring()","scribe.trust(source)","scribeproperti","scribereturns:","script","script'","script(config)","script,","script.","scripts/quickstart.j","search","search.","second","secret","secret)","secur","secure,","security.","see","see:","seed","seek","select","selector","selector.","self","seller","semant","semantics.","send","send.","sender","sent","sent.","separ","sequenc","sequence.","seri","serial","serialize.","serv","server","server,","servic","service'","service(config)","service,","service.","service._get(path)","service._put(path,","service._registeractor(actor)","service._send(message)","service.connect(notify)","service.handler(message)","service.route(msg)","service.send(channel,","service.start()","service.tick()","servicereturns:","services,","services.","session","session(settings)","session,","session.","session.start()","session.stop()","set","sets,","settings.","settings.bodi","settings.fe","settings.fees.minimum","settings.initi","settings.input","settl","settled.","sever","sha256","sha256(input)","shard","share","shared,","sheet","sidechain","sign","sign()","signatori","signatur","signature,","signatures,","signific","silo","similar","similarly,","simpl","simple!","simplest","simpli","simplicity'","simply:","simul","simultan","singl","singular","size","size]","slice","slightli","small","small,","smaller","smaller,","smart","smpc.","snapshot","snapshot(settings)","snapshot.","snapshot.commit()","snapshot}","softwar","solut","solv","someth","sort","soundtrack.io,","sourc","source,","source.","space","spaces.","speak","spec:","special","specif","specifi","specifically,","spectrum,","speech","spend","spendabl","spent","split","springer","spv","spvsource.","stabl","stack","stack#fram","stack#id.","stack([list])","stack.","stack.push(data)","stackreturns:","stand","standard","start","start!","started,","startreturns:","stash","state","state(data)","state,","state.","state.commit()","state.deserialize(input)","state.fork()","state.fromjson(input)","state.get(path)","state.id","state.render()","state.serialize([input])","state.set(path)","state.tostring()","stateproperti","statereturns:","static","statu","step","stop","storag","storage(config)","storage,","storage.","storage.set","store","store([settings])","store.","store._post(key,","store._register(obj)","store.del(key)","store.flush()","store.get(key)","store.set(key,","store.start()","store.trust(source)","storereturns:","strategi","stream","stream.","string","string,","string.","structur","structure)","structure,","sub","subgraph","subject","submit","subscrib","subscript","subscriptions,","subsequ","subset.","subsidi","subsidies.","subsidy\",","substrat","succe","success","success,","success.","such","such,","sudoku","suffici","sugar","sum","sum.","suppli","supply)","supply.","support","support.","suppos","surround","swap","swap([settings])","swap.","swap.extractsecret(tx,","swapreturns:","swarm","swarm(config)","swarm.","swarm.start()","swarm.trust(source)","swarmreturns:","symbol","symposium","syntact","syntax","system","system'","system,","system.","systems,","systems.","systems]:","szabo","t","t,","t^","tackl","tag","tag.","take","tangibl","target","target.","target.host","target.secur","task.","techniqu","technology.","templat","tenet","term","termin","testnet,","them,","themselv","there'","therein.","thermodynam","they'd","thing","things,","think","third","this.chain","this.state.","thought","thousand","three","threshold","threshold.","through","thrown","tick","tightli","time","time,","time.","timefram","timeout","timestamp","timestamp,","timestamp.","timothi","tip","tl","to.","to:","today","today.","todo","todo:","token","token,","token.","tokens,","tolerable,","tool","top","topolog","topology,","toward","track","traction,","trade","tradit","transact","transaction.","transactions,","transactions.","transfers,","transit","transition(settings)","transmit","treat","tree","tree.","tri","trigger","tripl","trivial","true","true,","trust","trust,","trust.","trustlessli","truth","truth.","turn","twitter","twitter,","twitter:","two","tx","type","type,","type.","type:","types,","typic","undefin","underli","unencrypted,","unifi","uniqu","unit","univers","unix","unknowable,","unknown","unmarshal","unrel","unspent","until","untrust","up","up!","updat","update)","update.","updates.","upnp","upon","upstart","us","use.","used.","user","user,","user.","users,","util","utilize.","utilized,","val","valid","valid.","valu","valuable.","value(data)","value)","value).","value,","value.","value.]","value.value(input)","values).","values,","values.","vari","varieti","variou","vector","vector(origin)","vector,","vector.","vector._serialize(input)","vector.tostring(input)","vectorreturns:","verbatim.","verbosity:","veri","verifi","verified,","verifier.","verify.","verse,","version","via","viable.","view","virtual","visual","volum","voluntari","vote","wait","walker","walker(init)","walker._define(dir,","walker._explore(path,","walkerreturns:","wallet","wallet([settings])","wallet,","wallet.","wallet...","wallet._createcrowdfund(fund)","wallet._getrefundinputscript(redeemscript)","wallet._getswapinputscript(redeemscript,","wallet._load(settings)","wallet._sign(tx)","wallet.createpricedorder(order)","wallet.getaddressforscript(script)","wallet.getaddressfromredeemscript(redeemscript)","wallet.publickeyfromstring(input)","wallet.start()","want","warning!","watchonly:","wave","way","way,","way?","we'v","wealth","web","web,","webs.","week","week),","well","wherebi","wherein","whether","whitepap","wid:","wide","widespread","widest","wipe","wisely.","with.","within","without","witness:","work","work\".","work)","work,","work.","worker","worker(method)","worker.compute(input)","workerreturns:","workflow","workload","world","world'","writing,","x","x'","xanadu","xmlhttprequest","y","yao'","yao,","you'r","you.","zero","zkcp","zkcp.","zyskind,","{","{@link","{@link}","{}","|","}","}\"]","})","});","~bitcoin","§","ƒ","ƒ(x)","δ","δx'","φ...","φ0","φ1","φ2","φ3","–","—","’sandy’","”effici","”protocol","”publicli","⇐","⇒","☕","⚡","🏦","👀","📃","📄","🖨️","🚨","🤔","🤯"],"pipeline":["stopWordFilter","stemmer"]},"store":{"./":{"url":"./","title":"🤔 Introduction","keywords":"","body":"Fabric\n\n\n\n\n\nFabric is an experimental approach to the secure establishment and execution of\npeer-to-peer agreements, up to and including financial transactions.  With a\nrobust library of common components, npm i @fabric/core provides all the tools\none might require during the development of a well-researched application of\ndecentralization technology.\n\n\n\n🚨 Heads up!\n\n\n\n\nUse of Fabric in production is not recommended in its current state.  Please wait for an official release before deploying to production environments, or proceed at your own risk.\n\n\n\nGetting Started\nIf you're already familiar with node and have a project already started, try\nnpm install --save @fabric/core to install Fabric Core,\nthe primary library used for most Fabric-based applications.\nFork and clone the Fabric GitHub repository and launch a local\nweb server with npm run examples to view the examples, or npm run docs once\nyou're ready to integrate Fabric into your application.\nAvailable Commands\n\nnpm run cli provides a direct command-line interface to the Fabric network.\nnpm run dev serves a developer interface over localhost HTTP.\nnpm run docs creates a local HTTP server for browsing documentation.\nnpm run examples creates a local HTTP server for interacting with examples.\nnpm start creates a local Fabric node.\n\nAPI\nThe Fabric reference implementation exposes a simple message-passing interface\nusing the actor model, enabling your downstream applications to\nsubscribe to simple events for rapid prototyping of distributed applications.\nUsing as a Library\nUsing the EventEmitter pattern, you can create an instance of Fabric to use\nit as an event source.\nSimple Example\nconst Fabric = require('@fabric/core');\nconst fabric = new Fabric();\n\nfabric.on('message', function (message) {\n  console.log('Received message from Fabric:', message);\n});\n\nfabric.start();\n\nservice now contains a full instance of Fabric, including SET and GET\nmethods for publishing and retrieving documents.  Use npm run examples to see\nmore.\nMessage Types\nMessage types are as follows:\nmessage\nThe generic message event.\nProperties:\n\n@type name of the event type.\n@data the content of the event, if any.\n\nUsing Fabric in the Browser\nFabric generates a fabric.min.js bundle, which can be included with any HTML\ndocument to expose the API in a browser.\nOther Fabrics\nSeveral other projects have used the name Fabric, as it's a great way to\ndescribe a network of things, conjuring feelings of nets and webs.  Here are\nsome links to them, as they offer some interesting things completely unrelated\nto our goals.\n\nFabric python project (#fabric on Freenode)\nFabric application framework by Twitter\nHyperLedger Fabric, by IBM\n\nPlugins\nFabric is an extensible framework, supporting a variety of plugins.\n\n\n\nPackage\nDescription\nStatus\n\n\n\n\n@fabric/http\nserve Fabric apps to the legacy web (HTTP)\n \n\n\n@fabric/doorman\nan artificially intelligent assistant\n \n\n\n@fabric/soundtrack\ncollaborative jukebox\n \n\n\n\nRunning on Fabric\nSeveral successful projects are built with or are running on Fabric, including:\n\nsoundtrack.io, Internet jukebox\nDoorman, an artificially intelligent assistant\nIdleRPG, a simple RPG game which rewards you for remaining idle\nVerse, a virtual universe simulator\n\nTo add your project to the list, read the API docs, create a public\nrepository for the source code, then edit this file to include a\nlink to your work.\nLearning More\nThe best place to get started is in the #learning channel, a\ncollection of empassioned educators eager to help you.\nFabric on Twitter: @FabricProtocol\n"},"QUICKSTART.html":{"url":"QUICKSTART.html","title":"👀 Quick Start","keywords":"","body":"Fabric Quickstart\nPrerequisites\n\n(optional) Install NVM: https://nvm.sh\nInstall Node 12.16\nRun node --version and verify the output matches 12.16\nSee #1\n\nInstructions\n\nMeet the prerequisites (above)\nInstall Fabric Core: npm i --save @fabric/core\n\nNote: for development releases, use npm i --save martindale/fabric#fabric instead.\nSample Program\nCreate the file scripts/quickstart.js using the following code:\nconst Bitcoin = require('@fabric/core/services/bitcoin');\n\nasync function main () {\n  const bitcoin = new Bitcoin({\n    verbosity: 3\n  });\n\n  await bitcoin.start();\n}\n\nmain().catch((exception) => {\n  console.error('[QUICKSTART]', 'Quick Start failed:', exception);\n});\n\nFinally, run the program:\n> node scripts/quickstart.js\n[AUDIT] Generating new HD key for wallet...\n[AUDIT] Wallet account: {\n  id: 'WLTTtuqaMtxMRiP33gLf1BN2js5HESWxHEhE',\n  wid: 1,\n  name: 'default',\n  network: 'main',\n  initialized: true,\n  witness: false,\n  watchOnly: false,\n  type: 'pubkeyhash',\n  m: 1,\n  n: 1,\n  accountIndex: 0,\n  receiveDepth: 1,\n  changeDepth: 1,\n  nestedDepth: 0,\n  lookahead: 10,\n  receiveAddress: '1CxaBhXMiyNPGZ2K2gNprxY6BnCnKVoEgW',\n  changeAddress: '1L3LYaPmHfUhLDtsjzw77bsqhzC5esx9qf',\n  nestedAddress: null,\n  accountKey: 'xpub6Cn1n6iWaPYRqoD4Ss9Sx4i2FLmdZ4ZSwb5NULg6DGCNXMVikaoRk3KFRihqRqLSPiNTDmVHgj7Ff1LMLidcveMf8kPHSX51CjBtZtCqiDU',\n  keys: []\n}\n"},"API.html":{"url":"API.html","title":"🖨️ API Reference Sheet","keywords":"","body":"Modules\n\n@fabric/core/services/bitcoin ⇐ Service\nManages interaction with the Bitcoin network.\n\n\n\nClasses\n\nActor\nGeneric Fabric Actor.\n\nApp ⇐ Scribe\nWeb-friendly application framework for building single-page applications with\nFabric-based networking and storage.\n\nChain\nChain.\n\nChannel\nThe Channel is a encrypted connection with a member of your\nPeer group, with some amount of $BTC bonded and paid for each\ncorrectly-validated message.\nChannels in Fabric are powerful tools for application development, as they\ncan empower users with income opportunities in exchange for delivering\nservice to the network.\n\nCircuit\nThe Circuit is the mechanism through which Fabric\noperates, a computable directed graph describing a network of\nPeer components and their interactions (side effects).\nSee also Swarm for deeper *inspection of Machine\nmechanics.\n\nCLI\nProvides a Command Line Interface (CLI) for interacting with\nthe Fabric network using a terminal emulator.\n\nCollection\nThe Collection type maintains an ordered list of State items.\n\nCompiler : Actor\nCompilers build interfaces for users of Fabric applications.\n\nConsensus\nProvides various network-specific rules.\n\nEntity : Object\nLive instance of an ARC in Fabric.\n\nFabric\nReliable decentralized infrastructure.\n\nHash256\nSimple interaction with 256-bit spaces.\n\nHKDF\nProvides an HMAC-based Extract-and-Expand Key Derivation Function (HKDF), compatible with\nRFC 5869.  Defaults to 32 byte output, matching Bitcoin's implementaton.\n\nInterface ⇐ EventEmitter\nInterfaces compile abstract contract code into Chain-executable transactions, or \"chaincode\". For example, the \"Bitcoin\" interface might compile a Swap contract into Script, preparing a valid Bitcoin transaction for broadcast which executes the swap contract.\n\nKey\nRepresents a cryptographic key.\n\nLedger ⇐ Scribe\nAn ordered stack of pages.\n\nMachine\nGeneral-purpose state machine with Vector-based instructions.\n\nMempool\nStores a list of Transaction elements.\n\nMessage : Object\nThe Message type defines the Application Messaging Protocol, or AMP.\nEach Actor in the network receives and broadcasts messages,\nselectively disclosing new routes to peers which may have open circuits.\n\nOracle ⇐ Store\nAn Oracle manages one or more collections, using a mempool for\ntransitive state.\n\nPath\nA Path is a Fabric-native link to a Document\nwithin the network.\n\nPeer\nAn in-memory representation of a node in our network.\n\nRemote : Remote\nInteract with a remote Resource.\n\nResource\nGeneric interface for collections of digital objects.\n\nRouter ⇐ Scribe\nProcess incoming messages.\n\nScribe ⇐ State\nSimple tag-based recordkeeper.\n\nScript\n\nService\nThe \"Service\" is a simple model for processing messages in a distributed\nsystem.  Service instances are public interfaces for outside systems,\nand typically advertise their presence to the network.\nTo implement a Service, you will typically need to implement all methods from\nthis prototype.  In general, connect and send are the highest-priority\njobs, and by default the fabric property will serve as an I/O stream using\nfamiliar semantics.\n\nSession\nThe Session type describes a connection between Peer\nobjects, and includes its own lifecycle.\n\nSnapshot\nA type of message to be expected from a Service.\n\nStack\nManage stacks of data.\n\nState ⇐ EventEmitter\nThe State is the core of most User-facing interactions.  To\ninteract with the User, simply propose a change in the state by\ncommitting to the outcome.  This workflow keeps app design quite simple!\n\nStorage\nPersistent data storage.\n\nStore\nLong-term storage.\n\nSwap : Object\nThe Swap contract executes a set of transactions on two distinct\nChain components, utilizing a secret-reveal mechanism to atomically\nexecute either the full set or none.\n\nSwarm : String\nOrchestrates a network of peers.\n\nTransition\nThe Transition type reflects a change from one finite\nState to another.\n\nValue\nNumber-like type.\n\nVector\n\nWalker\n\nWallet : Object\nManage keys and track their balances.\n\nWorker\nWorkers are arbitrary containers for processing data.  They can be thought of\nalmost like \"threads\", as they run asynchronously over the duration of a\ncontract's lifetime as \"fulfillment conditions\" for its closure.\n\nExchange\nImplements a basic Exchange.\n\nMatrix ⇐ Service\nService for interacting with Matrix.\n\n\n\n\n@fabric/core/services/bitcoin ⇐ Service\nManages interaction with the Bitcoin network.\nExtends: Service  \n\n@fabric/core/services/bitcoin ⇐ Service\n~Bitcoin\nnew Bitcoin([settings])\ninstance\n.UAString\n.tip\n.height\n._prepareTransaction(obj)\n._handleCommittedBlock(block)\n._handlePeerPacket(msg)\n._handleBlockFromSPV(msg)\n._handleTransactionFromSPV(tx)\n._subscribeToShard(shard)\n._connectSPV()\n.connect(addr)\n.start()\n.stop()\n\n\nstatic\n.Transaction\n.MutableTransaction\n\n\n\n\n\n\n\n\n@fabric/core/services/bitcoin~Bitcoin\nKind: inner class of @fabric/core/services/bitcoin  \n\n~Bitcoin\nnew Bitcoin([settings])\ninstance\n.UAString\n.tip\n.height\n._prepareTransaction(obj)\n._handleCommittedBlock(block)\n._handlePeerPacket(msg)\n._handleBlockFromSPV(msg)\n._handleTransactionFromSPV(tx)\n._subscribeToShard(shard)\n._connectSPV()\n.connect(addr)\n.start()\n.stop()\n\n\nstatic\n.Transaction\n.MutableTransaction\n\n\n\n\n\n\nnew Bitcoin([settings])\nCreates an instance of the Bitcoin service.\n\n\n\nParam\nType\nDescription\n\n\n\n\n[settings]\nObject\nMap of configuration options for the Bitcoin service.\n\n\n[settings.network]\nString\nOne of regtest, testnet, or mainnet.\n\n\n[settings.nodes]\nArray\nList of address:port pairs to trust.\n\n\n[settings.seeds]\nArray\nBitcoin peers to request chain from (address:port).\n\n\n[settings.fullnode]\nBoolean\nRun a full node.\n\n\n\n\nbitcoin.UAString\nUser Agent string for the Bitcoin P2P network.\nKind: instance property of Bitcoin\nbitcoin.tip\nChain tip (block hash of the chain with the most Proof of Work)\nKind: instance property of Bitcoin\nbitcoin.height\nChain height (=== length - 1)\nKind: instance property of Bitcoin\nbitcoin._prepareTransaction(obj)\nPrepares a Transaction for storage.\nKind: instance method of Bitcoin  \n\n\n\nParam\nType\nDescription\n\n\n\n\nobj\nTransaction\nTransaction to prepare.\n\n\n\n\nbitcoin._handleCommittedBlock(block)\nReceive a committed block.\nKind: instance method of Bitcoin  \n\n\n\nParam\nType\nDescription\n\n\n\n\nblock\nBlock\nBlock to handle.\n\n\n\n\nbitcoin._handlePeerPacket(msg)\nProcess a message from a peer in the Bitcoin network.\nKind: instance method of Bitcoin  \n\n\n\nParam\nType\nDescription\n\n\n\n\nmsg\nPeerPacket\nMessage from peer.\n\n\n\n\nbitcoin._handleBlockFromSPV(msg)\nHand a Block message as supplied by an SPV client.\nKind: instance method of Bitcoin  \n\n\n\nParam\nType\nDescription\n\n\n\n\nmsg\nBlockMessage\nA Message as passed by the SPV source.\n\n\n\n\nbitcoin._handleTransactionFromSPV(tx)\nVerify and interpret a BitcoinTransaction, as received from an\nSPVSource.\nKind: instance method of Bitcoin  \n\n\n\nParam\nType\nDescription\n\n\n\n\ntx\nBitcoinTransaction\nIncoming transaction from the SPV source.\n\n\n\n\nbitcoin._subscribeToShard(shard)\nAttach event handlers for a supplied list of addresses.\nKind: instance method of Bitcoin  \n\n\n\nParam\nType\nDescription\n\n\n\n\nshard\nShard\nList of addresses to monitor.\n\n\n\n\nbitcoin._connectSPV()\nInitiate outbound connections to configured SPV nodes.\nKind: instance method of Bitcoin\nbitcoin.connect(addr)\nConnect to a Fabric Peer.\nKind: instance method of Bitcoin  \n\n\n\nParam\nType\nDescription\n\n\n\n\naddr\nString\nAddress to connect to.\n\n\n\n\nbitcoin.start()\nStart the Bitcoin service, including the initiation of outbound requests.\nKind: instance method of Bitcoin\nbitcoin.stop()\nStop the Bitcoin service.\nKind: instance method of Bitcoin\nBitcoin.Transaction\nProvides bcoin's implementation of TX internally.  This static may be\nremoved in the future.\nKind: static property of Bitcoin\nBitcoin.MutableTransaction\nProvides bcoin's implementation of MTX internally.  This static may be\nremoved in the future.\nKind: static property of Bitcoin\nActor\nGeneric Fabric Actor.\nKind: global classEmits: event:message Fabric {@link Message} objects.Properties\n\n\n\nName\nType\nDescription\n\n\n\n\nid\nString\nUnique identifier for this Actor.\n\n\n\n\nActor\nnew Actor([actor])\n.toBuffer() ⇒ Buffer\n.sign() ⇒ Actor\n\n\n\n\nnew Actor([actor])\nCreates an Actor, which emits messages for other\nActors to subscribe to.  You can supply certain parameters\nfor the actor, including key material [!!!] — be mindful of\nwhat you share with others!\n\n\n\nParam\nType\nDescription\n\n\n\n\n[actor]\nObject\nObject to use as the actor.\n\n\n[actor.seed]\nString\nBIP24 Mnemonic to use as a seed phrase.\n\n\n[actor.public]\nBuffer\nPublic key.\n\n\n[actor.private]\nBuffer\nPrivate key.\n\n\n\n\nactor.toBuffer() ⇒ Buffer\nCasts the Actor to a normalized Buffer.\nKind: instance method of Actor\nactor.sign() ⇒ Actor\nSigns the Actor.\nKind: instance method of Actor\nApp ⇐ Scribe\nWeb-friendly application framework for building single-page applications with\nFabric-based networking and storage.\nKind: global classExtends: ScribeProperties\n\n\n\nName\nType\nDescription\n\n\n\n\ncomponents\nCollection\nInterface elements.\n\n\nstash\nStore\nRoutable Datastore.\n\n\n\n\nApp ⇐ Scribe\nnew App(definition)\n.id : Boolean\n.start() ⇒ Promise\n.stop() ⇒ Promise\n.define(name, structure) ⇒ Object\n.defer(authority) ⇒ App\n.attach(element) ⇒ App\n.consume(resources) ⇒ App\n.envelop(selector) ⇒ App\n.use(name, definition) ⇒ App\n.render() ⇒ String\n.now() ⇒ Number\n.trust(source) ⇒ Scribe\n.inherits(scribe) ⇒ Scribe\n.toString() ⇒ String\n.serialize([input]) ⇒ Buffer\n.deserialize(input) ⇒ State\n.fork() ⇒ State\n.get(path) ⇒ Mixed\n.set(path) ⇒ Mixed\n.commit()\n\n\n\n\nnew App(definition)\nGeneric bundle for building Fabric applications.\n\n\n\nParam\nType\nDescription\n\n\n\n\ndefinition\nObject\nApplication definition.  See config for examples.\n\n\n\n\napp.id : Boolean\nIdentity function.\nKind: instance property of App\napp.start() ⇒ Promise\nStart the program.\nKind: instance method of App\napp.stop() ⇒ Promise\nStop the program.\nKind: instance method of App\napp.define(name, structure) ⇒ Object\nDefine a Resource, or \"Type\", used by the application.\nKind: instance method of AppReturns: Object - [description]  \n\n\n\nParam\nType\nDescription\n\n\n\n\nname\nString\nHuman-friendly name for the Resource.\n\n\nstructure\nObject\nMap of attribute names -> definitions.\n\n\n\n\napp.defer(authority) ⇒ App\nDefer control of this application to an outside authority.\nKind: instance method of AppReturns: App - The configured application as deferred to authority.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nauthority\nString\nHostname to trust.\n\n\n\n\napp.attach(element) ⇒ App\nConfigure the Application to use a specific element.\nKind: instance method of AppReturns: App - Configured instance of the Application.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nelement\nDOMElement\nDOM element to bind to.\n\n\n\n\napp.consume(resources) ⇒ App\nDefine the Application's resources from an existing resource map.\nKind: instance method of AppReturns: App - Configured instance of the Application.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nresources\nObject\nMap of resource definitions by name.\n\n\n\n\napp.envelop(selector) ⇒ App\nUse a CSS selector to find an element in the current document's tree and\nbind to it as the render target.\nKind: instance method of AppReturns: App - Instance of app with bound element.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nselector\nString\nCSS selector.\n\n\n\n\napp.use(name, definition) ⇒ App\nDefine a named Resource.\nKind: instance method of AppReturns: App - Configurated instance of the App.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nname\nString\nHuman-friendly name for this resource.\n\n\ndefinition\nObject\nMap of configuration values.\n\n\n\n\napp.render() ⇒ String\nGet the output of our program.\nKind: instance method of AppOverrides: renderReturns: String - Output of the program.\napp.now() ⇒ Number\nRetrives the current timestamp, in milliseconds.\nKind: instance method of AppReturns: Number - Number representation of the millisecond Integer value.\napp.trust(source) ⇒ Scribe\nBlindly bind event handlers to the Source.\nKind: instance method of AppReturns: Scribe - Instance of the Scribe.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nsource\nSource\nEvent stream.\n\n\n\n\napp.inherits(scribe) ⇒ Scribe\nUse an existing Scribe instance as a parent.\nKind: instance method of AppReturns: Scribe - The configured instance of the Scribe.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nscribe\nScribe\nInstance of Scribe to use as parent.\n\n\n\n\napp.toString() ⇒ String\nUnmarshall an existing state to an instance of a Blob.\nKind: instance method of AppReturns: String - Serialized Blob.\napp.serialize([input]) ⇒ Buffer\nConvert to Buffer.\nKind: instance method of AppReturns: Buffer - Store-able blob.  \n\n\n\nParam\nType\nDescription\n\n\n\n\n[input]\nMixed\nInput to serialize.\n\n\n\n\napp.deserialize(input) ⇒ State\nTake a hex-encoded input and convert to a State object.\nKind: instance method of AppReturns: State - [description]  \n\n\n\nParam\nType\nDescription\n\n\n\n\ninput\nString\n[description]\n\n\n\n\napp.fork() ⇒ State\nCreates a new child State, with @parent set to\nthe current State by immutable identifier.\nKind: instance method of App\napp.get(path) ⇒ Mixed\nRetrieve a key from the State.\nKind: instance method of App  \n\n\n\nParam\nType\nDescription\n\n\n\n\npath\nPath\nKey to retrieve.\n\n\n\n\napp.set(path) ⇒ Mixed\nSet a key in the State to a particular value.\nKind: instance method of App  \n\n\n\nParam\nType\nDescription\n\n\n\n\npath\nPath\nKey to retrieve.\n\n\n\n\napp.commit()\nIncrement the vector clock, broadcast all changes as a transaction.\nKind: instance method of App\nChain\nChain.\nKind: global classProperties\n\n\n\nName\nType\nDescription\n\n\n\n\nname\nString\nCurrent name.\n\n\nindices\nMap\n\n\n\nledger\nLedger\n\n\n\nstorage\nStorage\n\n\n\n\nnew Chain(genesis)\nHolds an immutable chain of events.\n\n\n\nParam\nType\nDescription\n\n\n\n\ngenesis\nVector\nInitial state for the chain of events.\n\n\n\n\nChannel\nThe Channel is a encrypted connection with a member of your\nPeer group, with some amount of $BTC bonded and paid for each\ncorrectly-validated message.\nChannels in Fabric are powerful tools for application development, as they\ncan empower users with income opportunities in exchange for delivering\nservice to the network.\nKind: global class  \n\nChannel\nnew Channel([settings])\n.add(amount)\n.fund(input)\n.open(channel)\n\n\n\n\nnew Channel([settings])\nCreates a channel between two peers.\nof many transactions over time, to be settled on-chain later.\n\n\n\nParam\nType\nDescription\n\n\n\n\n[settings]\nObject\nConfiguration for the channel.\n\n\n\n\nchannel.add(amount)\nAdd an amount to the channel's balance.\nKind: instance method of Channel  \n\n\n\nParam\nType\nDescription\n\n\n\n\namount\nNumber\nAmount value to add to current outgoing balance.\n\n\n\n\nchannel.fund(input)\nFund the channel.\nKind: instance method of Channel  \n\n\n\nParam\nType\nDescription\n\n\n\n\ninput\nMixed\nInstance of a Transaction.\n\n\n\n\nchannel.open(channel)\nOpens a Channel with a Peer.\nKind: instance method of Channel  \n\n\n\nParam\nType\nDescription\n\n\n\n\nchannel\nObject\nChannel settings.\n\n\n\n\nCircuit\nThe Circuit is the mechanism through which Fabric\noperates, a computable directed graph describing a network of\nPeer components and their interactions (side effects).\nSee also Swarm for deeper *inspection of Machine\nmechanics.\nKind: global class\nCLI\nProvides a Command Line Interface (CLI) for interacting with\nthe Fabric network using a terminal emulator.\nKind: global class  \n\nCLI\nnew CLI([settings])\n.start()\n.stop()\n\n\n\n\nnew CLI([settings])\nCreate a terminal-based interface for a User.\n\n\n\nParam\nType\nDescription\n\n\n\n\n[settings]\nObject\nConfiguration values.\n\n\n[settings.currencies]\nArray\nList of currencies to support.\n\n\n\n\nclI.start()\nStarts (and renders) the CLI.\nKind: instance method of CLI\nclI.stop()\nDisconnect all interfaces and exit the process.\nKind: instance method of CLI\nCollection\nThe Collection type maintains an ordered list of State items.\nKind: global classProperties\n\n\n\nName\nType\nDescription\n\n\n\n\n@entity\nObject\nFabric-bound entity object.\n\n\n\n\nCollection\nnew Collection([configuration])\n.asMerkleTree() ⇒ MerkleTree\n._setKey(name)\n.getByID(id)\n.getLatest()\n.findByField(name, value)\n.findByName(name)\n.findBySymbol(symbol)\n._patchTarget(path, patches)\n.push(data) ⇒ Number\n.get(path) ⇒ Mixed\n.set(path) ⇒ Mixed\n.list() ⇒ Array\n.toTypedArray()\n.map() ⇒ Array\n.create(entity) ⇒ Promise\n.import(state, commit)\n\n\n\n\nnew Collection([configuration])\nCreate a list of Entity-like objects for later retrieval.\n\n\n\nParam\nType\nDefault\nDescription\n\n\n\n\n[configuration]\nObject\n{}\nConfiguration object.\n\n\n\n\ncollection.asMerkleTree() ⇒ MerkleTree\nCurrent elements of the collection as a MerkleTree.\nKind: instance method of Collection\ncollection._setKey(name)\nSets the key property of collection settings.\nKind: instance method of Collection  \n\n\n\nParam\nType\nDescription\n\n\n\n\nname\nString\nValue to set the key setting to.\n\n\n\n\ncollection.getByID(id)\nRetrieve an element from the collection by ID.\nKind: instance method of Collection  \n\n\n\nParam\nType\nDescription\n\n\n\n\nid\nString\nDocument identifier.\n\n\n\n\ncollection.getLatest()\nRetrieve the most recent element in the collection.\nKind: instance method of Collection\ncollection.findByField(name, value)\nFind a document by specific field.\nKind: instance method of Collection  \n\n\n\nParam\nType\nDescription\n\n\n\n\nname\nString\nName of field to search.\n\n\nvalue\nString\nValue to match.\n\n\n\n\ncollection.findByName(name)\nFind a document by the \"name\" field.\nKind: instance method of Collection  \n\n\n\nParam\nType\nDescription\n\n\n\n\nname\nString\nName to search for.\n\n\n\n\ncollection.findBySymbol(symbol)\nFind a document by the \"symbol\" field.\nKind: instance method of Collection  \n\n\n\nParam\nType\nDescription\n\n\n\n\nsymbol\nString\nValue to search for.\n\n\n\n\ncollection._patchTarget(path, patches)\nModify a target document using an array of atomic updates.\nKind: instance method of Collection  \n\n\n\nParam\nType\nDescription\n\n\n\n\npath\nString\nPath to the document to modify.\n\n\npatches\nArray\nList of operations to apply.\n\n\n\n\ncollection.push(data) ⇒ Number\nAdds an Entity to the Collection.\nKind: instance method of CollectionReturns: Number - Length of the collection.  \n\n\n\nParam\nType\nDescription\n\n\n\n\ndata\nMixed\nEntity to add.\n\n\n\n\ncollection.get(path) ⇒ Mixed\nRetrieve a key from the State.\nKind: instance method of Collection  \n\n\n\nParam\nType\nDescription\n\n\n\n\npath\nPath\nKey to retrieve.\n\n\n\n\ncollection.set(path) ⇒ Mixed\nSet a key in the State to a particular value.\nKind: instance method of Collection  \n\n\n\nParam\nType\nDescription\n\n\n\n\npath\nPath\nKey to retrieve.\n\n\n\n\ncollection.list() ⇒ Array\nDeprecated\nGenerate a list of elements in the collection.\nKind: instance method of Collection\ncollection.toTypedArray()\nProvides the Collection as an Array of typed\nelements.  The type of these elments are defined by the collection's\ntype, supplied in the constructor.\nKind: instance method of Collection\ncollection.map() ⇒ Array\nGenerate a hashtable of elements in the collection.\nKind: instance method of Collection\ncollection.create(entity) ⇒ Promise\nCreate an instance of an Entity.\nKind: instance method of CollectionReturns: Promise - Resolves with instantiated Entity.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nentity\nObject\nObject with properties.\n\n\n\n\ncollection.import(state, commit)\nLoads State into memory.\nKind: instance method of CollectionEmits: event:message Will emit one {@link Snapshot} message.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nstate\nState\nState to import.\n\n\ncommit\nBoolean\nWhether or not to commit the result.\n\n\n\n\nCompiler : Actor\nCompilers build interfaces for users of Fabric applications.\nKind: global classProperties\n\n\n\nName\nType\nDescription\n\n\n\n\nast\nAST\nCompiler's current AST.\n\n\nentity\nEntity\nCompiler's current Entity.\n\n\n\n\nCompiler : Actor\nnew Compiler(settings)\ninstance\n._getJavaScriptAST(input) ⇒ AST\n\n\nstatic\n._fromJavaScript(body) ⇒\n\n\n\n\n\n\nnew Compiler(settings)\nCreate a new Compiler.\n\n\n\nParam\nType\nDefault\nDescription\n\n\n\n\nsettings\nObject\n{}\nConfiguration.\n\n\nsettings.body\nBuffer\n\nBody of the input program to compile.\n\n\n\n\ncompiler._getJavaScriptAST(input) ⇒ AST\nParse a Buffer of JavaScript into an Abstract Syntax Tree (AST).\nKind: instance method of Compiler  \n\n\n\nParam\nType\nDescription\n\n\n\n\ninput\nBuffer\nInput JavaScript to parse.\n\n\n\n\nCompiler._fromJavaScript(body) ⇒\nCreates a new Compiler instance from a JavaScript contract.\nKind: static method of CompilerReturns: Compiler  \n\n\n\nParam\nType\nDescription\n\n\n\n\nbody\nBuffer\nContent of the JavaScript to evaluate.\n\n\n\n\nConsensus\nProvides various network-specific rules.\nKind: global class\nnew Consensus([settings])\nCreate an instance of a Consensus verifier.\n\n\n\nParam\nType\nDescription\n\n\n\n\n[settings]\nObject\nConfiguration for the network.\n\n\n[settings.network]\nString\nName of the network.\n\n\n[settings.provider]\nString\nName of the source provider.\n\n\n\n\nEntity : Object\nLive instance of an ARC in Fabric.\nKind: global class  \n\nEntity : Object\nnew Entity([data])\n.toJSON() ⇒ String\n.toRaw() ⇒ Buffer\n._downsample([input])\n\n\n\n\nnew Entity([data])\nGeneric template for virtual objects.\n\n\n\nParam\nType\nDefault\nDescription\n\n\n\n\n[data]\nObject\n{}\nPass an object to use.\n\n\n\n\nentity.toJSON() ⇒ String\nProduces a string of JSON, representing the entity.\nKind: instance method of EntityReturns: String - JSON-encoded object.\nentity.toRaw() ⇒ Buffer\nAs a Buffer.\nKind: instance method of EntityReturns: Buffer - Slice of memory.\nentity._downsample([input])\nReturn a Fabric-labeled Object for this Entity.\nKind: instance method of Entity  \n\n\n\nParam\nType\nDescription\n\n\n\n\n[input]\nMixed\nInput to downsample.  If not provided, current Entity will be used.\n\n\n\n\nFabric\nReliable decentralized infrastructure.\nKind: global classProperties\n\n\n\nName\nType\n\n\n\n\nBlock\nClass\n\n\n\n\nFabric\nnew Fabric(config)\n.register(service)\n.push(value) ⇒ Stack\n.trust(source) ⇒ Fabric\n.compute() ⇒ Fabric\n\n\n\n\nnew Fabric(config)\nThe Fabric type implements a peer-to-peer protocol for\nestablishing and settling of mutually-agreed upon proofs of\nwork.  Contract execution takes place in the local node first,\nthen is optionally shared with the network.\nUtilizing\n\n\n\nParam\nType\nDescription\n\n\n\n\nconfig\nVector\nInitial configuration for the Fabric engine.  This can be considered the \"genesis\" state for any contract using the system.  If a chain of events is maintained over long periods of time, state can be considered \"in contention\", and it is demonstrated that the outstanding value of the contract remains to be settled.\n\n\n\n\nfabric.register(service)\nRegister an available Service using an ES6 Class.\nKind: instance method of Fabric  \n\n\n\nParam\nType\nDescription\n\n\n\n\nservice\nClass\nThe ES6 Class.\n\n\n\n\nfabric.push(value) ⇒ Stack\nPush an instruction onto the stack.\nKind: instance method of Fabric  \n\n\n\nParam\nType\n\n\n\n\nvalue\nInstruction\n\n\n\n\nfabric.trust(source) ⇒ Fabric\nBlindly consume messages from a Source, relying on this.chain to\nverify results.\nKind: instance method of FabricReturns: Fabric - Returns itself.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nsource\nEventEmitter\nAny object which implements the EventEmitter pattern.\n\n\n\n\nfabric.compute() ⇒ Fabric\nProcess the current stack.\nKind: instance method of FabricReturns: Fabric - Resulting instance of the stack.\nHash256\nSimple interaction with 256-bit spaces.\nKind: global class  \n\nHash256\nnew Hash256(settings)\n.digest(input) ⇒ String\n.reverse()\n\n\n\n\nnew Hash256(settings)\nCreate an instance of a Hash256 object by calling new Hash256(),\nwhere settings can be provided to supply a particular input object.\nIf the settings is not a string, input must be provided.\n\n\n\nParam\nType\nDescription\n\n\n\n\nsettings\nObject\n\n\n\nsettings.input\nString\nInput string to map as 256-bit hash.\n\n\n\n\nHash256.digest(input) ⇒ String\nProduce a SHA256 digest of some input data.\nKind: static method of Hash256Returns: String - SHA256(input) as a hexadecimal string.  \n\n\n\nParam\nType\nDescription\n\n\n\n\ninput\nString \\\nBuffer\nContent to digest.\n\n\n\n\nHash256.reverse()\nReverses the bytes of the digest.\nKind: static method of Hash256\nHKDF\nProvides an HMAC-based Extract-and-Expand Key Derivation Function (HKDF), compatible with\nRFC 5869.  Defaults to 32 byte output, matching Bitcoin's implementaton.\nKind: global class  \n\nHKDF\nnew HKDF(settings)\n.derive([info], [size])\n\n\n\n\nnew HKDF(settings)\nCreate an HKDF instance.\n\n\n\nParam\nType\nDefault\nDescription\n\n\n\n\nsettings\nObject\n\nList of settings.\n\n\nsettings.initial\nString\n\nInput keying material.\n\n\n[settings.algorithm]\nString\nsha256\nName of the hashing algorithm to use.\n\n\n[settings.salt]\nString\n\nSalt value (a non-secret random value).\n\n\n\n\nhkdF.derive([info], [size])\nDerive a new output.\nKind: instance method of HKDF  \n\n\n\nParam\nType\nDefault\nDescription\n\n\n\n\n[info]\nBuffer\n\nContext and application specific information.\n\n\n[size]\nNumber\n32\nLength of output.\n\n\n\n\nInterface ⇐ EventEmitter\nInterfaces compile abstract contract code into Chain-executable transactions, or \"chaincode\". For example, the \"Bitcoin\" interface might compile a Swap contract into Script, preparing a valid Bitcoin transaction for broadcast which executes the swap contract.\nKind: global classExtends: EventEmitterProperties\n\n\n\nName\nType\nDescription\n\n\n\n\nstatus\nString\nHuman-friendly value representing the Interface's current State.\n\n\n\n\nInterface ⇐ EventEmitter\nnew Interface(settings)\n.start()\n.stop()\n.cycle(val)\n.log(...inputs)\n.now() ⇒ Number\n\n\n\n\nnew Interface(settings)\nDefine an Interface by creating an instance of this class.\n\n\n\nParam\nType\nDescription\n\n\n\n\nsettings\nObject\nConfiguration values.\n\n\n\n\ninterface.start()\nStart the Interface.\nKind: instance method of Interface\ninterface.stop()\nStop the Interface.\nKind: instance method of Interface\ninterface.cycle(val)\nTicks the clock with a named Cycle.\nKind: instance method of Interface  \n\n\n\nParam\nType\nDescription\n\n\n\n\nval\nString\nName of cycle to scribe.\n\n\n\n\ninterface.log(...inputs)\nLog some output to the console.\nKind: instance method of Interface  \n\n\n\nParam\nType\nDescription\n\n\n\n\n...inputs\nany\nComponents of the message to long.  Can be a single {@link} String, many String objects, or anything else.\n\n\n\n\ninterface.now() ⇒ Number\nReturns current timestamp.\nKind: instance method of Interface\nKey\nRepresents a cryptographic key.\nKind: global class\nnew Key([settings])\nCreate an instance of a Fabric Key, either restoring from some known\nvalues or from prior knowledge.  For instance, you can call new Key()\nto create a fresh keypair, or new Key({ public: 'deadbeef...' }) to\ncreate it from a known public key.\n\n\n\nParam\nType\nDescription\n\n\n\n\n[settings]\nObject\nInitialization for the key.\n\n\n[settings.network]\nString\nNetwork string.\n\n\n[settings.seed]\nString\nMnemonic seed for initializing the key.\n\n\n[settings.public]\nString\nPublic key in hex.\n\n\n[settings.private]\nString\nPrivate key in hex.\n\n\n\n\nLedger ⇐ Scribe\nAn ordered stack of pages.\nKind: global classExtends: ScribeProperties\n\n\n\nName\nType\nDescription\n\n\n\n\nmemory\nBuffer\nThe ledger's memory (4096 bytes).\n\n\nstack\nStack\nThe ledger's stack.\n\n\ntip\nMixed\nThe most recent page in the ledger.\n\n\n\n\nLedger ⇐ Scribe\n.id : Boolean\n.append(item) ⇒ Promise\n.now() ⇒ Number\n.trust(source) ⇒ Scribe\n.inherits(scribe) ⇒ Scribe\n.toString() ⇒ String\n.serialize([input]) ⇒ Buffer\n.deserialize(input) ⇒ State\n.fork() ⇒ State\n.get(path) ⇒ Mixed\n.set(path) ⇒ Mixed\n.commit()\n.render() ⇒ String\n\n\n\n\nledger.id : Boolean\nIdentity function.\nKind: instance property of Ledger\nledger.append(item) ⇒ Promise\nAttempts to append a Page to the ledger.\nKind: instance method of LedgerReturns: Promise - Resolves after the change has been committed.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nitem\nMixed\nItem to store.\n\n\n\n\nledger.now() ⇒ Number\nRetrives the current timestamp, in milliseconds.\nKind: instance method of LedgerReturns: Number - Number representation of the millisecond Integer value.\nledger.trust(source) ⇒ Scribe\nBlindly bind event handlers to the Source.\nKind: instance method of LedgerReturns: Scribe - Instance of the Scribe.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nsource\nSource\nEvent stream.\n\n\n\n\nledger.inherits(scribe) ⇒ Scribe\nUse an existing Scribe instance as a parent.\nKind: instance method of LedgerReturns: Scribe - The configured instance of the Scribe.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nscribe\nScribe\nInstance of Scribe to use as parent.\n\n\n\n\nledger.toString() ⇒ String\nUnmarshall an existing state to an instance of a Blob.\nKind: instance method of LedgerReturns: String - Serialized Blob.\nledger.serialize([input]) ⇒ Buffer\nConvert to Buffer.\nKind: instance method of LedgerReturns: Buffer - Store-able blob.  \n\n\n\nParam\nType\nDescription\n\n\n\n\n[input]\nMixed\nInput to serialize.\n\n\n\n\nledger.deserialize(input) ⇒ State\nTake a hex-encoded input and convert to a State object.\nKind: instance method of LedgerReturns: State - [description]  \n\n\n\nParam\nType\nDescription\n\n\n\n\ninput\nString\n[description]\n\n\n\n\nledger.fork() ⇒ State\nCreates a new child State, with @parent set to\nthe current State by immutable identifier.\nKind: instance method of Ledger\nledger.get(path) ⇒ Mixed\nRetrieve a key from the State.\nKind: instance method of Ledger  \n\n\n\nParam\nType\nDescription\n\n\n\n\npath\nPath\nKey to retrieve.\n\n\n\n\nledger.set(path) ⇒ Mixed\nSet a key in the State to a particular value.\nKind: instance method of Ledger  \n\n\n\nParam\nType\nDescription\n\n\n\n\npath\nPath\nKey to retrieve.\n\n\n\n\nledger.commit()\nIncrement the vector clock, broadcast all changes as a transaction.\nKind: instance method of LedgerOverrides: commit\nledger.render() ⇒ String\nCompose a JSON string for network consumption.\nKind: instance method of LedgerOverrides: renderReturns: String - JSON-encoded String.\nMachine\nGeneral-purpose state machine with Vector-based instructions.\nKind: global class  \n\nMachine\nnew Machine(config)\n.sip([n]) ⇒ Number\n.compute(input) ⇒ Promise\n\n\n\n\nnew Machine(config)\nCreate a Machine.\n\n\n\nParam\nType\nDescription\n\n\n\n\nconfig\nObject\nRun-time configuration.\n\n\n\n\nmachine.sip([n]) ⇒ Number\nGet n bits of entropy.\nKind: instance method of MachineReturns: Number - Random bits from Generator.  \n\n\n\nParam\nType\nDefault\nDescription\n\n\n\n\n[n]\nNumber\n32\nNumber of bits to retrieve (max = 32).\n\n\n\n\nmachine.compute(input) ⇒ Promise\nComputes the next \"step\" for our current Vector.  Analagous to sum.\nThe top item on the stack is always the memory held at current position,\nso counts should always begin with 0.\nKind: instance method of Machine  \n\n\n\nParam\nType\nDescription\n\n\n\n\ninput\nVector\nInput state, undefined if desired.\n\n\n\n\nMempool\nStores a list of Transaction elements.\nKind: global classEmits: event:{Message} confirmed Emitted when the Mempool has dropped a transaction.\nnew Mempool(settings)\nCreates an instance of a Mempool Service.\n\n\n\nParam\nType\nDescription\n\n\n\n\nsettings\nObject\nMap of settings to utilize.\n\n\n\n\nMessage : Object\nThe Message type defines the Application Messaging Protocol, or AMP.\nEach Actor in the network receives and broadcasts messages,\nselectively disclosing new routes to peers which may have open circuits.\nKind: global class  \n\nMessage : Object\nnew Message(message)\n.asRaw() ⇒ Buffer\n\n\n\n\nnew Message(message)\nThe Message type is standardized in Fabric as a Vector, which can be added to any other vector to compute a resulting state.\n\n\n\nParam\nType\nDescription\n\n\n\n\nmessage\nVector\nMessage vector.  Will be serialized by _serialize.\n\n\n\n\nmessage.asRaw() ⇒ Buffer\nReturns a Buffer of the complete message.\nKind: instance method of MessageReturns: Buffer - Buffer of the encoded Message.\nOracle ⇐ Store\nAn Oracle manages one or more collections, using a mempool for\ntransitive state.\nKind: global classExtends: Store  \n\nOracle ⇐ Store\nnew Oracle(initial)\n.broadcast(msg) ⇒ Boolean\n._REGISTER(obj) ⇒ Vector\n._POST(key, value) ⇒ Promise\n.get(key) ⇒ Promise\n.set(key, value)\n.trust(source) ⇒ Store\n.del(key)\n.flush()\n.start() ⇒ Promise\n\n\n\n\nnew Oracle(initial)\nTrusted point-of-reference for external services.\n\n\n\nParam\nType\nDescription\n\n\n\n\ninitial\nObject\nInitialization vector.\n\n\n\n\noracle.broadcast(msg) ⇒ Boolean\nCore messaging function for interacting with this object in system-time.\nKind: instance method of OracleReturns: Boolean - Returns true on success, false on failure.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nmsg\nMessage\nInstance of a module:Message object, validated then transmitted verbatim.\n\n\n\n\noracle._REGISTER(obj) ⇒ Vector\nRegisters an Actor.  Necessary to store in a collection.\nKind: instance method of OracleReturns: Vector - Returned from storage.set  \n\n\n\nParam\nType\nDescription\n\n\n\n\nobj\nObject\nInstance of the object to store.\n\n\n\n\noracle._POST(key, value) ⇒ Promise\nInsert something into a collection.\nKind: instance method of OracleReturns: Promise - Resolves on success with a String pointer.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nkey\nString\nPath to add data to.\n\n\nvalue\nMixed\nObject to store.\n\n\n\n\noracle.get(key) ⇒ Promise\nBarebones getter.\nKind: instance method of OracleReturns: Promise - Resolves on complete.  null if not found.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nkey\nString\nName of data to retrieve.\n\n\n\n\noracle.set(key, value)\nSet a key to a specific value.\nKind: instance method of Oracle  \n\n\n\nParam\nType\nDescription\n\n\n\n\nkey\nString\nAddress of the information.\n\n\nvalue\nMixed\nContent to store at key.\n\n\n\n\noracle.trust(source) ⇒ Store\nImplicitly trust an Event source.\nKind: instance method of OracleReturns: Store - Resulting instance of Store with new trust.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nsource\nEventEmitter\nEvent-emitting source.\n\n\n\n\noracle.del(key)\nRemove a Value by Path.\nKind: instance method of Oracle  \n\n\n\nParam\nType\nDescription\n\n\n\n\nkey\nPath\nKey to remove.\n\n\n\n\noracle.flush()\nWipes the storage.\nKind: instance method of OracleOverrides: flush\noracle.start() ⇒ Promise\nStart running the process.\nKind: instance method of OracleOverrides: startReturns: Promise - Resolves on complete.\nPath\nA Path is a Fabric-native link to a Document\nwithin the network.\nKind: global class  \n\nPath\nnew Path(input)\n.isValid() ⇒ Boolean\n\n\n\n\nnew Path(input)\nCreate a new Path.\n\n\n\nParam\nType\nDescription\n\n\n\n\ninput\nString \\\nObject\nNamed path.\n\n\n\n\npath.isValid() ⇒ Boolean\nKind: instance method of PathReturns: Boolean - Whether or not the Path is valid.\nPeer\nAn in-memory representation of a node in our network.\nKind: global class  \n\nPeer\nnew Peer([config])\n.start()\n.stop()\n.listen() ⇒ Peer\n\n\n\n\nnew Peer([config])\nCreate an instance of Peer.\n\n\n\nParam\nType\nDefault\nDescription\n\n\n\n\n[config]\nObject\n\nInitialization Vector for this peer.\n\n\n[config.listen]\nBoolean\n\nWhether or not to listen for connections.\n\n\n[config.upnp]\nBoolean\n\nWhether or not to use UPNP for automatic configuration.\n\n\n[config.port]\nNumber\n7777\nPort to use for P2P connections.\n\n\n[config.peers]\nArray\n[]\nList of initial peers.\n\n\n\n\npeer.start()\nStart the Peer.\nKind: instance method of Peer\npeer.stop()\nStop the peer.\nKind: instance method of Peer\npeer.listen() ⇒ Peer\nStart listening for connections.\nKind: instance method of PeerReturns: Peer - Chainable method.Emits: Peer#event:ready\nRemote : Remote\nInteract with a remote Resource.\nKind: global classProperties\n\n\n\nName\nType\n\n\n\n\nconfig\nObject\n\n\nsecure\nBoolean\n\n\n\n\nRemote : Remote\nnew Remote(target)\n.enumerate() ⇒ Configuration\n._PUT(path, body) ⇒ Mixed\n._GET(path, params) ⇒ Mixed\n._POST(path, params) ⇒ Mixed\n._OPTIONS(path, params) ⇒ Object\n._PATCH(path, body) ⇒ Object\n._DELETE(path, params) ⇒ Object\n\n\n\n\nnew Remote(target)\nAn in-memory representation of a node in our network.\n\n\n\nParam\nType\nDescription\n\n\n\n\ntarget\nObject\nTarget object.\n\n\ntarget.host\nString\nNamed host, e.g. \"localhost\".\n\n\ntarget.secure\nString\nRequire TLS session.\n\n\n\n\nremote.enumerate() ⇒ Configuration\nEnumerate the available Resources on the remote host.\nKind: instance method of Remote\nremote._PUT(path, body) ⇒ Mixed\nHTTP PUT against the configured Authority.\nKind: instance method of RemoteReturns: Mixed - [description]  \n\n\n\nParam\nType\nDescription\n\n\n\n\npath\nString\nHTTP Path to request.\n\n\nbody\nObject\nMap of parameters to supply.\n\n\n\n\nremote._GET(path, params) ⇒ Mixed\nHTTP GET against the configured Authority.\nKind: instance method of RemoteReturns: Mixed - [description]  \n\n\n\nParam\nType\nDescription\n\n\n\n\npath\nString\nHTTP Path to request.\n\n\nparams\nObject\nMap of parameters to supply.\n\n\n\n\nremote._POST(path, params) ⇒ Mixed\nHTTP POST against the configured Authority.\nKind: instance method of RemoteReturns: Mixed - Result of request.  \n\n\n\nParam\nType\nDescription\n\n\n\n\npath\nString\nHTTP Path to request.\n\n\nparams\nObject\nMap of parameters to supply.\n\n\n\n\nremote._OPTIONS(path, params) ⇒ Object\nHTTP OPTIONS on the configured Authority.\nKind: instance method of RemoteReturns: Object - - Full description of remote resource.  \n\n\n\nParam\nType\nDescription\n\n\n\n\npath\nString\nHTTP Path to request.\n\n\nparams\nObject\nMap of parameters to supply.\n\n\n\n\nremote._PATCH(path, body) ⇒ Object\nHTTP PATCH on the configured Authority.\nKind: instance method of RemoteReturns: Object - - Full description of remote resource.  \n\n\n\nParam\nType\nDescription\n\n\n\n\npath\nString\nHTTP Path to request.\n\n\nbody\nObject\nMap of parameters to supply.\n\n\n\n\nremote._DELETE(path, params) ⇒ Object\nHTTP DELETE on the configured Authority.\nKind: instance method of RemoteReturns: Object - - Full description of remote resource.  \n\n\n\nParam\nType\nDescription\n\n\n\n\npath\nString\nHTTP Path to request.\n\n\nparams\nObject\nMap of parameters to supply.\n\n\n\n\nResource\nGeneric interface for collections of digital objects.\nKind: global class  \n\nResource\nnew Resource(definition)\n.create(obj) ⇒ Vector\n.update(id, update) ⇒ Vector\n\n\n\n\nnew Resource(definition)\n\n\n\nParam\nType\nDescription\n\n\n\n\ndefinition\nObject\nInitial parameters\n\n\n\n\nresource.create(obj) ⇒ Vector\nCreate an instance of the Resource's type.\nKind: instance method of ResourceReturns: Vector - Resulting Vector with deterministic identifier.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nobj\nObject\nMap of the instance's properties and values.\n\n\n\n\nresource.update(id, update) ⇒ Vector\nModify an existing instance of a Resource by its unique identifier.  Produces a new instance.\nKind: instance method of ResourceReturns: Vector - Resulting Vector instance with updated identifier.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nid\nString\nUnique ID to update.\n\n\nupdate\nObject\nMap of change to make (keys -> values).\n\n\n\n\nRouter ⇐ Scribe\nProcess incoming messages.\nKind: global classExtends: Scribe  \n\nRouter ⇐ Scribe\nnew Router(map)\n.id : Boolean\n.route(msg) ⇒ Array\n.use(plugin, name) ⇒ Router\n.now() ⇒ Number\n.trust(source) ⇒ Scribe\n.inherits(scribe) ⇒ Scribe\n.toString() ⇒ String\n.serialize([input]) ⇒ Buffer\n.deserialize(input) ⇒ State\n.fork() ⇒ State\n.get(path) ⇒ Mixed\n.set(path) ⇒ Mixed\n.commit()\n.render() ⇒ String\n\n\n\n\nnew Router(map)\nMaintains a list of triggers (\"commands\") and their behaviors.\n\n\n\nParam\nType\nDescription\n\n\n\n\nmap\nObject\nMap of command names => behaviors.\n\n\n\n\nrouter.id : Boolean\nIdentity function.\nKind: instance property of Router\nrouter.route(msg) ⇒ Array\nAssembles a list of possible responses to the incoming request.\nKind: instance method of RouterReturns: Array - List of outputs generated from the input string.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nmsg\nString\nInput message to route.\n\n\n\n\nrouter.use(plugin, name) ⇒ Router\nAttaches a new handler to the router.\nKind: instance method of RouterReturns: Router - Configured instance of the router.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nplugin\nPlugin\nInstance of the plugin.\n\n\nname\nPlugin.name\nName of the plugin.\n\n\n\n\nrouter.now() ⇒ Number\nRetrives the current timestamp, in milliseconds.\nKind: instance method of RouterReturns: Number - Number representation of the millisecond Integer value.\nrouter.trust(source) ⇒ Scribe\nBlindly bind event handlers to the Source.\nKind: instance method of RouterReturns: Scribe - Instance of the Scribe.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nsource\nSource\nEvent stream.\n\n\n\n\nrouter.inherits(scribe) ⇒ Scribe\nUse an existing Scribe instance as a parent.\nKind: instance method of RouterReturns: Scribe - The configured instance of the Scribe.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nscribe\nScribe\nInstance of Scribe to use as parent.\n\n\n\n\nrouter.toString() ⇒ String\nUnmarshall an existing state to an instance of a Blob.\nKind: instance method of RouterReturns: String - Serialized Blob.\nrouter.serialize([input]) ⇒ Buffer\nConvert to Buffer.\nKind: instance method of RouterReturns: Buffer - Store-able blob.  \n\n\n\nParam\nType\nDescription\n\n\n\n\n[input]\nMixed\nInput to serialize.\n\n\n\n\nrouter.deserialize(input) ⇒ State\nTake a hex-encoded input and convert to a State object.\nKind: instance method of RouterReturns: State - [description]  \n\n\n\nParam\nType\nDescription\n\n\n\n\ninput\nString\n[description]\n\n\n\n\nrouter.fork() ⇒ State\nCreates a new child State, with @parent set to\nthe current State by immutable identifier.\nKind: instance method of Router\nrouter.get(path) ⇒ Mixed\nRetrieve a key from the State.\nKind: instance method of Router  \n\n\n\nParam\nType\nDescription\n\n\n\n\npath\nPath\nKey to retrieve.\n\n\n\n\nrouter.set(path) ⇒ Mixed\nSet a key in the State to a particular value.\nKind: instance method of Router  \n\n\n\nParam\nType\nDescription\n\n\n\n\npath\nPath\nKey to retrieve.\n\n\n\n\nrouter.commit()\nIncrement the vector clock, broadcast all changes as a transaction.\nKind: instance method of Router\nrouter.render() ⇒ String\nCompose a JSON string for network consumption.\nKind: instance method of RouterReturns: String - JSON-encoded String.\nScribe ⇐ State\nSimple tag-based recordkeeper.\nKind: global classExtends: StateProperties\n\n\n\nName\nType\nDescription\n\n\n\n\nconfig\nObject\nCurrent configuration.\n\n\n\n\nScribe ⇐ State\nnew Scribe(config)\n.id : Boolean\n.now() ⇒ Number\n.trust(source) ⇒ Scribe\n.inherits(scribe) ⇒ Scribe\n.toString() ⇒ String\n.serialize([input]) ⇒ Buffer\n.deserialize(input) ⇒ State\n.fork() ⇒ State\n.get(path) ⇒ Mixed\n.set(path) ⇒ Mixed\n.commit()\n.render() ⇒ String\n\n\n\n\nnew Scribe(config)\nThe \"Scribe\" is a simple tag-based recordkeeper.\n\n\n\nParam\nType\nDescription\n\n\n\n\nconfig\nObject\nGeneral configuration object.\n\n\nconfig.verbose\nBoolean\nShould the Scribe be noisy?\n\n\n\n\nscribe.id : Boolean\nIdentity function.\nKind: instance property of Scribe\nscribe.now() ⇒ Number\nRetrives the current timestamp, in milliseconds.\nKind: instance method of ScribeReturns: Number - Number representation of the millisecond Integer value.\nscribe.trust(source) ⇒ Scribe\nBlindly bind event handlers to the Source.\nKind: instance method of ScribeReturns: Scribe - Instance of the Scribe.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nsource\nSource\nEvent stream.\n\n\n\n\nscribe.inherits(scribe) ⇒ Scribe\nUse an existing Scribe instance as a parent.\nKind: instance method of ScribeReturns: Scribe - The configured instance of the Scribe.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nscribe\nScribe\nInstance of Scribe to use as parent.\n\n\n\n\nscribe.toString() ⇒ String\nUnmarshall an existing state to an instance of a Blob.\nKind: instance method of ScribeReturns: String - Serialized Blob.\nscribe.serialize([input]) ⇒ Buffer\nConvert to Buffer.\nKind: instance method of ScribeReturns: Buffer - Store-able blob.  \n\n\n\nParam\nType\nDescription\n\n\n\n\n[input]\nMixed\nInput to serialize.\n\n\n\n\nscribe.deserialize(input) ⇒ State\nTake a hex-encoded input and convert to a State object.\nKind: instance method of ScribeReturns: State - [description]  \n\n\n\nParam\nType\nDescription\n\n\n\n\ninput\nString\n[description]\n\n\n\n\nscribe.fork() ⇒ State\nCreates a new child State, with @parent set to\nthe current State by immutable identifier.\nKind: instance method of Scribe\nscribe.get(path) ⇒ Mixed\nRetrieve a key from the State.\nKind: instance method of Scribe  \n\n\n\nParam\nType\nDescription\n\n\n\n\npath\nPath\nKey to retrieve.\n\n\n\n\nscribe.set(path) ⇒ Mixed\nSet a key in the State to a particular value.\nKind: instance method of Scribe  \n\n\n\nParam\nType\nDescription\n\n\n\n\npath\nPath\nKey to retrieve.\n\n\n\n\nscribe.commit()\nIncrement the vector clock, broadcast all changes as a transaction.\nKind: instance method of Scribe\nscribe.render() ⇒ String\nCompose a JSON string for network consumption.\nKind: instance method of ScribeReturns: String - JSON-encoded String.\nScript\nKind: global class\nnew Script(config)\nCompose a Script for inclusion within a Contract.\nReturns: Script - Instance of the Script, ready for use.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nconfig\nMixed\nConfiguration options for the script.\n\n\n\n\nService\nThe \"Service\" is a simple model for processing messages in a distributed\nsystem.  Service instances are public interfaces for outside systems,\nand typically advertise their presence to the network.\nTo implement a Service, you will typically need to implement all methods from\nthis prototype.  In general, connect and send are the highest-priority\njobs, and by default the fabric property will serve as an I/O stream using\nfamiliar semantics.\nKind: global classProperties\n\n\n\nName\nDescription\n\n\n\n\nmap\nThe \"map\" is a hashtable of \"key\" => \"value\" pairs.\n\n\n\n\nService\nnew Service(config)\n.tick() ⇒ Number\n.handler(message) ⇒ Service\n.route(msg) ⇒ Promise\n.start()\n._GET(path) ⇒ Promise\n._PUT(path, value, [commit]) ⇒ Promise\n.connect(notify) ⇒ Promise\n.send(channel, message) ⇒ Service\n._registerActor(actor) ⇒ Promise\n._send(message)\n\n\n\n\nnew Service(config)\nCreate an instance of a Service.\n\n\n\nParam\nType\nDefault\nDescription\n\n\n\n\nconfig\nObject\n\nConfiguration for this service.\n\n\n[config.networking]\nBoolean\ntrue\nWhether or not to connect to the network.\n\n\n[config.@data]\nObject\n\nInternal data to assign.\n\n\n\n\nservice.tick() ⇒ Number\nMove forward one clock cycle.\nKind: instance method of Service\nservice.handler(message) ⇒ Service\nDefault route handler for an incoming message.  Follows the Activity\nStreams 2.0 spec: https://www.w3.org/TR/activitystreams-core/\nKind: instance method of ServiceReturns: Service - Chainable method.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nmessage\nActivity\nMessage object.\n\n\n\n\nservice.route(msg) ⇒ Promise\nResolve a State from a particular Message object.\nKind: instance method of ServiceReturns: Promise - Resolves with resulting State.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nmsg\nMessage\nExplicit Fabric Message.\n\n\n\n\nservice.start()\nStart the service, including the initiation of an outbound connection\nto any peers designated in the service's configuration.\nKind: instance method of Service\nservice._GET(path) ⇒ Promise\nRetrieve a value from the Service's state.\nKind: instance method of ServiceReturns: Promise - Resolves with the result.  \n\n\n\nParam\nType\nDescription\n\n\n\n\npath\nString\nPath of the value to retrieve.\n\n\n\n\nservice._PUT(path, value, [commit]) ⇒ Promise\nStore a value in the Service's state.\nKind: instance method of ServiceReturns: Promise - Resolves with with stored document.  \n\n\n\nParam\nType\nDefault\nDescription\n\n\n\n\npath\nString\n\nPath to store the value at.\n\n\nvalue\nObject\n\nDocument to store.\n\n\n[commit]\nBoolean\nfalse\nSign the resulting state.\n\n\n\n\nservice.connect(notify) ⇒ Promise\nAttach to network.\nKind: instance method of ServiceReturns: Promise - Resolves to Fabric.  \n\n\n\nParam\nType\nDefault\nDescription\n\n\n\n\nnotify\nBoolean\ntrue\nCommit to changes.\n\n\n\n\nservice.send(channel, message) ⇒ Service\nSend a message to a channel.\nKind: instance method of ServiceReturns: Service - Chainable method.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nchannel\nString\nChannel name to which the message will be sent.\n\n\nmessage\nString\nContent of the message to send.\n\n\n\n\nservice._registerActor(actor) ⇒ Promise\nRegister an Actor with the Service.\nKind: instance method of ServiceReturns: Promise - Resolves upon successful registration.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nactor\nObject\nInstance of the Actor.\n\n\n\n\nservice._send(message)\nSends a message.\nKind: instance method of Service  \n\n\n\nParam\nType\nDescription\n\n\n\n\nmessage\nMixed\nMessage to send.\n\n\n\n\nSession\nThe Session type describes a connection between Peer\nobjects, and includes its own lifecycle.\nKind: global class  \n\nSession\nnew Session(settings)\n.start()\n.stop()\n\n\n\n\nnew Session(settings)\nCreates a new Session.\n\n\n\nParam\nType\n\n\n\n\nsettings\nObject\n\n\n\n\nsession.start()\nOpens the Session for interaction.\nKind: instance method of Session\nsession.stop()\nCloses the Session, preventing further interaction.\nKind: instance method of Session\nSnapshot\nA type of message to be expected from a Service.\nKind: global class  \n\nSnapshot\nnew Snapshot(settings)\n.commit()\n\n\n\n\nnew Snapshot(settings)\nCreates an instance of a Snapshot.\n\n\n\nParam\nType\nDescription\n\n\n\n\nsettings\nObject\nMap of settings to configure the Snapshot with.\n\n\n\n\nsnapshot.commit()\nRetrieves the sha256 fingerprint for the Snapshot state.\nKind: instance method of Snapshot\nStack\nManage stacks of data.\nKind: global class  \n\nStack\nnew Stack([list])\n.push(data) ⇒ Number\n\n\n\n\nnew Stack([list])\nCreate a Stack instance.\n\n\n\nParam\nType\nDefault\nDescription\n\n\n\n\n[list]\nArray\n[]\nGenesis state for the Stack instance.\n\n\n\n\nstack.push(data) ⇒ Number\nPush data onto the stack.  Changes the Stack#frame and\nStack#id.\nKind: instance method of StackReturns: Number - Resulting size of the stack.  \n\n\n\nParam\nType\nDescription\n\n\n\n\ndata\nMixed\nTreated as a State.\n\n\n\n\nState ⇐ EventEmitter\nThe State is the core of most User-facing interactions.  To\ninteract with the User, simply propose a change in the state by\ncommitting to the outcome.  This workflow keeps app design quite simple!\nKind: global classExtends: EventEmitterProperties\n\n\n\nName\nType\nDescription\n\n\n\n\nsize\nNumber\nSize of state in bytes.\n\n\n@buffer\nBuffer\nByte-for-byte memory representation of state.\n\n\n@type\nString\nNamed type.\n\n\n@data\nMixed\nLocal instance of the state.\n\n\n@id\nString\nUnique identifier for this data.\n\n\n\n\nState ⇐ EventEmitter\nnew State(data)\ninstance\n.id : Boolean\n.toString() ⇒ String\n.serialize([input]) ⇒ Buffer\n.deserialize(input) ⇒ State\n.fork() ⇒ State\n.get(path) ⇒ Mixed\n.set(path) ⇒ Mixed\n.commit()\n.render() ⇒ String\n\n\nstatic\n.fromJSON(input) ⇒ State\n\n\n\n\n\n\nnew State(data)\nCreates a snapshot of some information.\n\n\n\nParam\nType\nDescription\n\n\n\n\ndata\nMixed\nInput data.\n\n\n\n\nstate.id : Boolean\nIdentity function.\nKind: instance property of State\nstate.toString() ⇒ String\nUnmarshall an existing state to an instance of a Blob.\nKind: instance method of StateReturns: String - Serialized Blob.\nstate.serialize([input]) ⇒ Buffer\nConvert to Buffer.\nKind: instance method of StateReturns: Buffer - Store-able blob.  \n\n\n\nParam\nType\nDescription\n\n\n\n\n[input]\nMixed\nInput to serialize.\n\n\n\n\nstate.deserialize(input) ⇒ State\nTake a hex-encoded input and convert to a State object.\nKind: instance method of StateReturns: State - [description]  \n\n\n\nParam\nType\nDescription\n\n\n\n\ninput\nString\n[description]\n\n\n\n\nstate.fork() ⇒ State\nCreates a new child State, with @parent set to\nthe current State by immutable identifier.\nKind: instance method of State\nstate.get(path) ⇒ Mixed\nRetrieve a key from the State.\nKind: instance method of State  \n\n\n\nParam\nType\nDescription\n\n\n\n\npath\nPath\nKey to retrieve.\n\n\n\n\nstate.set(path) ⇒ Mixed\nSet a key in the State to a particular value.\nKind: instance method of State  \n\n\n\nParam\nType\nDescription\n\n\n\n\npath\nPath\nKey to retrieve.\n\n\n\n\nstate.commit()\nIncrement the vector clock, broadcast all changes as a transaction.\nKind: instance method of State\nstate.render() ⇒ String\nCompose a JSON string for network consumption.\nKind: instance method of StateReturns: String - JSON-encoded String.\nState.fromJSON(input) ⇒ State\nMarshall an input into an instance of a State.  States have\nabsolute authority over their own domain, so choose your States wisely.\nKind: static method of StateReturns: State - Resulting instance of the State.  \n\n\n\nParam\nType\nDescription\n\n\n\n\ninput\nString\nArbitrary input.\n\n\n\n\nStorage\nPersistent data storage.\nKind: global class\nnew Storage(config)\n\n\n\nParam\nType\nDescription\n\n\n\n\nconfig\nObject\nConfiguration for internal datastore.\n\n\n\n\nStore\nLong-term storage.\nKind: global classProperties\n\n\n\nName\nType\nDescription\n\n\n\n\nsettings\nMixed\nCurrent configuration.\n\n\n\n\nStore\nnew Store([settings])\n._REGISTER(obj) ⇒ Vector\n._POST(key, value) ⇒ Promise\n.get(key) ⇒ Promise\n.set(key, value)\n.trust(source) ⇒ Store\n.del(key)\n.flush()\n.start() ⇒ Promise\n\n\n\n\nnew Store([settings])\nCreate an instance of a Store to manage long-term storage, which is\nparticularly useful when building a user-facing Product.\n\n\n\nParam\nType\nDefault\nDescription\n\n\n\n\n[settings]\nObject\n{}\nconfiguration object.\n\n\n\n\nstore._REGISTER(obj) ⇒ Vector\nRegisters an Actor.  Necessary to store in a collection.\nKind: instance method of StoreReturns: Vector - Returned from storage.set  \n\n\n\nParam\nType\nDescription\n\n\n\n\nobj\nObject\nInstance of the object to store.\n\n\n\n\nstore._POST(key, value) ⇒ Promise\nInsert something into a collection.\nKind: instance method of StoreReturns: Promise - Resolves on success with a String pointer.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nkey\nString\nPath to add data to.\n\n\nvalue\nMixed\nObject to store.\n\n\n\n\nstore.get(key) ⇒ Promise\nBarebones getter.\nKind: instance method of StoreReturns: Promise - Resolves on complete.  null if not found.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nkey\nString\nName of data to retrieve.\n\n\n\n\nstore.set(key, value)\nSet a key to a specific value.\nKind: instance method of Store  \n\n\n\nParam\nType\nDescription\n\n\n\n\nkey\nString\nAddress of the information.\n\n\nvalue\nMixed\nContent to store at key.\n\n\n\n\nstore.trust(source) ⇒ Store\nImplicitly trust an Event source.\nKind: instance method of StoreReturns: Store - Resulting instance of Store with new trust.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nsource\nEventEmitter\nEvent-emitting source.\n\n\n\n\nstore.del(key)\nRemove a Value by Path.\nKind: instance method of Store  \n\n\n\nParam\nType\nDescription\n\n\n\n\nkey\nPath\nKey to remove.\n\n\n\n\nstore.flush()\nWipes the storage.\nKind: instance method of Store\nstore.start() ⇒ Promise\nStart running the process.\nKind: instance method of StoreReturns: Promise - Resolves on complete.\nSwap : Object\nThe Swap contract executes a set of transactions on two distinct\nChain components, utilizing a secret-reveal mechanism to atomically\nexecute either the full set or none.\nKind: global class  \n\nSwap : Object\nnew Swap([settings])\n.extractSecret(tx, address) ⇒ Mixed\n\n\n\n\nnew Swap([settings])\nAtomically execute a set of transactions across two Chain components.\n\n\n\nParam\nType\nDefault\nDescription\n\n\n\n\n[settings]\nObject\n{}\nConfiguration for the swap.\n\n\n\n\nswap.extractSecret(tx, address) ⇒ Mixed\nFind an input from the provided transaction which spends from the target\nP2SH address.\nKind: instance method of SwapReturns: Mixed - False on failure, secret value on success.  \n\n\n\nParam\nType\nDescription\n\n\n\n\ntx\nTransaction\nTransaction to iterate over.\n\n\naddress\nString\nP2SH address to search for.\n\n\n\n\nSwarm : String\nOrchestrates a network of peers.\nKind: global class  \n\nSwarm : String\nnew Swarm(config)\n.trust(source)\n.start() ⇒ Promise\n\n\n\n\nnew Swarm(config)\nCreate an instance of a Swarm.\n\n\n\nParam\nType\nDescription\n\n\n\n\nconfig\nObject\nConfiguration object.\n\n\n\n\nswarm.trust(source)\nExplicitly trust an EventEmitter to provide messages using\nthe expected Interface, providing Message objects as\nthe expected Type.\nKind: instance method of Swarm  \n\n\n\nParam\nType\nDescription\n\n\n\n\nsource\nEventEmitter\nActor to utilize.\n\n\n\n\nswarm.start() ⇒ Promise\nBegin computing.\nKind: instance method of SwarmReturns: Promise - Resolves to instance of Swarm.\nTransition\nThe Transition type reflects a change from one finite\nState to another.\nKind: global class\nnew Transition(settings)\n\n\n\nParam\nType\nDescription\n\n\n\n\nsettings\nObject\nConfiguration for the transition object.\n\n\n\n\nValue\nNumber-like type.\nKind: global class  \n\nValue\nnew Value(data)\n.value(input)\n\n\n\n\nnew Value(data)\nUse the Value type to interact with Number-like objects.\n\n\n\nParam\nType\nDescription\n\n\n\n\ndata\nMixed\nInput value.\n\n\n\n\nvalue.value(input)\nCompute the numeric representation of this input.\nKind: instance method of Value  \n\n\n\nParam\nType\nDescription\n\n\n\n\ninput\nString\nInput string to seek for value.\n\n\n\n\nVector\nKind: global class  \n\nVector\nnew Vector(origin)\n._serialize(input) ⇒ String\n.toString(input) ⇒ String\n\n\n\n\nnew Vector(origin)\nAn \"Initialization\" Vector.\n\n\n\nParam\nType\nDescription\n\n\n\n\norigin\nObject\nInput state (will map to @data.)\n\n\n\n\nvector._serialize(input) ⇒ String\n_serialize is a placeholder, should be discussed.\nKind: instance method of VectorReturns: String - - resulting string [JSON-encoded version of the local @data value.]  \n\n\n\nParam\nType\nDescription\n\n\n\n\ninput\nString\nWhat to serialize.  Defaults to this.state.\n\n\n\n\nvector.toString(input) ⇒ String\nRender the output to a String.\nKind: instance method of Vector  \n\n\n\nParam\nType\nDescription\n\n\n\n\ninput\nMixed\nArbitrary input.\n\n\n\n\nWalker\nKind: global class  \n\nWalker\nnew Walker(init)\n._explore(path, [map]) ⇒ Object\n._define(dir, [map]) ⇒ Object\n\n\n\n\nnew Walker(init)\nThe Walker explores a directory tree and maps it to memory.\n\n\n\nParam\nType\nDescription\n\n\n\n\ninit\nVector\nInitial state tree.\n\n\n\n\nwalker._explore(path, [map]) ⇒ Object\nExplores a directory tree on the local system's disk.\nKind: instance method of WalkerReturns: Object - [description]  \n\n\n\nParam\nType\nDefault\nDescription\n\n\n\n\npath\nString\n\n[description]\n\n\n[map]\nObject\n{}\n[description]\n\n\n\n\nwalker._define(dir, [map]) ⇒ Object\nExplores a directory tree on the local system's disk.\nKind: instance method of WalkerReturns: Object - A hashmap of directory contents.  \n\n\n\nParam\nType\nDefault\nDescription\n\n\n\n\ndir\nString\n\nPath to crawl on local disk.\n\n\n[map]\nObject\n{}\nPointer to previous step in stack.\n\n\n\n\nWallet : Object\nManage keys and track their balances.\nKind: global classProperties\n\n\n\nName\nType\nDescription\n\n\n\n\nid\nString\nUnique identifier for this Wallet.\n\n\n\n\nWallet : Object\nnew Wallet([settings])\n.getAddressForScript(script)\n.getAddressFromRedeemScript(redeemScript)\n.createPricedOrder(order)\n._sign(tx)\n._createCrowdfund(fund)\n._getSwapInputScript(redeemScript, secret)\n._getRefundInputScript(redeemScript)\n.publicKeyFromString(input)\n._load(settings)\n.start()\n\n\n\n\nnew Wallet([settings])\nCreate an instance of a Wallet.\n\n\n\nParam\nType\nDefault\nDescription\n\n\n\n\n[settings]\nObject\n{}\nConfigure the wallet.\n\n\n[settings.verbosity]\nNumber\n2\nOne of: 0 (none), 1 (error), 2 (warning), 3 (notice), 4 (debug), 5 (audit)\n\n\n[settings.key]\nObject\n\nKey to restore from.\n\n\n[settings.key.seed]\nString\n\nMnemonic seed for a restored wallet.\n\n\n\n\nwallet.getAddressForScript(script)\nReturns a bech32 address for the provided Script.\nKind: instance method of Wallet  \n\n\n\nParam\nType\n\n\n\n\nscript\nScript\n\n\n\n\nwallet.getAddressFromRedeemScript(redeemScript)\nGenerate a BitcoinAddress for the supplied BitcoinScript.\nKind: instance method of Wallet  \n\n\n\nParam\nType\n\n\n\n\nredeemScript\nBitcoinScript\n\n\n\n\nwallet.createPricedOrder(order)\nCreate a priced order.\nKind: instance method of Wallet  \n\n\n\nParam\nType\n\n\n\n\norder\nObject\n\n\norder.asset\nObject\n\n\norder.amount\nObject\n\n\n\n\nwallet._sign(tx)\nSigns a transaction with the keyring.\nKind: instance method of Wallet  \n\n\n\nParam\nType\n\n\n\n\ntx\nBcoinTX\n\n\n\n\nwallet._createCrowdfund(fund)\nCreate a crowdfunding transaction.\nKind: instance method of Wallet  \n\n\n\nParam\nType\n\n\n\n\nfund\nObject\n\n\n\n\nwallet._getSwapInputScript(redeemScript, secret)\nGenerate Script for claiming a Swap.\nKind: instance method of Wallet  \n\n\n\nParam\nType\n\n\n\n\nredeemScript\n*\n\n\nsecret\n*\n\n\n\n\nwallet._getRefundInputScript(redeemScript)\nGenerate Script for reclaiming funds commited to a Swap.\nKind: instance method of Wallet  \n\n\n\nParam\nType\n\n\n\n\nredeemScript\n*\n\n\n\n\nwallet.publicKeyFromString(input)\nCreate a public key from a string.\nKind: instance method of Wallet  \n\n\n\nParam\nType\nDescription\n\n\n\n\ninput\nString\nHex-encoded string to create key from.\n\n\n\n\nwallet._load(settings)\nInitialize the wallet, including keys and addresses.\nKind: instance method of Wallet  \n\n\n\nParam\nType\n\n\n\n\nsettings\nObject\n\n\n\n\nwallet.start()\nStart the wallet, including listening for transactions.\nKind: instance method of Wallet\nWorker\nWorkers are arbitrary containers for processing data.  They can be thought of\nalmost like \"threads\", as they run asynchronously over the duration of a\ncontract's lifetime as \"fulfillment conditions\" for its closure.\nKind: global class  \n\nWorker\nnew Worker(method)\n.compute(input) ⇒ String\n\n\n\n\nnew Worker(method)\n\n\n\nParam\nType\nDescription\n\n\n\n\nmethod\nfunction\nPure function.\n\n\n\n\nworker.compute(input) ⇒ String\nHandle a task.\nKind: instance method of WorkerReturns: String - Outcome of the requested job.  \n\n\n\nParam\nType\nDescription\n\n\n\n\ninput\nVector\nInput vector.\n\n\n\n\nExchange\nImplements a basic Exchange.\nKind: global class\nnew Exchange(settings)\nCreate an instance of the Exchange.  You may run two instances at\nonce to simulate two-party contracts, or use the Fabric Market to\nfind and trade with real peers.\n\n\n\nParam\nType\nDescription\n\n\n\n\nsettings\nObject\nMap of settings to values.\n\n\nsettings.fees\nObject\nMap of fee settings (all values in BTC).\n\n\nsettings.fees.minimum\nObject\nMinimum fee (satoshis).\n\n\n\n\nMatrix ⇐ Service\nService for interacting with Matrix.\nKind: global classExtends: Service  \n\nMatrix ⇐ Service\nnew Matrix([settings])\n.state\n._registerActor(actor)\n.start()\n.stop()\n.tick() ⇒ Number\n.handler(message) ⇒ Service\n.route(msg) ⇒ Promise\n._GET(path) ⇒ Promise\n._PUT(path, value, [commit]) ⇒ Promise\n.connect(notify) ⇒ Promise\n.send(channel, message) ⇒ Service\n._send(message)\n\n\n\n\nnew Matrix([settings])\nCreate an instance of a Matrix client, connect to the\nnetwork, and relay messages received from therein.\n\n\n\nParam\nType\nDescription\n\n\n\n\n[settings]\nObject\nConfiguration values.\n\n\n\n\nmatrix.state\nGetter for State.\nKind: instance property of Matrix\nmatrix._registerActor(actor)\nRegister an Actor on the network.\nKind: instance method of MatrixOverrides: _registerActor  \n\n\n\nParam\nType\nDescription\n\n\n\n\nactor\nObject\nActor to register.\n\n\nactor.pubkey\nObject\nHex-encoded pubkey.\n\n\n\n\nmatrix.start()\nStart the service, including the initiation of an outbound connection\nto any peers designated in the service's configuration.\nKind: instance method of MatrixOverrides: start\nmatrix.stop()\nStop the service.\nKind: instance method of Matrix\nmatrix.tick() ⇒ Number\nMove forward one clock cycle.\nKind: instance method of Matrix\nmatrix.handler(message) ⇒ Service\nDefault route handler for an incoming message.  Follows the Activity\nStreams 2.0 spec: https://www.w3.org/TR/activitystreams-core/\nKind: instance method of MatrixReturns: Service - Chainable method.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nmessage\nActivity\nMessage object.\n\n\n\n\nmatrix.route(msg) ⇒ Promise\nResolve a State from a particular Message object.\nKind: instance method of MatrixReturns: Promise - Resolves with resulting State.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nmsg\nMessage\nExplicit Fabric Message.\n\n\n\n\nmatrix._GET(path) ⇒ Promise\nRetrieve a value from the Service's state.\nKind: instance method of MatrixReturns: Promise - Resolves with the result.  \n\n\n\nParam\nType\nDescription\n\n\n\n\npath\nString\nPath of the value to retrieve.\n\n\n\n\nmatrix._PUT(path, value, [commit]) ⇒ Promise\nStore a value in the Service's state.\nKind: instance method of MatrixReturns: Promise - Resolves with with stored document.  \n\n\n\nParam\nType\nDefault\nDescription\n\n\n\n\npath\nString\n\nPath to store the value at.\n\n\nvalue\nObject\n\nDocument to store.\n\n\n[commit]\nBoolean\nfalse\nSign the resulting state.\n\n\n\n\nmatrix.connect(notify) ⇒ Promise\nAttach to network.\nKind: instance method of MatrixReturns: Promise - Resolves to Fabric.  \n\n\n\nParam\nType\nDefault\nDescription\n\n\n\n\nnotify\nBoolean\ntrue\nCommit to changes.\n\n\n\n\nmatrix.send(channel, message) ⇒ Service\nSend a message to a channel.\nKind: instance method of MatrixReturns: Service - Chainable method.  \n\n\n\nParam\nType\nDescription\n\n\n\n\nchannel\nString\nChannel name to which the message will be sent.\n\n\nmessage\nString\nContent of the message to send.\n\n\n\n\nmatrix._send(message)\nSends a message.\nKind: instance method of MatrixOverrides: _send  \n\n\n\nParam\nType\nDescription\n\n\n\n\nmessage\nMixed\nMessage to send.\n\n\n\n"},"DEVELOPERS.html":{"url":"DEVELOPERS.html","title":"🤯 Developer Guide","keywords":"","body":"Fabric Developer Resources\nThere's a lot of information to cover with regards to building decentralized\napplications, so grab a coffee ☕ and settle in.\nArchitecture\nFabric relies on Message objects passed between nodes to exchange information,\nlike transaction data and requests for computation (RFCs).\nActors\nThe Actor is the primary tool for interacting with Fabric. It uses the\nfamiliar JavaScript EventEmitter pattern:\nconst Actor = require('@fabric/core/types/actor');\nconst actor = new Actor();\n\nactor.on('message', (msg) => {\n  console.log('message from actor:', msg);\n});\n\nActors carry with them cryptographic signatures, accessible via the sign() method:\nconst Actor = require('@fabric/core/types/actor');\nconst actor = new Actor();\nconst signature = actor.sign().signature;\n\nMessages\nThe Message class provides a variety of message-formatting options.\nServices\nServices are special Actors which can be used to interact with various external\nnetworks.\nSee the Services Overview for more information.\n"},"SERVICES.html":{"url":"SERVICES.html","title":"🏦 Services Overview","keywords":"","body":"Fabric Services\n@fabric/core offers numerous Service implementations to provide basic\nOracle functionality to the network.  Requests made to Oracles can require\nBTC payments, allowing consumers to pay their providers for their services.\nList of Services\n\n@fabric/bitcoin\n@fabric/lightning\n@fabric/matrix\n\nQuick Start\nconst Bitcoin = require('@fabric/core/services/bitcoin');\nconst bitcoin = new Bitcoin();\n\nbitcoin.start();\n"},"whitepaper.html":{"url":"whitepaper.html","title":"📄 Whitepaper (latest)","keywords":"","body":"Fabric\nA Secure Compute Substrate for Self-Enforcing Contracts\nE. Martindale, J. Paul Morrison, J. Dilley\nReviewers: J. Paul Morrison, J. Dilley\n0.1.0-drafting\nWarning!\nThis document is a draft and has not received significant review. Implement these ideas at your own risk!\nAbstract\nWe introduce Fabric, a new protocol for securely establishing and executing peer-to-peer\nagreements surrounding the exchange of arbitrary information. Coupled with a resilient trust\nanchor, such as the Bitcoin blockchain, Fabric enables secure multi-party computations which\npreserve the privacy of their participants while retaining integrity across otherwise disparate\nnetworks.\nWe present a distributed messaging protocol as an alternative to the current client-server model of\nthe World Wide Web, instead implementing an \"information market\" for voluntary participants\nwhich agree upon a common point of reference. We further extend the document-oriented basis of\nthe Web with a cryptographically-secure version control system, enabling accurate and reliable\nupdates to applications which may require shared state.\n1. Introduction\nDespite the backdrop of a fundamentally free market, modern economies remain tightly\nconstrained by monopolies on contract enforcement. Recent developments in distributed systems\nhave offered reprieve from the requirements of these centralized services, but leave much to be\ndesired with regards to awareness & adoption. Significant capital investment has been made into\ninfrastructure which relies on these monopolies, creating momentum which further reinforces their\nauthority.\nAny approach to developing a privacy-preserving contract enforcement platform should operate\neffectively in adversarial environments, obviating the use of components which already reliably\nsolve this problem. One such system is the Bitcoin network, which secures & maintains a\ndistributed ledger by way of economic incentives. In this environment, fraud is expensive, allowing\nfor the accumulation of trust over time without requiring a central coordinator.\n1.1. Bitcoin\nBitcoin was introduced by Satoshi Nakamoto in 2008 as an to alternative fiat currency, and has\nsince garnered international attention as a catalyst for significant economic change. By replacing\nthe role of a central bank in the issuance of money, it sets the foundation for a new market\nstructure, one backed by thermodynamic assurances and cryptographic guarantees. These newly\navailable properties manifest a wide array of applications, but also serve to expand the availability\nof financial services to a global market.\nOne of Bitcoin's most interesting components is its blockchain, a highly replicated data structure\nwhich preserves a history for its consumers. Using Bitcoin's blockchain, we can reliably timestamp\ninformation and assert the existence of a document in a mathematically-provable fashion, all\nwithout revealing the contents of the document itself.\nBy relying on Bitcoin to address the challenges in achieving global consensus over a unified\nrecord of history, we can turn our attention to solving the problem of securely computing\nmeaningful results from encrypted information.\n1.1.1. Smart Contracts\nBitcoin also offers Script, a stack-based programming language for describing validation\nrequirements to as-of-yet unknown parties. Script offers a list of pre-defined instructions known as\n\"opcodes\", which can be composed into larger programs which may exhibit more complex\nbehavior. A typical Bitcoin script looks as follows:\nOP_DUP OP_HASH160  OP_EQUAL OP_CHECKSIG\nWhen combined with a digital signature, this small program can be used to construct a new\ntransaction which will be checked for validity by the network before being accepted as a \"spend\"\nof funds previously sent to the recipient. This enables a form of \"carry-forward\" state management,\nwhere changes to global state are only accepted by the network upon the provision of a valid\nproof.\nAs Script does not offer the ability to iterate over arbitrary collections, it lends itself easily to highvolume finite-state computations with predictable costs and behaviors. These properties are\nconvenient for efficiently validating monetary transactions, which allows for a separation of\nconcerns when building more complex applications.\n1.1.1.1. Multi-Signature Transactions\nOne of Script's most powerful features is its ability to lock funds into smart contracts which can\nonly become spendable when signed by a specific group of parties in a pre-defined subset. While\nBitcoin's implementation leaves much to be desired (limited in size of the participating group,\nsome bugs are also preserved intentionally to maintain compatibility with legacy implementations).\n1.1.1.2. Hash Time-Locked Transactions\nIn addition to simple transfers, smart contracts deployed to the Bitcoin network may be invalid until\nsome future date using a mechanism known as Hash Time-Locked Transactions, or HTLCs.\nThese specially-crafted transactions can be used to construct simple logic trees dependent upon\nnetwork state, such as offering a \"failover\" mode for funds not spent by a particular date. One such\nexample:\n OP_CHECKLOCKTIMEVERIFY OP_IF\n OP_EQUALVERIFY\nOP_ELSE\n OP_EQUALVERIFY\nOP_ENDIF\nOP_CHECKSIG\nThis program allows a payment to be returned to its sender after 1008 blocks, or roughly 1 week\nassuming Bitcoin continues to operation normally. Combined with other features of the Script\nlanguage, this becomes an incredibly powerful tool for building complex decision trees which are\ndependent upon information outside of the control of the originator.\n1.1.1.3: Zero-Knowledge Contingent Payments\nScript further offers the ability to compute simple hashes in the form of the OP_SHA256 opcode,\nwhich eponymously produces the SHA256 digest of some input data. By combining this with other\nelements, we can construct a powerful form of smart contract known as a \"Zero-Knowledge\nContingent Payment\", or ZKCP.\nThis tool enables a buyer to publish an order for an arbitrary asset, including documents and other\ninformation, without knowing the seller ahead of time. Any seller with access to the desired\ninformation may construct a new transaction which fulfills the order by revealing the document to\nthe buyer. Such a contract might appear as follows:\nOP_SHA256\n OP_EQUAL\nOP_IF\n\nOP_ELSE\n OP_CHECKLOCKTIMEVERIFY OP_DROP\n\nOP_ENDIF\nOP_CHECKSIG\nThis program returns funds to the buyer after a specified number of blocks (again, roughly one\nweek), but allows a seller to redeem the funds by supplying the document as the RedeemScript\n(not provided) before executing the contract.\n1.1.2. Limitations\nScript, and Bitcoin at large, contain several limititations which deserve further improvement. For\nexample, limited capability for manipulating data is provided by Script, which has historically\nrestricted the growth of chain storage requirements, but makes the construction of useful data\ndifficult. Future improvements have been discussed with regards to enabling these behaviors, but\nfurther research is required before safely enabling these changes on the main Bitcoin network\nwithout endangering user funds.\nFor simplicity's sake, we restrict our scope to applications which can run on the Bitcoin network\ntoday.\n1.2: Homomorphic Encryption\nCryptographers have long been excited about the prospect of computing over encrypted\ninformation, which has widespread implications surrounding data privacy and information security.\nKnown as \"homomorphic\" encryption, programs implementing these schemes never have to\ndecrypt application state, allowing for the participation of untrusted parties in untrusted systems.\nOne of Fabric's applications is to implement Fully Homomorphic Encryption, or FHE, so first we\nprovide some background on the math.\n1.2.1: Pallier Systems\nOne basic composition which provides useful functionality is the Paillier cryptosystem, introduce\nby Pascal Paillier in 1999. This probabilistic method offers addition and multiplication of hidden\nvalues, returning sums and products respectively without revealing their values.\n1.2.2: Partially Homomorphic Encryption\nTODO\n1.2.3: Fully Homomorphic Encryption\nIn addition to the general schemes above, an algorithm which can compute arbitrary functions is\nknown as a Fully Homomorphic Encryption scheme, or FHE. As these systems do not require\n1.3: Multi-Party Computations\nFabric aims to provide data security across a fully decentralized network, that is, one without any\nrequisite third party. As participants in such a network are not necessarily favorable actors, a\nstrategy to protect data while simultaneously allowing for computations on said data is necessary\nfor such a system to be viable.\nWe build on Baum's work on secure computations, taking advantage of recent advances to extend\nexisting models to include n-party computations. Specifically, we utilize a hierarchical secure\nmulti-party computation, which splits our network into a hierarchy of equally-sized MPCs which\nare then used in sum to compute the finalized output. As these units are completely independent,\nwe can parallelize the work at each level of the hierarchy.\nTraditional software programs are composed as a list of instructions which are typically executed\nin single-machine, single-process environments. Workloads in these environments typically do not\nscale beyond the resources available to single machines, roughly 4GB for 32-bit architectures and\notherwise prohibitively expensive for average users at scales beyond 32GB.\nOne approach to tackling this problem is to divide complex programs into smaller components,\nwhich is useful for workloads which do not require extensive iteration over large quantities of data.\nFabric adopts this philosophy, requiring that programs be implemented as pure functions, wherein\na single input is passed to the program, some computation is performed, and a singular output\nprovided as the return value.\nFabric's computational model can be described in the following context:\nƒ(x) ⇒ Δx'\nWhere some program ƒ produces an output equivalent to the delta between input x and\nresulting state x' .\nIn a technique known as function composition, complex behaviors can be described using\nsimple primitives, a core tenet of the UNIX philosophy.\nAn Example\nSuppose some set of participants P each have a collection of private documents D, with\n1.3.1: Simple Circuits\n1.3.2: Polynomial Circuits\n1.4: Market Dynamics\nParticipants in a Fabric-speaking network may compete for contracts, earning digital currency in\nexchange for processing \"work orders\" made available to them through the peer-to-peer network.\nIncluded is a simple programming language for the construction of deterministic, formallyverifiable smart contracts, which are then broadcast to network participants for execution.\n1.4.1: Information Asymmetry\n2: Architecture\nOrders in the Fabric network are effectively \"requests for computation\": cryptographic\ncommitments to payment, known as a [Zero-Knowledge Contingent Payment][zkcp], in exchange\nfor the output of a requested program. When the required computation is complete, the fulfilling\nparty is able to claim the payment in the network — represented as an unspent transaction output\nto be later broadcast on the anchor chain.\nContracts requiring secure execution may be divided into smaller sub-programs, broadcast to the\nnetwork as discrete instructions, and later re-composed into a finalized output. In this way, Fabric\nimplements secure, multi-party computations for general-purpose programs, allowing for a wide\nrange of privacy-protecting applications.\nFigure 1: an overview of process flow in Fabric\nFabric Architecture Overview\nLayer 2\nLayer 3\nblock n block n+1 block n+2 ...\nL1: Trust Anchor (the Bitcoin Blockchain)\nblock n block n+1 block n+2 ...\nL2: Domain-Specific Sidechain (RSK, Drivechain, etc.)\nHTLC 0 HTLC+1 HTLC+2 ...\nL2: Lightning\nφ0 φ1 φ2 φ3 φ3 φ...\nroot n root n+1 root n+2\nL3: State Bubble\nφ0 φ1 φ2 φ3 φ3 φ...\nroot n root n+1 root n+2\nL3: State Bubble (...)\nCharlie David Eve Frank ...\nWorkers\nloop\nDefinitions:\nARC: Application Resource Contract — source code for\nCAN: Content-Addressable Network — long-term storage for documents indexed by their\nhash\n2.1: Network Topology\n2.2: Encryption\nTo preserve user privacy, all connections are encrypted after an initial handshake using an\nephemeral key which rotates on a per-message basis. While we do not detail the encryption\nprotocol in this paper, the Noise Protocol can be used as a reference implementation.\n3: Protocol\n3.1: Primitives\n3.1.1: Channels\nChannels are duplex communication streams between objects in Fabric. They are exposed to the\nuser as Subscriptions, as channels typically involve an exchange of value.\n3.1.1.1: Mechanics\nFollowing a Channel creates a Subscription object, which contains a commitment to the\ncontract specified in the Channel . At any point in time, the signatory for the Channel may \"settle\"\nthe contract, claiming the funds agreed upon as per the series of events (Operations) sent across\nthe Channel .\nSimilarly, the subscriber (creator of the Subscription object) may settle the contract at any time,\nclosing out any further agreements by broadcasting the latest commitment to the channel.\nA simple algorithm is proposed for computing trust between peers, using quadratic expansion to\ncompose a stable network over long periods of time.\n3.2: Message Semantics\nThe definition of our messaging language is intended to human-readable, as debugging\ndistributed systems is notoriously difficult. All logs are stored unencrypted, as they should be\nthrown away within a reasonable timeframe as disk utilization remains in high demand (see § 8:\nEconomics)\n3.3: Message Ordering\n3.3.1: Phase 0: Bonding\n3.3.2: Phase 1: Initialization\n3.3.3: Phase 2: Order Construction\n3.3.4: Phase 3: Order Publishing\n3.3.5: Phase 4: Order Fulfillment\n3.3.5.1: Contract Execution\n3.3.5.2: Complex Contracts\n3.3.5.3: External Resources\n3.3.5.4: Failure Modes\n3.3.5.4.1: Timeout\n3.3.5.4.2: Fraud\n3.3.5.4.3: State Collapse\n3.3.5.4.4: Chain Re-organization\n3.3.6: Phase 5: Contract Finality\n3.4: State Machine\nAs all programs in Fabric are modeled as finite-state graphs, the Fabric State Machine (FSM)\n3.4.4: Visualizer\nDirected graphs such as Fabric's computational model can easily be rep\n3.4.5: Flow-Based Programming\nOriginally invented by J. Paul Morrison\n4: Language\nFabric utilizes a simple syntax for denoting program behavior, named \"Purity\".\napplication example { # `application` with parameter `example`\n  start 0 # call `start` with parameter `0`\n  add example # call `add` with parameter `example`\n}\nThe above program represents a simple addition function, with syntactic sugar added for\nfamiliarity. Curly braces are optional, but indentation must be used within definitions. More simply:\napplication example\n  start 0\n  add example\nRunning the above program is as follows:\n⚡ example 1\nRunning [8ee89711330c1ccf39a2e65ad12bbd7df4a4a2ee857f53b4823f00fecb7bd252]…\nΔ 1\nAs expected, the primitive identify function 1 returns itself, 1 . Let's try adding two numbers.\n⚡ example example 1\nRunning [1b5879d683819f2a623049e9d0e4bd954d9f228da000d2774f58652af1f3c882]…\nΔ 2\nGreat! We've incremented an integer. You might notice that the middle line has also changed —\nFabric identifies all programs by the hash of their source code.\ncontract {\n  // identity\n  function identity (a) ⇒ a\n  // unit\n  function unit ⇒ start! // behavior needs to be defined\n  // compositions\n  function compose (a b) ⇒ a & b\n  // products\n  function pair (a b) ⇒ [a b]\n  function take (unit a b) ⇒ a\n  function drop (unit a b) ⇒ b\n  // sums\n  function injl (a b) ⇒ b | c\n  function injr (a b) ⇒ a | c\n  function case (a b) ⇒ 1 | 0\n}\n5: Components\n6: Security\n7: Scalability\nAs signatures are aggregated into fixed-size\n8: Economics\nResources are scarce. Incentives in Fabric are aligned such that resources are maximally utilized,\nproviding monetary value in exchange for meaningful work.\nNetwork capacity including processing power, random-access memory, long-term storage, and\nvarious highly-specialized services is by definition unknowable, but all participants are rewarded\nfor efficient utilization of their available resources.\n8.1 Routing\nFabric leverages these market economics to encourage a healthy network topology, rewarding\nparticipants for detecting and repairing inefficient routes.\n9: Drawbacks\nExisting platforms have gained varying degrees of traction, fragmenting attention across a number\nof disparate initiatives. Any such system can only function effectively at scale, so it is likely that a\nlower bounds exists for a desired security threshold.\n10: Applications\n10.1: Example RPG\nAn Example ARC\nMPC (Layer 2)\nARC (Layer 3)\nTrust Anchor (Layer 1)\n/users\n/assets\n1000 SAT\n/items\nCREATE { id }\n/transactions\n100.00 INK (100 @ 1)\nto: /universes/{id}\n/instances\nISSUE { id: '/items{id}' }\n/players\nBUY /items/{id} (1.00 INK)\nPUBLISH { id }\nAn Example ARC\nMPC (Layer 2)\nARC (Layer 3)\nTrust Anchor (Layer 1)\n/users\n/assets\n1000 SAT\n/items\nCREATE { id }\n/transactions\n100.00 INK (100 @ 1)\nto: /universes/{id}\n/instances\nISSUE { id: '/items{id}' }\n/players\nBUY /items/{id} (1.00 INK)\nPUBLISH { id }\napplication RPG {\n\"/users\" ⇒ \"/assets\" [label=\"1000 SAT\"]\n\"/items\" ⇒ \"/transactions\" [label=\" 100.00 INK (100 @ 1)\\nto: /universes/{id}\"]\n\"/users\" ⇒ \"/items\" [label=\" CREATE { id }\"]\n\"/items\" ⇒ \"/instances\" [label=\" ISSUE { id: '/items{id}' }\"]\n\"/instances\" ⇒ \"/players\" [label=\" BUY /items/{id} (1.00 INK)\"]\n\"/players\" ⇒ \"/transactions\" [label=\" PUBLISH { id }\"]\nsubgraph cluster_mpc {\nlabel = \"MPC (Layer 2)\"\n\"/assets\"\n\"/items\"\n}\nsubgraph cluster_arc {\nlabel = \"ARC (Layer 3)\"\n\"/instances\"\n\"/players\"\n\"/transactions\"\n}\nsubgraph cluster_anchor {\nlabel = \"Trust Anchor (Layer 1)\"\n\"/users\"\n}\n}\n11: Future Work\n12: Conclusion\nFabric implements a peer-to-peer network over which participants may define arbitrary types,\ncompose them into more complex programs, and provide meaningful services to users — all\nwithout requiring a trusted third party. Rather than relying on a server, applications deployed to\nFabric are \"offline first\", allowing them to operate independent of network availability or\nconsensus.\nAppendix A: Ephemera\nIn contrast with other networks, Fabric does not require network consensus or otherwise .\nConsumers of Fabric applications maintain explicit control over the content they consume, and,\ninstead of being forced to form a quorum with their peers, may in fact deliver value to the network\nby sharing their content moderation decisions in exchange for subscriber subsidies.\nWe introduce this emergent concept as a \"Fuzzchain\", where there is no single source of \"truth\",\ninstead being replaced by a more individually-oriented \"perspective\" of truth. In aggregate, these\ntruths become quite \"fuzzy\", requiring a specific frame of reference to discern a relative truth.\nFabric facilitates this value exchange by using cryptographic tokens, which provide a medium of\nexchange that is free of outside influence or external requirements.\nBitcoin\nThe emergence of Bitcoin, a new peer-to-peer digital cash system in 2008 by Satoshi Nakamoto,\ncatalyzed the development of what is now a burgeoning industry surrounding digital payments,\nidentity, and information security. Fabric would not be possible without a reliable, independentlysecured value token, and Bitcoin has to date achieve the widest success [cite: network size] and\ngreatest security [cite: hash power] in this field. For this reason, we explicitly select the Bitcoin as\nthe bond that secures all Fabric contracts.\nBitcoin works by enforcing a quorum of majority rule, whereby voting on the state of a shared\ndatabase takes place in the form of a \"proof of work\". To vote on the consensus is to provide\ncomputational capacity towards the security of the network, expending energy to complete proofs\nin exchange for the minting of new value tokens, known as \"bitcoins\", which ostensibly represent\nthe amount of energy spent in their creation.\nThis clever arrangement of incentives allows for the implementation of a triple-entry accounting\nsystem, wherein changes to the ledger must be broadcast publicly to the entire network and are\nsubsequently independently verified for correctness by every participant before being relayed to\nthe next. Once a modification has been verified, it can then move to a second phase, the \"commit\",\nwhereby it and other currently outstanding transactions are appended in a new \"page\" to the\nledger, known as a \"block\". This is isomorphic to the two-phase commit introduced by J. Gray\n[Gray78] in 1978.\nWith the addition of proof of work, Bitcoin presents a security profile reasonably defensible against\noutside parties, arranging a set of incentive mechanisms that ensure fair participation while\nkeeping it reasonably secure against irrational or outright malicious participants. We find that the\nBitcoin network demonstrates the principle that security of a network is directly correlated with the\ndecentralization of the network, and also that the security of a network is function of its size [cite:\naltcoin failures]. Fabric requires such a system, and cannot provide provable fairness without it.\nInformation Markets\nFundamentally, Fabric aims to facilitate an information market. By addressing content across the\nnetwork, and furthermore positively identifying it by utilizing cryptographic hashes, we can\nconstruct a market for information with the addition of an intrinsic payment mechanism. Actors\nparticipating in this market can independently price the delivery of the data, and consumers of\nthese information bundles can independently choose which data provider they'd like to retrieve the\ndata from.\nWe can think of Fabric in economic terms as a clearing house for computational resources,\nwherein contracts (termed \"Service Contracts\") are broadcast and claimed by individual actors on\nthe network. These contracts can have varying levels of complexity, and are paid for by the\nconsumers most interested in their results.\nPayments between nodes on the network are made using the Bitcoin network, specifically using a\nspecial construction of transactions termed \"duplex payment channels\". This allows for a zero-risk\ncommitment of monetary value, in addition to offering an extremely high rate of change – to be\nbroadcast and committed to the Bitcoin transaction only once, at the end of a peer session (or\nlonger).\nProvable Fairness\nprinciple of isolation\nperfect hashing (uniformity guarantees)\nBitcoin works by establishing a linked list of finalized pages, known as \"blocks\", in a distributed\nledger, the \"blockchain\". Actors within the network perform a resource-intensive operation in\ncompetition with one another to derive newly-minted tokens, known as \"bitcoins\", in an operation\nthat is difficult to duplicate, but trivial to verify. The allocation of new tokens in this system is\nknown as the \"block subsidy\", and it is the incentive mechanism by which outside parties are\nrewarded for providing the network with security through their efforts.\nThe Semantic Web\nTimothy Berners-Lee introduced the idea of hypertext in 198~ [citation needed]. With it came the\npromise of a new era of context in the blossoming world of interconnected networks. Other, similar\nideas emerged at roughly the same time, including Project Xanadu and ??? [citation needed].\nWith the introduction of XMLHTTPRequest by Microsoft in ??? [citation needed], the doors to a\nnew era of the Web opened as new, interesting, and compelling use-cases became possible like\nnever before. A new wave of dynamic \"shell\" applications that had the ability to modify documents\nafter they had been retrieved emerged, including Twitter, MySpace, Friendster [???] [citation\nneeded]. However, these applications very quickly became isolated silos with barely-working\ninterfaces for integration, as their proprietary bundles of application-specific code had finite, acute\nfocii.\nA resurgent effort to restore the interoperability provided by purely semantic markup languages\nsuch as HTML gave birth to initiatives such as Microformats and later Schema.org [citation\nneeded], but the overhead of their implementations gave too much resistance to their adoption.\nArchitecture\nTrust Model\nUsers of the Fabric protocol are expected to share a trust anchor with their direct peers, which in\nmost cases will be the Bitcoin blockchain. Other systems can be used should both parties trust the\nsame entity, but our work has determined Bitcoin to be the most secure and likely to succeed over\ntime. On the other end of the spectrum, models may be constructed which require the trust of a\ncentralized Oracle, but for our purposes we assume all market participants maintain an up-to-date\ncopy of the Bitcoin blockchain.\nFabric relies the Zero Knowledge Contingent Payment (\"ZKCP\") approach used by Gregory\nMaxwell et al to trustlessly purchase the solution to a Sudoku Puzzle, the first public\ndemonstration of such a transaction using the Bitcoin protocol.\nExample ZKCP\nOP_SHA256  OP_EQUAL OP_IF\n\nOP_ELSE\n OP_CHECKLOCKTIMEVERIFY OP_DROP\n\nOPENDIF\nOP_CHECKSIG\nMessaging\nAlan Kay introduced the idea of messaging .... Today we observe many derivatives of this model,\nincluding that of the Actor Model citation needed.\nA messaging system provides .... It does not, however, provide any mechanism for ordering. This\nis desirable when developing asynchronous systems. However, for conflict resolution, one might\nwant to identify which particular message came first. This leaves us with the timestamping\nproblem.\nProtocol\nThe Fabric protocol implements a mechanism for representing a largely intangible idea, trust, as a\npre-established commitment in a slightly more tangible fashion, a value token. If a network is\ncomposed primarily of honest, friendly nodes, then commitments increase over time until the\nupdates provided by the network cease to be valuable. Should a node cease being honest, it\ndestroys its ability to increase in value over time.\nSecurity\nContract Signatures\nTransactions as Functions\nGiven a transaction set _t, there should also be a correlating inverse transaction set t^-1 such\nthat the state of a database prior to the application of t can be completely derived after its\napplication by applying t^-1.\nFurther, individual patchsets, should be composable functions, with equivalent inverse functions.\nFuzzchains (WIP)\nSince the constraint of a finite limit on information (such as a limit on token supply) is not present\nin an information market, new information can be introduced at any time, To implement a\ndistributed datastore on a peer-to-peer basis without compromising the freedom of speech of any\nindividual node, we must remove the constraint of consensus from the network.\nWithout a need to enforce the availability of specific transaction sets, we can derive a new type of\nblockchain we term a \"fuzzchain\". This fuzzchain allows for many divergent sequences of chains,\nwhich may or may not be in conflict at any point in time.\nMulti-Party Computations\nApplications\nThe application layer of Fabric is the implementation of the underlying Resource contract. We\nprovide Maki, a reference implementation of the Application Resource Contracts (ARC) protocol,\nResources\nFabric's\nSemantic Linkability\nSince Fabric exposes Resources in a descriptive fashion, programs deplo can discover and\ninteract with one another. By requesting a resource from a namespace other than one's own,\ninformation can cross the boundaries of individual applications and other interesting combinations\nof data can be constructed.\nFurthermore, since applications can be described in their entirety with a simple contract,\napplications can discover one anothers' behaviors and resource definitions. This can be used to\nbuild various forms of semantic interoperability, potentially including new forms of search engine\nbehaviors.\nTwo-Way Links on the Web\nAn Introduction to Channels\nThe Web we know today is built on a simple construct: the  tag. In HTML, the a stands for\nanchor — a point of reference, or hyperlink.\nUsing these hyperlinks, we've been able to navigate content published on the web contextually —\nthat is to say, we can choose to dig deeper into a \"linked\" subject based on the context provided.\nThis has proven helpful to the curious explorer, as the Web opened up the wealth of human\nknowledge to a greater extent than ever before.\nBut what of the two-way conversation? How can a reader submit an improvement to the author's\ncontent in a meaningful way? How can a publisher expect to be notified of reader feedback, in\ncomment form or even a proposal? How can we collaborate on content constructively?\nMutations\nOnce an application's underlying Resources are defined, their state can be manipulated in an\natomic fashion. Arbitrary rules can be defined about the validity of a mutation, including various\nauthorization models.\nMutation Blocks\nFabric, in contrast to traditional proof-of-work mechanisms, does not require work to be bundled\ninto \"blocks\". Instead, consensus is achieved through the bundling of atomic mutations to the\nchain state. These atomic operations are rolled up into groupings called, perhaps inconveniently,\n\"transactions\". These transactions are isomorphic to traditional blockchain transactions, in that\neither a block is valid or it is not, as determined by the component operations it contains. If any\none operation is invalid, so too must be the block.\nYao, Andrew C. ”Protocols for secure computations.” 2013 IEEE 54th Annual Symposium on\nFoundations of Computer Science. IEEE, 1982.\nBaum, Carsten, Ivan Damgrd, and Claudio Orlandi. ”Publicly auditable secure multi-party\ncomputation.” Security and Cryptography for Networks. Springer International Publishing,\n\n175-196.\nCohen, Gil, et al. ”Efficient multiparty protocols via log-depth threshold formulae.” Advances\nin CryptologyCRYPTO 2013. Springer Berlin Heidelberg, 2013. 185-202.\nGuy Zyskind, Oz Nathan, Alex ’Sandy’ Pentland. \"Enigma: Decentralized Computation\nPlatform with Guaranteed Privacy\" MIT\n\nTODO: include content hashes of links as they appear at\ndocument compilation time.\nOTHER CITATIONS TO INCLUDE: [bitcoin]: http://bitcoin.org/bitcoin.pdf [capability-based\nsystems]: ??? [capability-based financial systems]:\nhttp://www.cypherpunks.to/erights/elib/capability/ode/ode.pdf\n"},"whitepaper-2015.html":{"url":"whitepaper-2015.html","title":"📃 Whitepaper (2015)","keywords":"","body":"Fabric\nAbstract\nWe present a novel approach to building general-purpose \"computation markets\", in which users\nare able to deploy complex programs for blinded execution by a network of peers,\nwhich lay claim to digital currency bonded in the initial request for\ncomputation.  Our design defers consensus on global state to an underlying trust\nanchor, particularly the Nakamoto Consensus surrounding Bitcoin's blockchain.\nIntroduction\nRecent advances in Fully-Homomorphic Encryption (FHE) have reduced computational\nrequirements to a domain in which real-world users may find tolerable, in the\nrange of 30 seconds to two minutes for small, well-defined programs.  Two primary\napproaches exist, Yao's garbled circuits model^[citation needed] and an array of\nsecret-sharing designs, but Fabric's design relies on Yao's model for Secure\nMulti-Party Computations, or SMPC.\nBackground\nBitcoin\nIn 2008, Satoshi Nakamoto crystallized a solution to the Byzantine General's\nProblem in the form of Nakamoto Consensus, which is most famously utilized as\npart of Bitcoin's consensus mechanism.  Launching publicly in 2009, Bitcoin has\ngone on to become the world's most reknown distributed system.\nSmart Contracts\nBitcoin leverages the concept of a self-executing agreement known as a Smart\nContract, a term coined by Nick Szabo in 2001^[citation needed].  While Bitcoin\nhas encountered many upstart alternatives, it remains dominant in the market as\nof the time of writing, indicating it has the highest likelihood of success\naccording to the Lindy Effect^[citation needed].\nPayment Channels\nA Payment Channel is a special arrangement between two Bitcoin users, who construct\na special form of smart contract which applies additional constraints to the funds\nlocked up in the contract, but allows the pair to perform large volumes of transactions\nwithout generating additional on-chain overhead.\nAtomic Cross-Chain Transactions\nAnother interesting use of Bitcoin's smart contracting capability is the hash-lock,\nwhich can add the additional constraint on a Bitcoin transaction to require a\npre-selected secret to be revealed in order to claim funds.  When off-chain\ncoordination is utilized, peers can leverage this tool to construct multi-chain\ntransactions, which either happen all at once or not at all (thus the \"atomic\"\ndescription).\nPotential Networks\nTo measure the potential along any one particular path, one first calculates the\nrisk for each edge by measuring the probability of reversal, then multiplying it\nby the balance of channel (positive or negative).  Once all routes have been\ncomputed, a simple sum along any route is sufficient to rank paths by potential\nvalue, allowing any peer to verify the correct execution of a contract by\nperforming the sort themselves and checking the order of the resulting elements.\nLet's take a simple example where Alice would like to pay the network to compute\nthe n_th fibonacci number.  Alice first composes her verifier program, which takes\nsome inputs _x and y and produces some boolean value B as to whether x is\nat position y in the fibonacci sequence.\nApproach\nMinimized Trust Requirements\nAssumptions\nCryptographic\nComputational\nConsensus\nComponents\nLayer 1: Consensus on Global State\nFabric relies on Bitcoin's blockchain to establish consensus on a shared, global\nstate, namely the monetary capital used in a Fabric-speaking network.  Using this\nexternal conflict resolution mechanism, we can build smaller, more specialized\nnetworks without additionally having to implement our own consensus algorithm.\nLayer 2: Peering & Payments\nRequests for computation are small operations, typically a single application of\na polynomial function to a known prior state.  As even the simplest of programs is\noften composed from hundreds of thousands of such operations, requiring space in a\nglobally-distributed database for every transaction would rapidly become prohibitively\nexpensive.  As such, Fabric relies on a network of deeply-embedded payment channels at\nLayer 2, not dissimilar from the Lightning Network or our earlier work on Impulse.\nEach peering relationship has three primary components; the bonding commitment, the\nsecret preimage, and the counterparty.  A typical peer lifecycle might look as\nfollows:\n\nUser commits funds to a time-locked contract (the bonding commitment)\nUser establishes a peering relationship with the network (the counterparty)\nUser generates some secret preimage, \n\nLayer 3: Execution\nBitcoin\nThe emergence of Bitcoin, a new peer-to-peer digital cash system in 2008 by\nSatoshi Nakamoto, catalyzed the development of what is now a burgeoning industry\nsurrounding digital payments, identity, and information security.  Fabric would\nnot be possible without a reliable, independently-secured value token, and\nBitcoin has to date achieve the widest success [cite: network size] and greatest\nsecurity [cite: hash power] in this field.  For this reason, we explicitly\nselect the Bitcoin as the bond that secures all Fabric contracts.\nBitcoin works by enforcing a quorum of majority rule, whereby voting on the\nstate of a shared database takes place in the form of a \"proof of work\".  To\nvote on the consensus is to provide computational capacity towards the security\nof the network, expending energy to complete proofs in exchange for the minting\nof new value tokens, known as \"bitcoins\", which ostensibly represent the amount\nof energy spent in their creation.\nThis clever arrangement of incentives allows for the implementation of a\ntriple-entry accounting system, wherein changes to the ledger must be broadcast\npublicly to the entire network and are subsequently independently verified for\ncorrectness by every participant before being relayed to the next.  Once a\nmodification has been verified, it can then move to a second phase, the\n\"commit\", whereby it and other currently outstanding transactions are appended\nin a new \"page\" to the ledger, known as a \"block\".  This is isomorphic to the\ntwo-phase commit introduced by J. Gray [Gray78] in 1978.\nWith the addition of proof of work, Bitcoin presents a security profile\nreasonably defensible against outside parties, arranging a set of incentive\nmechanisms that ensure fair participation while keeping it reasonably secure\nagainst irrational or outright malicious participants.  We find that the Bitcoin\nnetwork demonstrates the principle that security of a network is directly\ncorrelated with the decentralization of the network, and also that the security\nof a network is function of its size [cite: altcoin failures].  Fabric requires\nsuch a system, and cannot provide provable fairness without it.\nInformation Markets\nFundamentally, Fabric aims to facilitate an information market.  By addressing\ncontent across the network, and furthermore positively identifying it by\nutilizing cryptographic hashes, we can construct a market for information with\nthe addition of an intrinsic payment mechanism. Actors participating in this\nmarket can independently price the delivery of the data, and consumers of these\ninformation bundles can independently choose which data provider they'd like to\nretrieve the data from.\nWe can think of Fabric in economic terms as a clearing house for computational\nresources, wherein contracts (termed \"Service Contracts\") are broadcast and\nclaimed by individual actors on the network.  These contracts can have varying\nlevels of complexity, and are paid for by the consumers most interested in their\nresults.\nPayments between nodes on the network are made using the Bitcoin network,\nspecifically using a special construction of transactions termed \"duplex payment\nchannels\".  This allows for a zero-risk commitment of monetary value, in\naddition to offering an extremely high rate of change – to be broadcast and\ncommitted to the Bitcoin transaction only once, at the end of a peer session (or\nlonger).\nProvable Fairness\n\nprinciple of isolation\nperfect hashing (uniformity guarantees)\n\nBitcoin works by establishing a linked list of finalized pages, known as\n\"blocks\", in a distributed ledger, the \"blockchain\".  Actors within the network\nperform a resource-intensive operation in competition with one another to\nderive newly-minted tokens, known as \"bitcoins\", in an operation that is\ndifficult to duplicate, but trivial to verify.  The allocation of new tokens in\nthis system is known as the \"block subsidy\", and it is the incentive mechanism\nby which outside parties are rewarded for providing the network with security\nthrough their efforts.\nThe Semantic Web\nTimothy Berners-Lee introduced the idea of hypertext in 198~ [citation needed].\nWith it came the promise of a new era of context in the blossoming world of\ninterconnected networks.  Other, similar ideas emerged at roughly the same time,\nincluding Project Xanadu and ??? [citation needed].\nWith the introduction of XMLHTTPRequest by Microsoft in ??? [citation needed],\nthe doors to a new era of the Web opened as new, interesting, and compelling\nuse-cases became possible like never before.  A new wave of dynamic \"shell\"\napplications that had the ability to modify documents after they had been\nretrieved  emerged, including Twitter, MySpace, Friendster [???] [citation\nneeded].  However, these applications very quickly became isolated silos with\nbarely-working interfaces for integration, as their proprietary bundles of\napplication-specific code had finite, acute focii.\nA resurgent effort to restore the interoperability provided by purely semantic\nmarkup languages such as HTML gave birth to initiatives such as Microformats and\nlater Schema.org [citation needed], but the overhead of their implementations\ngave too much resistance to their adoption.\nMessaging\nAlan Kay introduced the idea of messaging ....  Today we observe many\nderivatives of this model, including that of the Actor Model citation\nneeded.  \nA messaging system provides ....  It does not, however, provide any mechanism\nfor ordering.  This is desirable when developing asynchronous systems.  However,\nfor conflict resolution, one might want to identify which particular message\ncame first.  This leaves us with the timestamping problem.\nProtocol\nThe Fabric protocol implements a mechanism for representing a largely\nintangible idea, trust, as a pre-established commitment in a slightly more\ntangible fashion, a value token.  If a network is composed primarily of honest,\nfriendly nodes, then commitments increase over time until the updates provided\nby the network cease to be valuable.  Should a node cease being honest, it\ndestroys its ability to increase in value over time.\nSecurity\nContract Signatures\nTransactions as Functions\nGiven a transaction set t, there should also be a correlating inverse\ntransaction set t^-1 such that the state of a database prior to the\napplication of t can be completely derived after its application by applying\nt^-1.\nFurther, individual patchsets, should be composable functions, with equivalent\ninverse functions.\nFuzzchains (WIP)\nSince the constraint of a finite limit on information (such as a limit on token\nsupply) is not present in an information market, as new information can be\nintroduced at any time,  To implement a distributed datastore on a peer-to-peer\nbasis without compromising the freedom of speech of any individual node, we\nmust remove the constraint of consensus from the network.  \nWithout a need to enforce the availability of specific transaction sets, we can\nderive a new type of blockchain we term a \"fuzzchain\".  This fuzzchain allows\nfor many divergent sequences of chains, which may or may not be in conflict at\nany point in time.\n In the case of Fabric, we replace the direct block subsidy and transaction fee\nmarket with a  \nMulti-Party Computations\nFabric aims to provide data security across a fully decentralized network, that\nis, one without any requisite third party.  As participants in such a network\nare not necessarily favorable actors, a strategy to protect data while\nsimultaneously allowing for computations on said data is necessary for such a\nsystem to be viable.\nWe build on Baum's work on secure computations, taking advantage of recent\nadvances in computer science to extend existing models to include n-party\ncomputations.  Specifically, we utilize a hierarchical secure multi-party\ncomputation, which splits our network into a hierarchy of equally sized MPCs\nwhich are then used in sum to compute the finalized output.  As these units are\ncompletely independent, we can parallelize the work at each level of the\nhierarchy.\nSome optimizations from Enigma are included in Fabric to offer linear, rather\nthan quadratic, scalability.\n\nYao, Andrew C. ”Protocols for secure computations.” 2013 IEEE 54th Annual Symposium on Foundations of Computer Science. IEEE, 1982.\nBaum, Carsten, Ivan Damgrd, and Claudio Orlandi. ”Publicly auditable secure multi-party computation.” Security and Cryptography for Networks. Springer International Publishing, 2014. 175-196.\nCohen, Gil, et al. ”Efficient multiparty protocols via log-depth threshold formulae.” Advances in CryptologyCRYPTO 2013. Springer Berlin Heidelberg, 2013. 185-202.\n\nGuy Zyskind, Oz Nathan, Alex ’Sandy’ Pentland.  \"Enigma: Decentralized Computation Platform with Guaranteed Privacy\"  MIT\n\n\nApplication\nThe application layer of Fabric is the implementation of the underlying Resource contract.  We provide Maki, a reference implementation of the Application Resource Contracts (ARC) protocol,\nResources\nFabric's\nSemantic Linkability\nSince Fabric exposes Resources in a descriptive fashion, applications can interact with one another.  By requesting a resource from a namespace other than one's own, information can cross the boundaries of individual applications and other interesting combinations of data can be constructed.\nFurthermore, since applications can be described in their entirety with a simple contract, applications can discover one anothers' behaviors and resource definitions.  This can be used to build various forms of semantic interoperability, potentially including new forms of search engine behaviors.\nMutations\nOnce an application's underlying Resources are defined, their state can be\nmanipulated in an atomic fashion.  Arbitrary rules can be defined about the\nvalidity of a mutation, including various authorization models.\nMutation Blocks\nFabric, in contrast to traditional proof-of-work mechanisms, does not require\nwork to be bundled into \"blocks\".  Instead, consensus is achieved through the\nbundling of atomic mutations to the chain state.  These atomic operations are\nrolled up into groupings called, perhaps inconveniently, \"transactions\".  These\ntransactions are isomorphic to traditional blockchain transactions, in that\neither a block is valid or it is not, as determined by the component operations\nit contains.  If any one operation is invalid, so too must be the block.\nOTHER NOTES\nSee:\n\n\"Convergent Instrumental Goal\"\n\nTODO: include content hashes of links as they appear at document compilation time.\nOTHER CITATIONS TO INCLUDE:\n"}}}
./_book/whitepaper.html:                  <p>TODO</p>
./_book/whitepaper.html:                  <p>TODO: include content hashes of links as they appear at
./_book/examples/bitcoin.js:  // TODO: import these into core process logic
./_book/examples/game.js:    // TODO: use fabric call
./_book/examples/swarm.html:          <p>TODO: create entities on seed node
./_book/examples/swarm.html:            TODO: receive entities from seed node
./_book/examples/swarm.html:            TODO: create entities on swarm instance</p>
./_book/examples/bitcoin.html:          <p>TODO: import these into core process logic
./_book/examples/service.js:      // TODO: revert to OPTIONS (this was a temporary fix for an NGINX bug)
./_book/examples/swarm.js:  // TODO: create entities on seed node
./_book/examples/swarm.js:  // TODO: receive entities from seed node
./_book/examples/swarm.js:  // TODO: create entities on swarm instance
./_book/examples/oracle.html:          <p>TODO: use bottom panel for inline execution (<em>a la</em> “Run this Code &raquo;”)</p>
./_book/examples/oracle.js:// TODO: use bottom panel for inline execution (_a la_ "Run this Code &raquo;")
./_book/examples/service.html:          <p>TODO: revert to OPTIONS (this was a temporary fix for an NGINX bug)</p>
./_book/examples/game.html:          <p>TODO: use fabric call
./_book/examples/blockchain.html:          <p>TODO: disconnect peers</p>
./_book/examples/blockchain.js:      // TODO: disconnect peers
./_book/whitepaper-2015.html:                  <h3 id="todo-include-content-hashes-of-links-as-they-appear-at-document-compilation-time">TODO: include content hashes of links as they appear at document compilation time.</h3>
./_book/GOALS.md:- [ ] Find all TODO items (run script, check diff)
./assets/service.js:eval("/*\n  Fabric Core Constants.\n  ---\n  Author: Fabric Labs\n  Copyright: All Rights Reserved.\n */\n\n\nconst PEER_PORT = 9999;\nconst MAX_PEERS = 32;\n\nconst PRECISION = 100;\n\nconst MAGIC_BYTES = 0xC0D3F33D;\nconst VERSION_NUMBER = 0x01;\nconst BITCOIN_GENESIS = 0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f;\n\nconst HEADER_SIZE = 48; // 32 + 16 bytes\nconst LARGE_COLLECTION_SIZE = 10; // TODO: test with 1,000,000\nconst MAX_MESSAGE_SIZE = 4096 - HEADER_SIZE;\n\nconst MAX_STACK_HEIGHT = 32; // max height of stack (number of elements)\nconst MAX_FRAME_SIZE = 32; // max size of a stack frame in bytes\nconst MAX_MEMORY_ALLOC = MAX_STACK_HEIGHT * MAX_FRAME_SIZE;\nconst MAX_CHANNEL_VALUE = 100000000;\n\n// FABRIC ONLY\nconst OP_CYCLE = '00';\nconst OP_DONE = 'ff';\n\n// Bitcoin\nconst OP_0 = '00';\nconst OP_36 = '24';\nconst OP_CHECKSIG = 'ac';\nconst OP_DUP = '76';\nconst OP_EQUAL = '87';\nconst OP_SHA256 = 'a8';\nconst OP_HASH160 = 'a9';\nconst OP_PUSHDATA1 = '4c';\nconst OP_RETURN = '6a';\nconst OP_EQUALVERIFY = '88';\nconst OP_SEPARATOR = 'ab';\n\nconst P2P_GENERIC = 0x80; // 128 in decimal\nconst P2P_IDENT_REQUEST = 0x01; // 1, or the identity\nconst P2P_IDENT_RESPONSE = 0x11;\nconst P2P_ROOT = 0x00000000;\nconst P2P_PING = 0x00000012; // same ID as Lightning (18)\nconst P2P_PONG = 0x00000013; // same ID as Lightning (19)\nconst P2P_INSTRUCTION = 0x00000020; // TODO: select w/ no overlap\nconst P2P_START_CHAIN = 0x00000021;\nconst P2P_STATE_REQUEST = 0x00000029; // TODO: select w/ no overlap\nconst P2P_STATE_ROOT = 0x00000030; // TODO: select w/ no overlap\nconst P2P_BASE_MESSAGE = 0x00000031; // TODO: select w/ no overlap\nconst P2P_STATE_COMMITTMENT = 0x00000032; // TODO: select w/ no overlap\nconst P2P_STATE_CHANGE = 0x00000033; // TODO: select w/ no overlap\nconst P2P_TRANSACTION = 0x00000039; // TODO: select w/ no overlap\nconst P2P_CALL = 0x00000042;\nconst P2P_CHAIN_SYNC_REQUEST = 0x55;\n\nconst PEER_CANDIDATE = 0x09;\n// TODO: should be 0x02 for Bitcoin P2P\nconst BLOCK_CANDIDATE = 0x03;\n\nconst SESSION_START = 0x02;\nconst CHAT_MESSAGE = 0x67;\n\n// Lightning\nconst LIGHTNING_TEST_HEADER = 'D0520C6E';\nconst LIGHTNING_PROTOCOL_H_INIT = 'Noise_XK_secp256k1_ChaChaPoly_SHA256';\nconst LIGHTNING_PROTOCOL_PROLOGUE = 'lightning';\n\n// Lightning BMM\nconst LIGHTNING_BMM_HEADER = 'D0520C6E';\nconst LIGHTNING_SIDECHAIN_NUM = 0xFF; // 1-byte - sidechain number\n\nconst LIGHTNING_SIDEBLOCK_HASH = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000; // 32-bytes\nconst LIGHTNING_PARENT_SIDEBLOCK_HASH = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001; // 32-bytes\n\nconst ZERO_LENGTH_PLAINTEXT = '';\n\nmodule.exports = {\n  PEER_PORT,\n  MAX_PEERS,\n  PRECISION,\n  BITCOIN_GENESIS,\n  HEADER_SIZE,\n  LARGE_COLLECTION_SIZE,\n  BLOCK_CANDIDATE,\n  CHAT_MESSAGE,\n  ZERO_LENGTH_PLAINTEXT,\n  LIGHTNING_TEST_HEADER,\n  LIGHTNING_PROTOCOL_H_INIT,\n  LIGHTNING_PROTOCOL_PROLOGUE,\n  LIGHTNING_BMM_HEADER,\n  LIGHTNING_SIDECHAIN_NUM,\n  LIGHTNING_SIDEBLOCK_HASH,\n  LIGHTNING_PARENT_SIDEBLOCK_HASH,\n  MAGIC_BYTES,\n  MAX_FRAME_SIZE,\n  MAX_MEMORY_ALLOC,\n  MAX_MESSAGE_SIZE,\n  MAX_STACK_HEIGHT,\n  MAX_CHANNEL_VALUE,\n  OP_CYCLE,\n  OP_DONE,\n  OP_0,\n  OP_36,\n  OP_CHECKSIG,\n  OP_DUP,\n  OP_EQUAL,\n  OP_SHA256,\n  OP_HASH160,\n  OP_PUSHDATA1,\n  OP_RETURN,\n  OP_EQUALVERIFY,\n  OP_SEPARATOR,\n  P2P_GENERIC,\n  P2P_IDENT_REQUEST,\n  P2P_IDENT_RESPONSE,\n  P2P_CHAIN_SYNC_REQUEST,\n  P2P_ROOT,\n  P2P_PING,\n  P2P_PONG,\n  P2P_START_CHAIN,\n  P2P_INSTRUCTION,\n  P2P_BASE_MESSAGE,\n  P2P_STATE_ROOT,\n  P2P_STATE_COMMITTMENT,\n  P2P_STATE_CHANGE,\n  P2P_STATE_REQUEST,\n  P2P_TRANSACTION,\n  P2P_CALL,\n  PEER_CANDIDATE,\n  SESSION_START,\n  VERSION_NUMBER\n};\n\n\n//# sourceURL=webpack://Fabric/./constants.js?");
./assets/service.js:eval("//importScripts('/app.min.js');\n\nconst url = __webpack_require__(/*! url */ \"./node_modules/url/url.js\");\nconst Stash = __webpack_require__(/*! ../types/stash */ \"./types/stash.js\");\n\nself.addEventListener('message', function (e) {\n  e.source.postMessage('[GUARDIAN]', 'Hello! Your message was: ' + e.data);\n});\n\nself.addEventListener('fetch', async function (event) {\n  const self = this;\n  console.log('[GUARDIAN]', 'request:', event);\n\n  const path = event.request.url;\n  const target = url.parse(path);\n  const uri = target.pathname;\n\n  const stash = new Stash();\n  console.log('stash:', stash);\n  console.log('target:', target);\n\n  //await stash.set('/messages', [{ foo: 'bar' }]);\n  console.log('recovery:', await stash.get('/messages'));\n\n  const value = await stash.get(uri);\n  if (value) {\n    console.log('was cached:', uri, value.length, 'bytes');\n    const request = new Request(uri, {\n      // TODO: revert to OPTIONS (this was a temporary fix for an NGINX bug)\n      method: 'HEAD'\n    });\n\n    const response = await fetch(request);\n    //const content = await response.text();\n    return value;\n  } else {\n    const request = new Request(uri, {\n      headers: {\n        'X-Identity': 'foo'\n      }\n    });\n\n    const response = await fetch(request);\n    const content = await response.text();\n    console.log('response:', uri, content.length);\n\n    if (content) {\n      stash.set(uri, content);\n    }\n\n    return request;\n  }\n});\n\n\n//# sourceURL=webpack://Fabric/./examples/service.js?");
./assets/service.js:eval("\n\nconst Reporter = __webpack_require__(/*! ../base/reporter */ \"./node_modules/asn1.js/lib/asn1/base/reporter.js\").Reporter;\nconst EncoderBuffer = __webpack_require__(/*! ../base/buffer */ \"./node_modules/asn1.js/lib/asn1/base/buffer.js\").EncoderBuffer;\nconst DecoderBuffer = __webpack_require__(/*! ../base/buffer */ \"./node_modules/asn1.js/lib/asn1/base/buffer.js\").DecoderBuffer;\nconst assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\n// Supported tags\nconst tags = [\n  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',\n  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',\n  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',\n  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'\n];\n\n// Public methods list\nconst methods = [\n  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',\n  'any', 'contains'\n].concat(tags);\n\n// Overrided methods list\nconst overrided = [\n  '_peekTag', '_decodeTag', '_use',\n  '_decodeStr', '_decodeObjid', '_decodeTime',\n  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',\n\n  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',\n  '_encodeNull', '_encodeInt', '_encodeBool'\n];\n\nfunction Node(enc, parent, name) {\n  const state = {};\n  this._baseState = state;\n\n  state.name = name;\n  state.enc = enc;\n\n  state.parent = parent || null;\n  state.children = null;\n\n  // State\n  state.tag = null;\n  state.args = null;\n  state.reverseArgs = null;\n  state.choice = null;\n  state.optional = false;\n  state.any = false;\n  state.obj = false;\n  state.use = null;\n  state.useDecoder = null;\n  state.key = null;\n  state['default'] = null;\n  state.explicit = null;\n  state.implicit = null;\n  state.contains = null;\n\n  // Should create new instance on each method\n  if (!state.parent) {\n    state.children = [];\n    this._wrap();\n  }\n}\nmodule.exports = Node;\n\nconst stateProps = [\n  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',\n  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',\n  'implicit', 'contains'\n];\n\nNode.prototype.clone = function clone() {\n  const state = this._baseState;\n  const cstate = {};\n  stateProps.forEach(function(prop) {\n    cstate[prop] = state[prop];\n  });\n  const res = new this.constructor(cstate.parent);\n  res._baseState = cstate;\n  return res;\n};\n\nNode.prototype._wrap = function wrap() {\n  const state = this._baseState;\n  methods.forEach(function(method) {\n    this[method] = function _wrappedMethod() {\n      const clone = new this.constructor(this);\n      state.children.push(clone);\n      return clone[method].apply(clone, arguments);\n    };\n  }, this);\n};\n\nNode.prototype._init = function init(body) {\n  const state = this._baseState;\n\n  assert(state.parent === null);\n  body.call(this);\n\n  // Filter children\n  state.children = state.children.filter(function(child) {\n    return child._baseState.parent === this;\n  }, this);\n  assert.equal(state.children.length, 1, 'Root node can have only one child');\n};\n\nNode.prototype._useArgs = function useArgs(args) {\n  const state = this._baseState;\n\n  // Filter children and args\n  const children = args.filter(function(arg) {\n    return arg instanceof this.constructor;\n  }, this);\n  args = args.filter(function(arg) {\n    return !(arg instanceof this.constructor);\n  }, this);\n\n  if (children.length !== 0) {\n    assert(state.children === null);\n    state.children = children;\n\n    // Replace parent to maintain backward link\n    children.forEach(function(child) {\n      child._baseState.parent = this;\n    }, this);\n  }\n  if (args.length !== 0) {\n    assert(state.args === null);\n    state.args = args;\n    state.reverseArgs = args.map(function(arg) {\n      if (typeof arg !== 'object' || arg.constructor !== Object)\n        return arg;\n\n      const res = {};\n      Object.keys(arg).forEach(function(key) {\n        if (key == (key | 0))\n          key |= 0;\n        const value = arg[key];\n        res[value] = key;\n      });\n      return res;\n    });\n  }\n};\n\n//\n// Overrided methods\n//\n\noverrided.forEach(function(method) {\n  Node.prototype[method] = function _overrided() {\n    const state = this._baseState;\n    throw new Error(method + ' not implemented for encoding: ' + state.enc);\n  };\n});\n\n//\n// Public methods\n//\n\ntags.forEach(function(tag) {\n  Node.prototype[tag] = function _tagMethod() {\n    const state = this._baseState;\n    const args = Array.prototype.slice.call(arguments);\n\n    assert(state.tag === null);\n    state.tag = tag;\n\n    this._useArgs(args);\n\n    return this;\n  };\n});\n\nNode.prototype.use = function use(item) {\n  assert(item);\n  const state = this._baseState;\n\n  assert(state.use === null);\n  state.use = item;\n\n  return this;\n};\n\nNode.prototype.optional = function optional() {\n  const state = this._baseState;\n\n  state.optional = true;\n\n  return this;\n};\n\nNode.prototype.def = function def(val) {\n  const state = this._baseState;\n\n  assert(state['default'] === null);\n  state['default'] = val;\n  state.optional = true;\n\n  return this;\n};\n\nNode.prototype.explicit = function explicit(num) {\n  const state = this._baseState;\n\n  assert(state.explicit === null && state.implicit === null);\n  state.explicit = num;\n\n  return this;\n};\n\nNode.prototype.implicit = function implicit(num) {\n  const state = this._baseState;\n\n  assert(state.explicit === null && state.implicit === null);\n  state.implicit = num;\n\n  return this;\n};\n\nNode.prototype.obj = function obj() {\n  const state = this._baseState;\n  const args = Array.prototype.slice.call(arguments);\n\n  state.obj = true;\n\n  if (args.length !== 0)\n    this._useArgs(args);\n\n  return this;\n};\n\nNode.prototype.key = function key(newKey) {\n  const state = this._baseState;\n\n  assert(state.key === null);\n  state.key = newKey;\n\n  return this;\n};\n\nNode.prototype.any = function any() {\n  const state = this._baseState;\n\n  state.any = true;\n\n  return this;\n};\n\nNode.prototype.choice = function choice(obj) {\n  const state = this._baseState;\n\n  assert(state.choice === null);\n  state.choice = obj;\n  this._useArgs(Object.keys(obj).map(function(key) {\n    return obj[key];\n  }));\n\n  return this;\n};\n\nNode.prototype.contains = function contains(item) {\n  const state = this._baseState;\n\n  assert(state.use === null);\n  state.contains = item;\n\n  return this;\n};\n\n//\n// Decoding\n//\n\nNode.prototype._decode = function decode(input, options) {\n  const state = this._baseState;\n\n  // Decode root node\n  if (state.parent === null)\n    return input.wrapResult(state.children[0]._decode(input, options));\n\n  let result = state['default'];\n  let present = true;\n\n  let prevKey = null;\n  if (state.key !== null)\n    prevKey = input.enterKey(state.key);\n\n  // Check if tag is there\n  if (state.optional) {\n    let tag = null;\n    if (state.explicit !== null)\n      tag = state.explicit;\n    else if (state.implicit !== null)\n      tag = state.implicit;\n    else if (state.tag !== null)\n      tag = state.tag;\n\n    if (tag === null && !state.any) {\n      // Trial and Error\n      const save = input.save();\n      try {\n        if (state.choice === null)\n          this._decodeGeneric(state.tag, input, options);\n        else\n          this._decodeChoice(input, options);\n        present = true;\n      } catch (e) {\n        present = false;\n      }\n      input.restore(save);\n    } else {\n      present = this._peekTag(input, tag, state.any);\n\n      if (input.isError(present))\n        return present;\n    }\n  }\n\n  // Push object on stack\n  let prevObj;\n  if (state.obj && present)\n    prevObj = input.enterObject();\n\n  if (present) {\n    // Unwrap explicit values\n    if (state.explicit !== null) {\n      const explicit = this._decodeTag(input, state.explicit);\n      if (input.isError(explicit))\n        return explicit;\n      input = explicit;\n    }\n\n    const start = input.offset;\n\n    // Unwrap implicit and normal values\n    if (state.use === null && state.choice === null) {\n      let save;\n      if (state.any)\n        save = input.save();\n      const body = this._decodeTag(\n        input,\n        state.implicit !== null ? state.implicit : state.tag,\n        state.any\n      );\n      if (input.isError(body))\n        return body;\n\n      if (state.any)\n        result = input.raw(save);\n      else\n        input = body;\n    }\n\n    if (options && options.track && state.tag !== null)\n      options.track(input.path(), start, input.length, 'tagged');\n\n    if (options && options.track && state.tag !== null)\n      options.track(input.path(), input.offset, input.length, 'content');\n\n    // Select proper method for tag\n    if (state.any) {\n      // no-op\n    } else if (state.choice === null) {\n      result = this._decodeGeneric(state.tag, input, options);\n    } else {\n      result = this._decodeChoice(input, options);\n    }\n\n    if (input.isError(result))\n      return result;\n\n    // Decode children\n    if (!state.any && state.choice === null && state.children !== null) {\n      state.children.forEach(function decodeChildren(child) {\n        // NOTE: We are ignoring errors here, to let parser continue with other\n        // parts of encoded data\n        child._decode(input, options);\n      });\n    }\n\n    // Decode contained/encoded by schema, only in bit or octet strings\n    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {\n      const data = new DecoderBuffer(result);\n      result = this._getUse(state.contains, input._reporterState.obj)\n        ._decode(data, options);\n    }\n  }\n\n  // Pop object\n  if (state.obj && present)\n    result = input.leaveObject(prevObj);\n\n  // Set key\n  if (state.key !== null && (result !== null || present === true))\n    input.leaveKey(prevKey, state.key, result);\n  else if (prevKey !== null)\n    input.exitKey(prevKey);\n\n  return result;\n};\n\nNode.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {\n  const state = this._baseState;\n\n  if (tag === 'seq' || tag === 'set')\n    return null;\n  if (tag === 'seqof' || tag === 'setof')\n    return this._decodeList(input, tag, state.args[0], options);\n  else if (/str$/.test(tag))\n    return this._decodeStr(input, tag, options);\n  else if (tag === 'objid' && state.args)\n    return this._decodeObjid(input, state.args[0], state.args[1], options);\n  else if (tag === 'objid')\n    return this._decodeObjid(input, null, null, options);\n  else if (tag === 'gentime' || tag === 'utctime')\n    return this._decodeTime(input, tag, options);\n  else if (tag === 'null_')\n    return this._decodeNull(input, options);\n  else if (tag === 'bool')\n    return this._decodeBool(input, options);\n  else if (tag === 'objDesc')\n    return this._decodeStr(input, tag, options);\n  else if (tag === 'int' || tag === 'enum')\n    return this._decodeInt(input, state.args && state.args[0], options);\n\n  if (state.use !== null) {\n    return this._getUse(state.use, input._reporterState.obj)\n      ._decode(input, options);\n  } else {\n    return input.error('unknown tag: ' + tag);\n  }\n};\n\nNode.prototype._getUse = function _getUse(entity, obj) {\n\n  const state = this._baseState;\n  // Create altered use decoder if implicit is set\n  state.useDecoder = this._use(entity, obj);\n  assert(state.useDecoder._baseState.parent === null);\n  state.useDecoder = state.useDecoder._baseState.children[0];\n  if (state.implicit !== state.useDecoder._baseState.implicit) {\n    state.useDecoder = state.useDecoder.clone();\n    state.useDecoder._baseState.implicit = state.implicit;\n  }\n  return state.useDecoder;\n};\n\nNode.prototype._decodeChoice = function decodeChoice(input, options) {\n  const state = this._baseState;\n  let result = null;\n  let match = false;\n\n  Object.keys(state.choice).some(function(key) {\n    const save = input.save();\n    const node = state.choice[key];\n    try {\n      const value = node._decode(input, options);\n      if (input.isError(value))\n        return false;\n\n      result = { type: key, value: value };\n      match = true;\n    } catch (e) {\n      input.restore(save);\n      return false;\n    }\n    return true;\n  }, this);\n\n  if (!match)\n    return input.error('Choice not matched');\n\n  return result;\n};\n\n//\n// Encoding\n//\n\nNode.prototype._createEncoderBuffer = function createEncoderBuffer(data) {\n  return new EncoderBuffer(data, this.reporter);\n};\n\nNode.prototype._encode = function encode(data, reporter, parent) {\n  const state = this._baseState;\n  if (state['default'] !== null && state['default'] === data)\n    return;\n\n  const result = this._encodeValue(data, reporter, parent);\n  if (result === undefined)\n    return;\n\n  if (this._skipDefault(result, reporter, parent))\n    return;\n\n  return result;\n};\n\nNode.prototype._encodeValue = function encode(data, reporter, parent) {\n  const state = this._baseState;\n\n  // Decode root node\n  if (state.parent === null)\n    return state.children[0]._encode(data, reporter || new Reporter());\n\n  let result = null;\n\n  // Set reporter to share it with a child class\n  this.reporter = reporter;\n\n  // Check if data is there\n  if (state.optional && data === undefined) {\n    if (state['default'] !== null)\n      data = state['default'];\n    else\n      return;\n  }\n\n  // Encode children first\n  let content = null;\n  let primitive = false;\n  if (state.any) {\n    // Anything that was given is translated to buffer\n    result = this._createEncoderBuffer(data);\n  } else if (state.choice) {\n    result = this._encodeChoice(data, reporter);\n  } else if (state.contains) {\n    content = this._getUse(state.contains, parent)._encode(data, reporter);\n    primitive = true;\n  } else if (state.children) {\n    content = state.children.map(function(child) {\n      if (child._baseState.tag === 'null_')\n        return child._encode(null, reporter, data);\n\n      if (child._baseState.key === null)\n        return reporter.error('Child should have a key');\n      const prevKey = reporter.enterKey(child._baseState.key);\n\n      if (typeof data !== 'object')\n        return reporter.error('Child expected, but input is not object');\n\n      const res = child._encode(data[child._baseState.key], reporter, data);\n      reporter.leaveKey(prevKey);\n\n      return res;\n    }, this).filter(function(child) {\n      return child;\n    });\n    content = this._createEncoderBuffer(content);\n  } else {\n    if (state.tag === 'seqof' || state.tag === 'setof') {\n      // TODO(indutny): this should be thrown on DSL level\n      if (!(state.args && state.args.length === 1))\n        return reporter.error('Too many args for : ' + state.tag);\n\n      if (!Array.isArray(data))\n        return reporter.error('seqof/setof, but data is not Array');\n\n      const child = this.clone();\n      child._baseState.implicit = null;\n      content = this._createEncoderBuffer(data.map(function(item) {\n        const state = this._baseState;\n\n        return this._getUse(state.args[0], data)._encode(item, reporter);\n      }, child));\n    } else if (state.use !== null) {\n      result = this._getUse(state.use, parent)._encode(data, reporter);\n    } else {\n      content = this._encodePrimitive(state.tag, data);\n      primitive = true;\n    }\n  }\n\n  // Encode data itself\n  if (!state.any && state.choice === null) {\n    const tag = state.implicit !== null ? state.implicit : state.tag;\n    const cls = state.implicit === null ? 'universal' : 'context';\n\n    if (tag === null) {\n      if (state.use === null)\n        reporter.error('Tag could be omitted only for .use()');\n    } else {\n      if (state.use === null)\n        result = this._encodeComposite(tag, primitive, cls, content);\n    }\n  }\n\n  // Wrap in explicit\n  if (state.explicit !== null)\n    result = this._encodeComposite(state.explicit, false, 'context', result);\n\n  return result;\n};\n\nNode.prototype._encodeChoice = function encodeChoice(data, reporter) {\n  const state = this._baseState;\n\n  const node = state.choice[data.type];\n  if (!node) {\n    assert(\n      false,\n      data.type + ' not found in ' +\n            JSON.stringify(Object.keys(state.choice)));\n  }\n  return node._encode(data.value, reporter);\n};\n\nNode.prototype._encodePrimitive = function encodePrimitive(tag, data) {\n  const state = this._baseState;\n\n  if (/str$/.test(tag))\n    return this._encodeStr(data, tag);\n  else if (tag === 'objid' && state.args)\n    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);\n  else if (tag === 'objid')\n    return this._encodeObjid(data, null, null);\n  else if (tag === 'gentime' || tag === 'utctime')\n    return this._encodeTime(data, tag);\n  else if (tag === 'null_')\n    return this._encodeNull();\n  else if (tag === 'int' || tag === 'enum')\n    return this._encodeInt(data, state.args && state.reverseArgs[0]);\n  else if (tag === 'bool')\n    return this._encodeBool(data);\n  else if (tag === 'objDesc')\n    return this._encodeStr(data, tag);\n  else\n    throw new Error('Unsupported tag: ' + tag);\n};\n\nNode.prototype._isNumstr = function isNumstr(str) {\n  return /^[0-9 ]*$/.test(str);\n};\n\nNode.prototype._isPrintstr = function isPrintstr(str) {\n  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);\n};\n\n\n//# sourceURL=webpack://Fabric/./node_modules/asn1.js/lib/asn1/base/node.js?");
./assets/service.js:eval("/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {\n  'use strict';\n\n  // Utils\n  function assert (val, msg) {\n    if (!val) throw new Error(msg || 'Assertion failed');\n  }\n\n  // Could use `inherits` module, but don't want to move from single file\n  // architecture yet.\n  function inherits (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  }\n\n  // BN\n\n  function BN (number, base, endian) {\n    if (BN.isBN(number)) {\n      return number;\n    }\n\n    this.negative = 0;\n    this.words = null;\n    this.length = 0;\n\n    // Reduction context\n    this.red = null;\n\n    if (number !== null) {\n      if (base === 'le' || base === 'be') {\n        endian = base;\n        base = 10;\n      }\n\n      this._init(number || 0, base || 10, endian || 'be');\n    }\n  }\n  if (typeof module === 'object') {\n    module.exports = BN;\n  } else {\n    exports.BN = BN;\n  }\n\n  BN.BN = BN;\n  BN.wordSize = 26;\n\n  var Buffer;\n  try {\n    Buffer = __webpack_require__(/*! buffer */ 4).Buffer;\n  } catch (e) {\n  }\n\n  BN.isBN = function isBN (num) {\n    if (num instanceof BN) {\n      return true;\n    }\n\n    return num !== null && typeof num === 'object' &&\n      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n  };\n\n  BN.max = function max (left, right) {\n    if (left.cmp(right) > 0) return left;\n    return right;\n  };\n\n  BN.min = function min (left, right) {\n    if (left.cmp(right) < 0) return left;\n    return right;\n  };\n\n  BN.prototype._init = function init (number, base, endian) {\n    if (typeof number === 'number') {\n      return this._initNumber(number, base, endian);\n    }\n\n    if (typeof number === 'object') {\n      return this._initArray(number, base, endian);\n    }\n\n    if (base === 'hex') {\n      base = 16;\n    }\n    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n    number = number.toString().replace(/\\s+/g, '');\n    var start = 0;\n    if (number[0] === '-') {\n      start++;\n    }\n\n    if (base === 16) {\n      this._parseHex(number, start);\n    } else {\n      this._parseBase(number, base, start);\n    }\n\n    if (number[0] === '-') {\n      this.negative = 1;\n    }\n\n    this.strip();\n\n    if (endian !== 'le') return;\n\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n    if (number < 0) {\n      this.negative = 1;\n      number = -number;\n    }\n    if (number < 0x4000000) {\n      this.words = [ number & 0x3ffffff ];\n      this.length = 1;\n    } else if (number < 0x10000000000000) {\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff\n      ];\n      this.length = 2;\n    } else {\n      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff,\n        1\n      ];\n      this.length = 3;\n    }\n\n    if (endian !== 'le') return;\n\n    // Reverse the bytes\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initArray = function _initArray (number, base, endian) {\n    // Perhaps a Uint8Array\n    assert(typeof number.length === 'number');\n    if (number.length <= 0) {\n      this.words = [ 0 ];\n      this.length = 1;\n      return this;\n    }\n\n    this.length = Math.ceil(number.length / 3);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    var off = 0;\n    if (endian === 'be') {\n      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    } else if (endian === 'le') {\n      for (i = 0, j = 0; i < number.length; i += 3) {\n        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    }\n    return this.strip();\n  };\n\n  function parseHex (str, start, end) {\n    var r = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r <<= 4;\n\n      // 'a' - 'f'\n      if (c >= 49 && c <= 54) {\n        r |= c - 49 + 0xa;\n\n      // 'A' - 'F'\n      } else if (c >= 17 && c <= 22) {\n        r |= c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        r |= c & 0xf;\n      }\n    }\n    return r;\n  }\n\n  BN.prototype._parseHex = function _parseHex (number, start) {\n    // Create possibly bigger array to ensure that it fits the number\n    this.length = Math.ceil((number.length - start) / 6);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    // Scan 24-bit chunks and add them to the number\n    var off = 0;\n    for (i = number.length - 6, j = 0; i >= start; i -= 6) {\n      w = parseHex(number, i, i + 6);\n      this.words[j] |= (w << off) & 0x3ffffff;\n      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb\n      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n      off += 24;\n      if (off >= 26) {\n        off -= 26;\n        j++;\n      }\n    }\n    if (i + 6 !== start) {\n      w = parseHex(number, start, i + 6);\n      this.words[j] |= (w << off) & 0x3ffffff;\n      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n    }\n    this.strip();\n  };\n\n  function parseBase (str, start, end, mul) {\n    var r = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r *= mul;\n\n      // 'a'\n      if (c >= 49) {\n        r += c - 49 + 0xa;\n\n      // 'A'\n      } else if (c >= 17) {\n        r += c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        r += c;\n      }\n    }\n    return r;\n  }\n\n  BN.prototype._parseBase = function _parseBase (number, base, start) {\n    // Initialize as zero\n    this.words = [ 0 ];\n    this.length = 1;\n\n    // Find length of limb in base\n    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n      limbLen++;\n    }\n    limbLen--;\n    limbPow = (limbPow / base) | 0;\n\n    var total = number.length - start;\n    var mod = total % limbLen;\n    var end = Math.min(total, total - mod) + start;\n\n    var word = 0;\n    for (var i = start; i < end; i += limbLen) {\n      word = parseBase(number, i, i + limbLen, base);\n\n      this.imuln(limbPow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    if (mod !== 0) {\n      var pow = 1;\n      word = parseBase(number, i, number.length, base);\n\n      for (i = 0; i < mod; i++) {\n        pow *= base;\n      }\n\n      this.imuln(pow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n  };\n\n  BN.prototype.copy = function copy (dest) {\n    dest.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      dest.words[i] = this.words[i];\n    }\n    dest.length = this.length;\n    dest.negative = this.negative;\n    dest.red = this.red;\n  };\n\n  BN.prototype.clone = function clone () {\n    var r = new BN(null);\n    this.copy(r);\n    return r;\n  };\n\n  BN.prototype._expand = function _expand (size) {\n    while (this.length < size) {\n      this.words[this.length++] = 0;\n    }\n    return this;\n  };\n\n  // Remove leading `0` from `this`\n  BN.prototype.strip = function strip () {\n    while (this.length > 1 && this.words[this.length - 1] === 0) {\n      this.length--;\n    }\n    return this._normSign();\n  };\n\n  BN.prototype._normSign = function _normSign () {\n    // -0 = 0\n    if (this.length === 1 && this.words[0] === 0) {\n      this.negative = 0;\n    }\n    return this;\n  };\n\n  BN.prototype.inspect = function inspect () {\n    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n  };\n\n  /*\n\n  var zeros = [];\n  var groupSizes = [];\n  var groupBases = [];\n\n  var s = '';\n  var i = -1;\n  while (++i < BN.wordSize) {\n    zeros[i] = s;\n    s += '0';\n  }\n  groupSizes[0] = 0;\n  groupSizes[1] = 0;\n  groupBases[0] = 0;\n  groupBases[1] = 0;\n  var base = 2 - 1;\n  while (++base < 36 + 1) {\n    var groupSize = 0;\n    var groupBase = 1;\n    while (groupBase < (1 << BN.wordSize) / base) {\n      groupBase *= base;\n      groupSize += 1;\n    }\n    groupSizes[base] = groupSize;\n    groupBases[base] = groupBase;\n  }\n\n  */\n\n  var zeros = [\n    '',\n    '0',\n    '00',\n    '000',\n    '0000',\n    '00000',\n    '000000',\n    '0000000',\n    '00000000',\n    '000000000',\n    '0000000000',\n    '00000000000',\n    '000000000000',\n    '0000000000000',\n    '00000000000000',\n    '000000000000000',\n    '0000000000000000',\n    '00000000000000000',\n    '000000000000000000',\n    '0000000000000000000',\n    '00000000000000000000',\n    '000000000000000000000',\n    '0000000000000000000000',\n    '00000000000000000000000',\n    '000000000000000000000000',\n    '0000000000000000000000000'\n  ];\n\n  var groupSizes = [\n    0, 0,\n    25, 16, 12, 11, 10, 9, 8,\n    8, 7, 7, 7, 7, 6, 6,\n    6, 6, 6, 6, 6, 5, 5,\n    5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5\n  ];\n\n  var groupBases = [\n    0, 0,\n    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n  ];\n\n  BN.prototype.toString = function toString (base, padding) {\n    base = base || 10;\n    padding = padding | 0 || 1;\n\n    var out;\n    if (base === 16 || base === 'hex') {\n      out = '';\n      var off = 0;\n      var carry = 0;\n      for (var i = 0; i < this.length; i++) {\n        var w = this.words[i];\n        var word = (((w << off) | carry) & 0xffffff).toString(16);\n        carry = (w >>> (24 - off)) & 0xffffff;\n        if (carry !== 0 || i !== this.length - 1) {\n          out = zeros[6 - word.length] + word + out;\n        } else {\n          out = word + out;\n        }\n        off += 2;\n        if (off >= 26) {\n          off -= 26;\n          i--;\n        }\n      }\n      if (carry !== 0) {\n        out = carry.toString(16) + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    if (base === (base | 0) && base >= 2 && base <= 36) {\n      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n      var groupSize = groupSizes[base];\n      // var groupBase = Math.pow(base, groupSize);\n      var groupBase = groupBases[base];\n      out = '';\n      var c = this.clone();\n      c.negative = 0;\n      while (!c.isZero()) {\n        var r = c.modn(groupBase).toString(base);\n        c = c.idivn(groupBase);\n\n        if (!c.isZero()) {\n          out = zeros[groupSize - r.length] + r + out;\n        } else {\n          out = r + out;\n        }\n      }\n      if (this.isZero()) {\n        out = '0' + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    assert(false, 'Base should be between 2 and 36');\n  };\n\n  BN.prototype.toNumber = function toNumber () {\n    var ret = this.words[0];\n    if (this.length === 2) {\n      ret += this.words[1] * 0x4000000;\n    } else if (this.length === 3 && this.words[2] === 0x01) {\n      // NOTE: at this stage it is known that the top bit is set\n      ret += 0x10000000000000 + (this.words[1] * 0x4000000);\n    } else if (this.length > 2) {\n      assert(false, 'Number can only safely store up to 53 bits');\n    }\n    return (this.negative !== 0) ? -ret : ret;\n  };\n\n  BN.prototype.toJSON = function toJSON () {\n    return this.toString(16);\n  };\n\n  BN.prototype.toBuffer = function toBuffer (endian, length) {\n    assert(typeof Buffer !== 'undefined');\n    return this.toArrayLike(Buffer, endian, length);\n  };\n\n  BN.prototype.toArray = function toArray (endian, length) {\n    return this.toArrayLike(Array, endian, length);\n  };\n\n  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {\n    var byteLength = this.byteLength();\n    var reqLength = length || Math.max(1, byteLength);\n    assert(byteLength <= reqLength, 'byte array longer than desired length');\n    assert(reqLength > 0, 'Requested array length <= 0');\n\n    this.strip();\n    var littleEndian = endian === 'le';\n    var res = new ArrayType(reqLength);\n\n    var b, i;\n    var q = this.clone();\n    if (!littleEndian) {\n      // Assume big-endian\n      for (i = 0; i < reqLength - byteLength; i++) {\n        res[i] = 0;\n      }\n\n      for (i = 0; !q.isZero(); i++) {\n        b = q.andln(0xff);\n        q.iushrn(8);\n\n        res[reqLength - i - 1] = b;\n      }\n    } else {\n      for (i = 0; !q.isZero(); i++) {\n        b = q.andln(0xff);\n        q.iushrn(8);\n\n        res[i] = b;\n      }\n\n      for (; i < reqLength; i++) {\n        res[i] = 0;\n      }\n    }\n\n    return res;\n  };\n\n  if (Math.clz32) {\n    BN.prototype._countBits = function _countBits (w) {\n      return 32 - Math.clz32(w);\n    };\n  } else {\n    BN.prototype._countBits = function _countBits (w) {\n      var t = w;\n      var r = 0;\n      if (t >= 0x1000) {\n        r += 13;\n        t >>>= 13;\n      }\n      if (t >= 0x40) {\n        r += 7;\n        t >>>= 7;\n      }\n      if (t >= 0x8) {\n        r += 4;\n        t >>>= 4;\n      }\n      if (t >= 0x02) {\n        r += 2;\n        t >>>= 2;\n      }\n      return r + t;\n    };\n  }\n\n  BN.prototype._zeroBits = function _zeroBits (w) {\n    // Short-cut\n    if (w === 0) return 26;\n\n    var t = w;\n    var r = 0;\n    if ((t & 0x1fff) === 0) {\n      r += 13;\n      t >>>= 13;\n    }\n    if ((t & 0x7f) === 0) {\n      r += 7;\n      t >>>= 7;\n    }\n    if ((t & 0xf) === 0) {\n      r += 4;\n      t >>>= 4;\n    }\n    if ((t & 0x3) === 0) {\n      r += 2;\n      t >>>= 2;\n    }\n    if ((t & 0x1) === 0) {\n      r++;\n    }\n    return r;\n  };\n\n  // Return number of used bits in a BN\n  BN.prototype.bitLength = function bitLength () {\n    var w = this.words[this.length - 1];\n    var hi = this._countBits(w);\n    return (this.length - 1) * 26 + hi;\n  };\n\n  function toBitArray (num) {\n    var w = new Array(num.bitLength());\n\n    for (var bit = 0; bit < w.length; bit++) {\n      var off = (bit / 26) | 0;\n      var wbit = bit % 26;\n\n      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;\n    }\n\n    return w;\n  }\n\n  // Number of trailing zero bits\n  BN.prototype.zeroBits = function zeroBits () {\n    if (this.isZero()) return 0;\n\n    var r = 0;\n    for (var i = 0; i < this.length; i++) {\n      var b = this._zeroBits(this.words[i]);\n      r += b;\n      if (b !== 26) break;\n    }\n    return r;\n  };\n\n  BN.prototype.byteLength = function byteLength () {\n    return Math.ceil(this.bitLength() / 8);\n  };\n\n  BN.prototype.toTwos = function toTwos (width) {\n    if (this.negative !== 0) {\n      return this.abs().inotn(width).iaddn(1);\n    }\n    return this.clone();\n  };\n\n  BN.prototype.fromTwos = function fromTwos (width) {\n    if (this.testn(width - 1)) {\n      return this.notn(width).iaddn(1).ineg();\n    }\n    return this.clone();\n  };\n\n  BN.prototype.isNeg = function isNeg () {\n    return this.negative !== 0;\n  };\n\n  // Return negative clone of `this`\n  BN.prototype.neg = function neg () {\n    return this.clone().ineg();\n  };\n\n  BN.prototype.ineg = function ineg () {\n    if (!this.isZero()) {\n      this.negative ^= 1;\n    }\n\n    return this;\n  };\n\n  // Or `num` with `this` in-place\n  BN.prototype.iuor = function iuor (num) {\n    while (this.length < num.length) {\n      this.words[this.length++] = 0;\n    }\n\n    for (var i = 0; i < num.length; i++) {\n      this.words[i] = this.words[i] | num.words[i];\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ior = function ior (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuor(num);\n  };\n\n  // Or `num` with `this`\n  BN.prototype.or = function or (num) {\n    if (this.length > num.length) return this.clone().ior(num);\n    return num.clone().ior(this);\n  };\n\n  BN.prototype.uor = function uor (num) {\n    if (this.length > num.length) return this.clone().iuor(num);\n    return num.clone().iuor(this);\n  };\n\n  // And `num` with `this` in-place\n  BN.prototype.iuand = function iuand (num) {\n    // b = min-length(num, this)\n    var b;\n    if (this.length > num.length) {\n      b = num;\n    } else {\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = this.words[i] & num.words[i];\n    }\n\n    this.length = b.length;\n\n    return this.strip();\n  };\n\n  BN.prototype.iand = function iand (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuand(num);\n  };\n\n  // And `num` with `this`\n  BN.prototype.and = function and (num) {\n    if (this.length > num.length) return this.clone().iand(num);\n    return num.clone().iand(this);\n  };\n\n  BN.prototype.uand = function uand (num) {\n    if (this.length > num.length) return this.clone().iuand(num);\n    return num.clone().iuand(this);\n  };\n\n  // Xor `num` with `this` in-place\n  BN.prototype.iuxor = function iuxor (num) {\n    // a.length > b.length\n    var a;\n    var b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = a.words[i] ^ b.words[i];\n    }\n\n    if (this !== a) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = a.length;\n\n    return this.strip();\n  };\n\n  BN.prototype.ixor = function ixor (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuxor(num);\n  };\n\n  // Xor `num` with `this`\n  BN.prototype.xor = function xor (num) {\n    if (this.length > num.length) return this.clone().ixor(num);\n    return num.clone().ixor(this);\n  };\n\n  BN.prototype.uxor = function uxor (num) {\n    if (this.length > num.length) return this.clone().iuxor(num);\n    return num.clone().iuxor(this);\n  };\n\n  // Not ``this`` with ``width`` bitwidth\n  BN.prototype.inotn = function inotn (width) {\n    assert(typeof width === 'number' && width >= 0);\n\n    var bytesNeeded = Math.ceil(width / 26) | 0;\n    var bitsLeft = width % 26;\n\n    // Extend the buffer with leading zeroes\n    this._expand(bytesNeeded);\n\n    if (bitsLeft > 0) {\n      bytesNeeded--;\n    }\n\n    // Handle complete words\n    for (var i = 0; i < bytesNeeded; i++) {\n      this.words[i] = ~this.words[i] & 0x3ffffff;\n    }\n\n    // Handle the residue\n    if (bitsLeft > 0) {\n      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n    }\n\n    // And remove leading zeroes\n    return this.strip();\n  };\n\n  BN.prototype.notn = function notn (width) {\n    return this.clone().inotn(width);\n  };\n\n  // Set `bit` of `this`\n  BN.prototype.setn = function setn (bit, val) {\n    assert(typeof bit === 'number' && bit >= 0);\n\n    var off = (bit / 26) | 0;\n    var wbit = bit % 26;\n\n    this._expand(off + 1);\n\n    if (val) {\n      this.words[off] = this.words[off] | (1 << wbit);\n    } else {\n      this.words[off] = this.words[off] & ~(1 << wbit);\n    }\n\n    return this.strip();\n  };\n\n  // Add `num` to `this` in-place\n  BN.prototype.iadd = function iadd (num) {\n    var r;\n\n    // negative + positive\n    if (this.negative !== 0 && num.negative === 0) {\n      this.negative = 0;\n      r = this.isub(num);\n      this.negative ^= 1;\n      return this._normSign();\n\n    // positive + negative\n    } else if (this.negative === 0 && num.negative !== 0) {\n      num.negative = 0;\n      r = this.isub(num);\n      num.negative = 1;\n      return r._normSign();\n    }\n\n    // a.length > b.length\n    var a, b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    this.length = a.length;\n    if (carry !== 0) {\n      this.words[this.length] = carry;\n      this.length++;\n    // Copy the rest of the words\n    } else if (a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    return this;\n  };\n\n  // Add `num` to `this`\n  BN.prototype.add = function add (num) {\n    var res;\n    if (num.negative !== 0 && this.negative === 0) {\n      num.negative = 0;\n      res = this.sub(num);\n      num.negative ^= 1;\n      return res;\n    } else if (num.negative === 0 && this.negative !== 0) {\n      this.negative = 0;\n      res = num.sub(this);\n      this.negative = 1;\n      return res;\n    }\n\n    if (this.length > num.length) return this.clone().iadd(num);\n\n    return num.clone().iadd(this);\n  };\n\n  // Subtract `num` from `this` in-place\n  BN.prototype.isub = function isub (num) {\n    // this - (-num) = this + num\n    if (num.negative !== 0) {\n      num.negative = 0;\n      var r = this.iadd(num);\n      num.negative = 1;\n      return r._normSign();\n\n    // -this - num = -(this + num)\n    } else if (this.negative !== 0) {\n      this.negative = 0;\n      this.iadd(num);\n      this.negative = 1;\n      return this._normSign();\n    }\n\n    // At this point both numbers are positive\n    var cmp = this.cmp(num);\n\n    // Optimization - zeroify\n    if (cmp === 0) {\n      this.negative = 0;\n      this.length = 1;\n      this.words[0] = 0;\n      return this;\n    }\n\n    // a > b\n    var a, b;\n    if (cmp > 0) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n\n    // Copy rest of the words\n    if (carry === 0 && i < a.length && a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = Math.max(this.length, i);\n\n    if (a !== this) {\n      this.negative = 1;\n    }\n\n    return this.strip();\n  };\n\n  // Subtract `num` from `this`\n  BN.prototype.sub = function sub (num) {\n    return this.clone().isub(num);\n  };\n\n  function smallMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    var len = (self.length + num.length) | 0;\n    out.length = len;\n    len = (len - 1) | 0;\n\n    // Peel one iteration (compiler can't do it, because of code complexity)\n    var a = self.words[0] | 0;\n    var b = num.words[0] | 0;\n    var r = a * b;\n\n    var lo = r & 0x3ffffff;\n    var carry = (r / 0x4000000) | 0;\n    out.words[0] = lo;\n\n    for (var k = 1; k < len; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = carry >>> 26;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = (k - j) | 0;\n        a = self.words[i] | 0;\n        b = num.words[j] | 0;\n        r = a * b + rword;\n        ncarry += (r / 0x4000000) | 0;\n        rword = r & 0x3ffffff;\n      }\n      out.words[k] = rword | 0;\n      carry = ncarry | 0;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry | 0;\n    } else {\n      out.length--;\n    }\n\n    return out.strip();\n  }\n\n  // TODO(indutny): it may be reasonable to omit it for users who don't need\n  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n  // multiplication (like elliptic secp256k1).\n  var comb10MulTo = function comb10MulTo (self, num, out) {\n    var a = self.words;\n    var b = num.words;\n    var o = out.words;\n    var c = 0;\n    var lo;\n    var mid;\n    var hi;\n    var a0 = a[0] | 0;\n    var al0 = a0 & 0x1fff;\n    var ah0 = a0 >>> 13;\n    var a1 = a[1] | 0;\n    var al1 = a1 & 0x1fff;\n    var ah1 = a1 >>> 13;\n    var a2 = a[2] | 0;\n    var al2 = a2 & 0x1fff;\n    var ah2 = a2 >>> 13;\n    var a3 = a[3] | 0;\n    var al3 = a3 & 0x1fff;\n    var ah3 = a3 >>> 13;\n    var a4 = a[4] | 0;\n    var al4 = a4 & 0x1fff;\n    var ah4 = a4 >>> 13;\n    var a5 = a[5] | 0;\n    var al5 = a5 & 0x1fff;\n    var ah5 = a5 >>> 13;\n    var a6 = a[6] | 0;\n    var al6 = a6 & 0x1fff;\n    var ah6 = a6 >>> 13;\n    var a7 = a[7] | 0;\n    var al7 = a7 & 0x1fff;\n    var ah7 = a7 >>> 13;\n    var a8 = a[8] | 0;\n    var al8 = a8 & 0x1fff;\n    var ah8 = a8 >>> 13;\n    var a9 = a[9] | 0;\n    var al9 = a9 & 0x1fff;\n    var ah9 = a9 >>> 13;\n    var b0 = b[0] | 0;\n    var bl0 = b0 & 0x1fff;\n    var bh0 = b0 >>> 13;\n    var b1 = b[1] | 0;\n    var bl1 = b1 & 0x1fff;\n    var bh1 = b1 >>> 13;\n    var b2 = b[2] | 0;\n    var bl2 = b2 & 0x1fff;\n    var bh2 = b2 >>> 13;\n    var b3 = b[3] | 0;\n    var bl3 = b3 & 0x1fff;\n    var bh3 = b3 >>> 13;\n    var b4 = b[4] | 0;\n    var bl4 = b4 & 0x1fff;\n    var bh4 = b4 >>> 13;\n    var b5 = b[5] | 0;\n    var bl5 = b5 & 0x1fff;\n    var bh5 = b5 >>> 13;\n    var b6 = b[6] | 0;\n    var bl6 = b6 & 0x1fff;\n    var bh6 = b6 >>> 13;\n    var b7 = b[7] | 0;\n    var bl7 = b7 & 0x1fff;\n    var bh7 = b7 >>> 13;\n    var b8 = b[8] | 0;\n    var bl8 = b8 & 0x1fff;\n    var bh8 = b8 >>> 13;\n    var b9 = b[9] | 0;\n    var bl9 = b9 & 0x1fff;\n    var bh9 = b9 >>> 13;\n\n    out.negative = self.negative ^ num.negative;\n    out.length = 19;\n    /* k = 0 */\n    lo = Math.imul(al0, bl0);\n    mid = Math.imul(al0, bh0);\n    mid = (mid + Math.imul(ah0, bl0)) | 0;\n    hi = Math.imul(ah0, bh0);\n    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\n    w0 &= 0x3ffffff;\n    /* k = 1 */\n    lo = Math.imul(al1, bl0);\n    mid = Math.imul(al1, bh0);\n    mid = (mid + Math.imul(ah1, bl0)) | 0;\n    hi = Math.imul(ah1, bh0);\n    lo = (lo + Math.imul(al0, bl1)) | 0;\n    mid = (mid + Math.imul(al0, bh1)) | 0;\n    mid = (mid + Math.imul(ah0, bl1)) | 0;\n    hi = (hi + Math.imul(ah0, bh1)) | 0;\n    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\n    w1 &= 0x3ffffff;\n    /* k = 2 */\n    lo = Math.imul(al2, bl0);\n    mid = Math.imul(al2, bh0);\n    mid = (mid + Math.imul(ah2, bl0)) | 0;\n    hi = Math.imul(ah2, bh0);\n    lo = (lo + Math.imul(al1, bl1)) | 0;\n    mid = (mid + Math.imul(al1, bh1)) | 0;\n    mid = (mid + Math.imul(ah1, bl1)) | 0;\n    hi = (hi + Math.imul(ah1, bh1)) | 0;\n    lo = (lo + Math.imul(al0, bl2)) | 0;\n    mid = (mid + Math.imul(al0, bh2)) | 0;\n    mid = (mid + Math.imul(ah0, bl2)) | 0;\n    hi = (hi + Math.imul(ah0, bh2)) | 0;\n    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\n    w2 &= 0x3ffffff;\n    /* k = 3 */\n    lo = Math.imul(al3, bl0);\n    mid = Math.imul(al3, bh0);\n    mid = (mid + Math.imul(ah3, bl0)) | 0;\n    hi = Math.imul(ah3, bh0);\n    lo = (lo + Math.imul(al2, bl1)) | 0;\n    mid = (mid + Math.imul(al2, bh1)) | 0;\n    mid = (mid + Math.imul(ah2, bl1)) | 0;\n    hi = (hi + Math.imul(ah2, bh1)) | 0;\n    lo = (lo + Math.imul(al1, bl2)) | 0;\n    mid = (mid + Math.imul(al1, bh2)) | 0;\n    mid = (mid + Math.imul(ah1, bl2)) | 0;\n    hi = (hi + Math.imul(ah1, bh2)) | 0;\n    lo = (lo + Math.imul(al0, bl3)) | 0;\n    mid = (mid + Math.imul(al0, bh3)) | 0;\n    mid = (mid + Math.imul(ah0, bl3)) | 0;\n    hi = (hi + Math.imul(ah0, bh3)) | 0;\n    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\n    w3 &= 0x3ffffff;\n    /* k = 4 */\n    lo = Math.imul(al4, bl0);\n    mid = Math.imul(al4, bh0);\n    mid = (mid + Math.imul(ah4, bl0)) | 0;\n    hi = Math.imul(ah4, bh0);\n    lo = (lo + Math.imul(al3, bl1)) | 0;\n    mid = (mid + Math.imul(al3, bh1)) | 0;\n    mid = (mid + Math.imul(ah3, bl1)) | 0;\n    hi = (hi + Math.imul(ah3, bh1)) | 0;\n    lo = (lo + Math.imul(al2, bl2)) | 0;\n    mid = (mid + Math.imul(al2, bh2)) | 0;\n    mid = (mid + Math.imul(ah2, bl2)) | 0;\n    hi = (hi + Math.imul(ah2, bh2)) | 0;\n    lo = (lo + Math.imul(al1, bl3)) | 0;\n    mid = (mid + Math.imul(al1, bh3)) | 0;\n    mid = (mid + Math.imul(ah1, bl3)) | 0;\n    hi = (hi + Math.imul(ah1, bh3)) | 0;\n    lo = (lo + Math.imul(al0, bl4)) | 0;\n    mid = (mid + Math.imul(al0, bh4)) | 0;\n    mid = (mid + Math.imul(ah0, bl4)) | 0;\n    hi = (hi + Math.imul(ah0, bh4)) | 0;\n    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\n    w4 &= 0x3ffffff;\n    /* k = 5 */\n    lo = Math.imul(al5, bl0);\n    mid = Math.imul(al5, bh0);\n    mid = (mid + Math.imul(ah5, bl0)) | 0;\n    hi = Math.imul(ah5, bh0);\n    lo = (lo + Math.imul(al4, bl1)) | 0;\n    mid = (mid + Math.imul(al4, bh1)) | 0;\n    mid = (mid + Math.imul(ah4, bl1)) | 0;\n    hi = (hi + Math.imul(ah4, bh1)) | 0;\n    lo = (lo + Math.imul(al3, bl2)) | 0;\n    mid = (mid + Math.imul(al3, bh2)) | 0;\n    mid = (mid + Math.imul(ah3, bl2)) | 0;\n    hi = (hi + Math.imul(ah3, bh2)) | 0;\n    lo = (lo + Math.imul(al2, bl3)) | 0;\n    mid = (mid + Math.imul(al2, bh3)) | 0;\n    mid = (mid + Math.imul(ah2, bl3)) | 0;\n    hi = (hi + Math.imul(ah2, bh3)) | 0;\n    lo = (lo + Math.imul(al1, bl4)) | 0;\n    mid = (mid + Math.imul(al1, bh4)) | 0;\n    mid = (mid + Math.imul(ah1, bl4)) | 0;\n    hi = (hi + Math.imul(ah1, bh4)) | 0;\n    lo = (lo + Math.imul(al0, bl5)) | 0;\n    mid = (mid + Math.imul(al0, bh5)) | 0;\n    mid = (mid + Math.imul(ah0, bl5)) | 0;\n    hi = (hi + Math.imul(ah0, bh5)) | 0;\n    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\n    w5 &= 0x3ffffff;\n    /* k = 6 */\n    lo = Math.imul(al6, bl0);\n    mid = Math.imul(al6, bh0);\n    mid = (mid + Math.imul(ah6, bl0)) | 0;\n    hi = Math.imul(ah6, bh0);\n    lo = (lo + Math.imul(al5, bl1)) | 0;\n    mid = (mid + Math.imul(al5, bh1)) | 0;\n    mid = (mid + Math.imul(ah5, bl1)) | 0;\n    hi = (hi + Math.imul(ah5, bh1)) | 0;\n    lo = (lo + Math.imul(al4, bl2)) | 0;\n    mid = (mid + Math.imul(al4, bh2)) | 0;\n    mid = (mid + Math.imul(ah4, bl2)) | 0;\n    hi = (hi + Math.imul(ah4, bh2)) | 0;\n    lo = (lo + Math.imul(al3, bl3)) | 0;\n    mid = (mid + Math.imul(al3, bh3)) | 0;\n    mid = (mid + Math.imul(ah3, bl3)) | 0;\n    hi = (hi + Math.imul(ah3, bh3)) | 0;\n    lo = (lo + Math.imul(al2, bl4)) | 0;\n    mid = (mid + Math.imul(al2, bh4)) | 0;\n    mid = (mid + Math.imul(ah2, bl4)) | 0;\n    hi = (hi + Math.imul(ah2, bh4)) | 0;\n    lo = (lo + Math.imul(al1, bl5)) | 0;\n    mid = (mid + Math.imul(al1, bh5)) | 0;\n    mid = (mid + Math.imul(ah1, bl5)) | 0;\n    hi = (hi + Math.imul(ah1, bh5)) | 0;\n    lo = (lo + Math.imul(al0, bl6)) | 0;\n    mid = (mid + Math.imul(al0, bh6)) | 0;\n    mid = (mid + Math.imul(ah0, bl6)) | 0;\n    hi = (hi + Math.imul(ah0, bh6)) | 0;\n    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\n    w6 &= 0x3ffffff;\n    /* k = 7 */\n    lo = Math.imul(al7, bl0);\n    mid = Math.imul(al7, bh0);\n    mid = (mid + Math.imul(ah7, bl0)) | 0;\n    hi = Math.imul(ah7, bh0);\n    lo = (lo + Math.imul(al6, bl1)) | 0;\n    mid = (mid + Math.imul(al6, bh1)) | 0;\n    mid = (mid + Math.imul(ah6, bl1)) | 0;\n    hi = (hi + Math.imul(ah6, bh1)) | 0;\n    lo = (lo + Math.imul(al5, bl2)) | 0;\n    mid = (mid + Math.imul(al5, bh2)) | 0;\n    mid = (mid + Math.imul(ah5, bl2)) | 0;\n    hi = (hi + Math.imul(ah5, bh2)) | 0;\n    lo = (lo + Math.imul(al4, bl3)) | 0;\n    mid = (mid + Math.imul(al4, bh3)) | 0;\n    mid = (mid + Math.imul(ah4, bl3)) | 0;\n    hi = (hi + Math.imul(ah4, bh3)) | 0;\n    lo = (lo + Math.imul(al3, bl4)) | 0;\n    mid = (mid + Math.imul(al3, bh4)) | 0;\n    mid = (mid + Math.imul(ah3, bl4)) | 0;\n    hi = (hi + Math.imul(ah3, bh4)) | 0;\n    lo = (lo + Math.imul(al2, bl5)) | 0;\n    mid = (mid + Math.imul(al2, bh5)) | 0;\n    mid = (mid + Math.imul(ah2, bl5)) | 0;\n    hi = (hi + Math.imul(ah2, bh5)) | 0;\n    lo = (lo + Math.imul(al1, bl6)) | 0;\n    mid = (mid + Math.imul(al1, bh6)) | 0;\n    mid = (mid + Math.imul(ah1, bl6)) | 0;\n    hi = (hi + Math.imul(ah1, bh6)) | 0;\n    lo = (lo + Math.imul(al0, bl7)) | 0;\n    mid = (mid + Math.imul(al0, bh7)) | 0;\n    mid = (mid + Math.imul(ah0, bl7)) | 0;\n    hi = (hi + Math.imul(ah0, bh7)) | 0;\n    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\n    w7 &= 0x3ffffff;\n    /* k = 8 */\n    lo = Math.imul(al8, bl0);\n    mid = Math.imul(al8, bh0);\n    mid = (mid + Math.imul(ah8, bl0)) | 0;\n    hi = Math.imul(ah8, bh0);\n    lo = (lo + Math.imul(al7, bl1)) | 0;\n    mid = (mid + Math.imul(al7, bh1)) | 0;\n    mid = (mid + Math.imul(ah7, bl1)) | 0;\n    hi = (hi + Math.imul(ah7, bh1)) | 0;\n    lo = (lo + Math.imul(al6, bl2)) | 0;\n    mid = (mid + Math.imul(al6, bh2)) | 0;\n    mid = (mid + Math.imul(ah6, bl2)) | 0;\n    hi = (hi + Math.imul(ah6, bh2)) | 0;\n    lo = (lo + Math.imul(al5, bl3)) | 0;\n    mid = (mid + Math.imul(al5, bh3)) | 0;\n    mid = (mid + Math.imul(ah5, bl3)) | 0;\n    hi = (hi + Math.imul(ah5, bh3)) | 0;\n    lo = (lo + Math.imul(al4, bl4)) | 0;\n    mid = (mid + Math.imul(al4, bh4)) | 0;\n    mid = (mid + Math.imul(ah4, bl4)) | 0;\n    hi = (hi + Math.imul(ah4, bh4)) | 0;\n    lo = (lo + Math.imul(al3, bl5)) | 0;\n    mid = (mid + Math.imul(al3, bh5)) | 0;\n    mid = (mid + Math.imul(ah3, bl5)) | 0;\n    hi = (hi + Math.imul(ah3, bh5)) | 0;\n    lo = (lo + Math.imul(al2, bl6)) | 0;\n    mid = (mid + Math.imul(al2, bh6)) | 0;\n    mid = (mid + Math.imul(ah2, bl6)) | 0;\n    hi = (hi + Math.imul(ah2, bh6)) | 0;\n    lo = (lo + Math.imul(al1, bl7)) | 0;\n    mid = (mid + Math.imul(al1, bh7)) | 0;\n    mid = (mid + Math.imul(ah1, bl7)) | 0;\n    hi = (hi + Math.imul(ah1, bh7)) | 0;\n    lo = (lo + Math.imul(al0, bl8)) | 0;\n    mid = (mid + Math.imul(al0, bh8)) | 0;\n    mid = (mid + Math.imul(ah0, bl8)) | 0;\n    hi = (hi + Math.imul(ah0, bh8)) | 0;\n    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\n    w8 &= 0x3ffffff;\n    /* k = 9 */\n    lo = Math.imul(al9, bl0);\n    mid = Math.imul(al9, bh0);\n    mid = (mid + Math.imul(ah9, bl0)) | 0;\n    hi = Math.imul(ah9, bh0);\n    lo = (lo + Math.imul(al8, bl1)) | 0;\n    mid = (mid + Math.imul(al8, bh1)) | 0;\n    mid = (mid + Math.imul(ah8, bl1)) | 0;\n    hi = (hi + Math.imul(ah8, bh1)) | 0;\n    lo = (lo + Math.imul(al7, bl2)) | 0;\n    mid = (mid + Math.imul(al7, bh2)) | 0;\n    mid = (mid + Math.imul(ah7, bl2)) | 0;\n    hi = (hi + Math.imul(ah7, bh2)) | 0;\n    lo = (lo + Math.imul(al6, bl3)) | 0;\n    mid = (mid + Math.imul(al6, bh3)) | 0;\n    mid = (mid + Math.imul(ah6, bl3)) | 0;\n    hi = (hi + Math.imul(ah6, bh3)) | 0;\n    lo = (lo + Math.imul(al5, bl4)) | 0;\n    mid = (mid + Math.imul(al5, bh4)) | 0;\n    mid = (mid + Math.imul(ah5, bl4)) | 0;\n    hi = (hi + Math.imul(ah5, bh4)) | 0;\n    lo = (lo + Math.imul(al4, bl5)) | 0;\n    mid = (mid + Math.imul(al4, bh5)) | 0;\n    mid = (mid + Math.imul(ah4, bl5)) | 0;\n    hi = (hi + Math.imul(ah4, bh5)) | 0;\n    lo = (lo + Math.imul(al3, bl6)) | 0;\n    mid = (mid + Math.imul(al3, bh6)) | 0;\n    mid = (mid + Math.imul(ah3, bl6)) | 0;\n    hi = (hi + Math.imul(ah3, bh6)) | 0;\n    lo = (lo + Math.imul(al2, bl7)) | 0;\n    mid = (mid + Math.imul(al2, bh7)) | 0;\n    mid = (mid + Math.imul(ah2, bl7)) | 0;\n    hi = (hi + Math.imul(ah2, bh7)) | 0;\n    lo = (lo + Math.imul(al1, bl8)) | 0;\n    mid = (mid + Math.imul(al1, bh8)) | 0;\n    mid = (mid + Math.imul(ah1, bl8)) | 0;\n    hi = (hi + Math.imul(ah1, bh8)) | 0;\n    lo = (lo + Math.imul(al0, bl9)) | 0;\n    mid = (mid + Math.imul(al0, bh9)) | 0;\n    mid = (mid + Math.imul(ah0, bl9)) | 0;\n    hi = (hi + Math.imul(ah0, bh9)) | 0;\n    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\n    w9 &= 0x3ffffff;\n    /* k = 10 */\n    lo = Math.imul(al9, bl1);\n    mid = Math.imul(al9, bh1);\n    mid = (mid + Math.imul(ah9, bl1)) | 0;\n    hi = Math.imul(ah9, bh1);\n    lo = (lo + Math.imul(al8, bl2)) | 0;\n    mid = (mid + Math.imul(al8, bh2)) | 0;\n    mid = (mid + Math.imul(ah8, bl2)) | 0;\n    hi = (hi + Math.imul(ah8, bh2)) | 0;\n    lo = (lo + Math.imul(al7, bl3)) | 0;\n    mid = (mid + Math.imul(al7, bh3)) | 0;\n    mid = (mid + Math.imul(ah7, bl3)) | 0;\n    hi = (hi + Math.imul(ah7, bh3)) | 0;\n    lo = (lo + Math.imul(al6, bl4)) | 0;\n    mid = (mid + Math.imul(al6, bh4)) | 0;\n    mid = (mid + Math.imul(ah6, bl4)) | 0;\n    hi = (hi + Math.imul(ah6, bh4)) | 0;\n    lo = (lo + Math.imul(al5, bl5)) | 0;\n    mid = (mid + Math.imul(al5, bh5)) | 0;\n    mid = (mid + Math.imul(ah5, bl5)) | 0;\n    hi = (hi + Math.imul(ah5, bh5)) | 0;\n    lo = (lo + Math.imul(al4, bl6)) | 0;\n    mid = (mid + Math.imul(al4, bh6)) | 0;\n    mid = (mid + Math.imul(ah4, bl6)) | 0;\n    hi = (hi + Math.imul(ah4, bh6)) | 0;\n    lo = (lo + Math.imul(al3, bl7)) | 0;\n    mid = (mid + Math.imul(al3, bh7)) | 0;\n    mid = (mid + Math.imul(ah3, bl7)) | 0;\n    hi = (hi + Math.imul(ah3, bh7)) | 0;\n    lo = (lo + Math.imul(al2, bl8)) | 0;\n    mid = (mid + Math.imul(al2, bh8)) | 0;\n    mid = (mid + Math.imul(ah2, bl8)) | 0;\n    hi = (hi + Math.imul(ah2, bh8)) | 0;\n    lo = (lo + Math.imul(al1, bl9)) | 0;\n    mid = (mid + Math.imul(al1, bh9)) | 0;\n    mid = (mid + Math.imul(ah1, bl9)) | 0;\n    hi = (hi + Math.imul(ah1, bh9)) | 0;\n    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\n    w10 &= 0x3ffffff;\n    /* k = 11 */\n    lo = Math.imul(al9, bl2);\n    mid = Math.imul(al9, bh2);\n    mid = (mid + Math.imul(ah9, bl2)) | 0;\n    hi = Math.imul(ah9, bh2);\n    lo = (lo + Math.imul(al8, bl3)) | 0;\n    mid = (mid + Math.imul(al8, bh3)) | 0;\n    mid = (mid + Math.imul(ah8, bl3)) | 0;\n    hi = (hi + Math.imul(ah8, bh3)) | 0;\n    lo = (lo + Math.imul(al7, bl4)) | 0;\n    mid = (mid + Math.imul(al7, bh4)) | 0;\n    mid = (mid + Math.imul(ah7, bl4)) | 0;\n    hi = (hi + Math.imul(ah7, bh4)) | 0;\n    lo = (lo + Math.imul(al6, bl5)) | 0;\n    mid = (mid + Math.imul(al6, bh5)) | 0;\n    mid = (mid + Math.imul(ah6, bl5)) | 0;\n    hi = (hi + Math.imul(ah6, bh5)) | 0;\n    lo = (lo + Math.imul(al5, bl6)) | 0;\n    mid = (mid + Math.imul(al5, bh6)) | 0;\n    mid = (mid + Math.imul(ah5, bl6)) | 0;\n    hi = (hi + Math.imul(ah5, bh6)) | 0;\n    lo = (lo + Math.imul(al4, bl7)) | 0;\n    mid = (mid + Math.imul(al4, bh7)) | 0;\n    mid = (mid + Math.imul(ah4, bl7)) | 0;\n    hi = (hi + Math.imul(ah4, bh7)) | 0;\n    lo = (lo + Math.imul(al3, bl8)) | 0;\n    mid = (mid + Math.imul(al3, bh8)) | 0;\n    mid = (mid + Math.imul(ah3, bl8)) | 0;\n    hi = (hi + Math.imul(ah3, bh8)) | 0;\n    lo = (lo + Math.imul(al2, bl9)) | 0;\n    mid = (mid + Math.imul(al2, bh9)) | 0;\n    mid = (mid + Math.imul(ah2, bl9)) | 0;\n    hi = (hi + Math.imul(ah2, bh9)) | 0;\n    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\n    w11 &= 0x3ffffff;\n    /* k = 12 */\n    lo = Math.imul(al9, bl3);\n    mid = Math.imul(al9, bh3);\n    mid = (mid + Math.imul(ah9, bl3)) | 0;\n    hi = Math.imul(ah9, bh3);\n    lo = (lo + Math.imul(al8, bl4)) | 0;\n    mid = (mid + Math.imul(al8, bh4)) | 0;\n    mid = (mid + Math.imul(ah8, bl4)) | 0;\n    hi = (hi + Math.imul(ah8, bh4)) | 0;\n    lo = (lo + Math.imul(al7, bl5)) | 0;\n    mid = (mid + Math.imul(al7, bh5)) | 0;\n    mid = (mid + Math.imul(ah7, bl5)) | 0;\n    hi = (hi + Math.imul(ah7, bh5)) | 0;\n    lo = (lo + Math.imul(al6, bl6)) | 0;\n    mid = (mid + Math.imul(al6, bh6)) | 0;\n    mid = (mid + Math.imul(ah6, bl6)) | 0;\n    hi = (hi + Math.imul(ah6, bh6)) | 0;\n    lo = (lo + Math.imul(al5, bl7)) | 0;\n    mid = (mid + Math.imul(al5, bh7)) | 0;\n    mid = (mid + Math.imul(ah5, bl7)) | 0;\n    hi = (hi + Math.imul(ah5, bh7)) | 0;\n    lo = (lo + Math.imul(al4, bl8)) | 0;\n    mid = (mid + Math.imul(al4, bh8)) | 0;\n    mid = (mid + Math.imul(ah4, bl8)) | 0;\n    hi = (hi + Math.imul(ah4, bh8)) | 0;\n    lo = (lo + Math.imul(al3, bl9)) | 0;\n    mid = (mid + Math.imul(al3, bh9)) | 0;\n    mid = (mid + Math.imul(ah3, bl9)) | 0;\n    hi = (hi + Math.imul(ah3, bh9)) | 0;\n    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\n    w12 &= 0x3ffffff;\n    /* k = 13 */\n    lo = Math.imul(al9, bl4);\n    mid = Math.imul(al9, bh4);\n    mid = (mid + Math.imul(ah9, bl4)) | 0;\n    hi = Math.imul(ah9, bh4);\n    lo = (lo + Math.imul(al8, bl5)) | 0;\n    mid = (mid + Math.imul(al8, bh5)) | 0;\n    mid = (mid + Math.imul(ah8, bl5)) | 0;\n    hi = (hi + Math.imul(ah8, bh5)) | 0;\n    lo = (lo + Math.imul(al7, bl6)) | 0;\n    mid = (mid + Math.imul(al7, bh6)) | 0;\n    mid = (mid + Math.imul(ah7, bl6)) | 0;\n    hi = (hi + Math.imul(ah7, bh6)) | 0;\n    lo = (lo + Math.imul(al6, bl7)) | 0;\n    mid = (mid + Math.imul(al6, bh7)) | 0;\n    mid = (mid + Math.imul(ah6, bl7)) | 0;\n    hi = (hi + Math.imul(ah6, bh7)) | 0;\n    lo = (lo + Math.imul(al5, bl8)) | 0;\n    mid = (mid + Math.imul(al5, bh8)) | 0;\n    mid = (mid + Math.imul(ah5, bl8)) | 0;\n    hi = (hi + Math.imul(ah5, bh8)) | 0;\n    lo = (lo + Math.imul(al4, bl9)) | 0;\n    mid = (mid + Math.imul(al4, bh9)) | 0;\n    mid = (mid + Math.imul(ah4, bl9)) | 0;\n    hi = (hi + Math.imul(ah4, bh9)) | 0;\n    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\n    w13 &= 0x3ffffff;\n    /* k = 14 */\n    lo = Math.imul(al9, bl5);\n    mid = Math.imul(al9, bh5);\n    mid = (mid + Math.imul(ah9, bl5)) | 0;\n    hi = Math.imul(ah9, bh5);\n    lo = (lo + Math.imul(al8, bl6)) | 0;\n    mid = (mid + Math.imul(al8, bh6)) | 0;\n    mid = (mid + Math.imul(ah8, bl6)) | 0;\n    hi = (hi + Math.imul(ah8, bh6)) | 0;\n    lo = (lo + Math.imul(al7, bl7)) | 0;\n    mid = (mid + Math.imul(al7, bh7)) | 0;\n    mid = (mid + Math.imul(ah7, bl7)) | 0;\n    hi = (hi + Math.imul(ah7, bh7)) | 0;\n    lo = (lo + Math.imul(al6, bl8)) | 0;\n    mid = (mid + Math.imul(al6, bh8)) | 0;\n    mid = (mid + Math.imul(ah6, bl8)) | 0;\n    hi = (hi + Math.imul(ah6, bh8)) | 0;\n    lo = (lo + Math.imul(al5, bl9)) | 0;\n    mid = (mid + Math.imul(al5, bh9)) | 0;\n    mid = (mid + Math.imul(ah5, bl9)) | 0;\n    hi = (hi + Math.imul(ah5, bh9)) | 0;\n    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\n    w14 &= 0x3ffffff;\n    /* k = 15 */\n    lo = Math.imul(al9, bl6);\n    mid = Math.imul(al9, bh6);\n    mid = (mid + Math.imul(ah9, bl6)) | 0;\n    hi = Math.imul(ah9, bh6);\n    lo = (lo + Math.imul(al8, bl7)) | 0;\n    mid = (mid + Math.imul(al8, bh7)) | 0;\n    mid = (mid + Math.imul(ah8, bl7)) | 0;\n    hi = (hi + Math.imul(ah8, bh7)) | 0;\n    lo = (lo + Math.imul(al7, bl8)) | 0;\n    mid = (mid + Math.imul(al7, bh8)) | 0;\n    mid = (mid + Math.imul(ah7, bl8)) | 0;\n    hi = (hi + Math.imul(ah7, bh8)) | 0;\n    lo = (lo + Math.imul(al6, bl9)) | 0;\n    mid = (mid + Math.imul(al6, bh9)) | 0;\n    mid = (mid + Math.imul(ah6, bl9)) | 0;\n    hi = (hi + Math.imul(ah6, bh9)) | 0;\n    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\n    w15 &= 0x3ffffff;\n    /* k = 16 */\n    lo = Math.imul(al9, bl7);\n    mid = Math.imul(al9, bh7);\n    mid = (mid + Math.imul(ah9, bl7)) | 0;\n    hi = Math.imul(ah9, bh7);\n    lo = (lo + Math.imul(al8, bl8)) | 0;\n    mid = (mid + Math.imul(al8, bh8)) | 0;\n    mid = (mid + Math.imul(ah8, bl8)) | 0;\n    hi = (hi + Math.imul(ah8, bh8)) | 0;\n    lo = (lo + Math.imul(al7, bl9)) | 0;\n    mid = (mid + Math.imul(al7, bh9)) | 0;\n    mid = (mid + Math.imul(ah7, bl9)) | 0;\n    hi = (hi + Math.imul(ah7, bh9)) | 0;\n    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\n    w16 &= 0x3ffffff;\n    /* k = 17 */\n    lo = Math.imul(al9, bl8);\n    mid = Math.imul(al9, bh8);\n    mid = (mid + Math.imul(ah9, bl8)) | 0;\n    hi = Math.imul(ah9, bh8);\n    lo = (lo + Math.imul(al8, bl9)) | 0;\n    mid = (mid + Math.imul(al8, bh9)) | 0;\n    mid = (mid + Math.imul(ah8, bl9)) | 0;\n    hi = (hi + Math.imul(ah8, bh9)) | 0;\n    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\n    w17 &= 0x3ffffff;\n    /* k = 18 */\n    lo = Math.imul(al9, bl9);\n    mid = Math.imul(al9, bh9);\n    mid = (mid + Math.imul(ah9, bl9)) | 0;\n    hi = Math.imul(ah9, bh9);\n    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\n    w18 &= 0x3ffffff;\n    o[0] = w0;\n    o[1] = w1;\n    o[2] = w2;\n    o[3] = w3;\n    o[4] = w4;\n    o[5] = w5;\n    o[6] = w6;\n    o[7] = w7;\n    o[8] = w8;\n    o[9] = w9;\n    o[10] = w10;\n    o[11] = w11;\n    o[12] = w12;\n    o[13] = w13;\n    o[14] = w14;\n    o[15] = w15;\n    o[16] = w16;\n    o[17] = w17;\n    o[18] = w18;\n    if (c !== 0) {\n      o[19] = c;\n      out.length++;\n    }\n    return out;\n  };\n\n  // Polyfill comb\n  if (!Math.imul) {\n    comb10MulTo = smallMulTo;\n  }\n\n  function bigMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    out.length = self.length + num.length;\n\n    var carry = 0;\n    var hncarry = 0;\n    for (var k = 0; k < out.length - 1; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = hncarry;\n      hncarry = 0;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = k - j;\n        var a = self.words[i] | 0;\n        var b = num.words[j] | 0;\n        var r = a * b;\n\n        var lo = r & 0x3ffffff;\n        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n        lo = (lo + rword) | 0;\n        rword = lo & 0x3ffffff;\n        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n        hncarry += ncarry >>> 26;\n        ncarry &= 0x3ffffff;\n      }\n      out.words[k] = rword;\n      carry = ncarry;\n      ncarry = hncarry;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry;\n    } else {\n      out.length--;\n    }\n\n    return out.strip();\n  }\n\n  function jumboMulTo (self, num, out) {\n    var fftm = new FFTM();\n    return fftm.mulp(self, num, out);\n  }\n\n  BN.prototype.mulTo = function mulTo (num, out) {\n    var res;\n    var len = this.length + num.length;\n    if (this.length === 10 && num.length === 10) {\n      res = comb10MulTo(this, num, out);\n    } else if (len < 63) {\n      res = smallMulTo(this, num, out);\n    } else if (len < 1024) {\n      res = bigMulTo(this, num, out);\n    } else {\n      res = jumboMulTo(this, num, out);\n    }\n\n    return res;\n  };\n\n  // Cooley-Tukey algorithm for FFT\n  // slightly revisited to rely on looping instead of recursion\n\n  function FFTM (x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  FFTM.prototype.makeRBT = function makeRBT (N) {\n    var t = new Array(N);\n    var l = BN.prototype._countBits(N) - 1;\n    for (var i = 0; i < N; i++) {\n      t[i] = this.revBin(i, l, N);\n    }\n\n    return t;\n  };\n\n  // Returns binary-reversed representation of `x`\n  FFTM.prototype.revBin = function revBin (x, l, N) {\n    if (x === 0 || x === N - 1) return x;\n\n    var rb = 0;\n    for (var i = 0; i < l; i++) {\n      rb |= (x & 1) << (l - i - 1);\n      x >>= 1;\n    }\n\n    return rb;\n  };\n\n  // Performs \"tweedling\" phase, therefore 'emulating'\n  // behaviour of the recursive algorithm\n  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n    for (var i = 0; i < N; i++) {\n      rtws[i] = rws[rbt[i]];\n      itws[i] = iws[rbt[i]];\n    }\n  };\n\n  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n    this.permute(rbt, rws, iws, rtws, itws, N);\n\n    for (var s = 1; s < N; s <<= 1) {\n      var l = s << 1;\n\n      var rtwdf = Math.cos(2 * Math.PI / l);\n      var itwdf = Math.sin(2 * Math.PI / l);\n\n      for (var p = 0; p < N; p += l) {\n        var rtwdf_ = rtwdf;\n        var itwdf_ = itwdf;\n\n        for (var j = 0; j < s; j++) {\n          var re = rtws[p + j];\n          var ie = itws[p + j];\n\n          var ro = rtws[p + j + s];\n          var io = itws[p + j + s];\n\n          var rx = rtwdf_ * ro - itwdf_ * io;\n\n          io = rtwdf_ * io + itwdf_ * ro;\n          ro = rx;\n\n          rtws[p + j] = re + ro;\n          itws[p + j] = ie + io;\n\n          rtws[p + j + s] = re - ro;\n          itws[p + j + s] = ie - io;\n\n          /* jshint maxdepth : false */\n          if (j !== l) {\n            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n            rtwdf_ = rx;\n          }\n        }\n      }\n    }\n  };\n\n  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n    var N = Math.max(m, n) | 1;\n    var odd = N & 1;\n    var i = 0;\n    for (N = N / 2 | 0; N; N = N >>> 1) {\n      i++;\n    }\n\n    return 1 << i + 1 + odd;\n  };\n\n  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n    if (N <= 1) return;\n\n    for (var i = 0; i < N / 2; i++) {\n      var t = rws[i];\n\n      rws[i] = rws[N - i - 1];\n      rws[N - i - 1] = t;\n\n      t = iws[i];\n\n      iws[i] = -iws[N - i - 1];\n      iws[N - i - 1] = -t;\n    }\n  };\n\n  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n    var carry = 0;\n    for (var i = 0; i < N / 2; i++) {\n      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n        Math.round(ws[2 * i] / N) +\n        carry;\n\n      ws[i] = w & 0x3ffffff;\n\n      if (w < 0x4000000) {\n        carry = 0;\n      } else {\n        carry = w / 0x4000000 | 0;\n      }\n    }\n\n    return ws;\n  };\n\n  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n    var carry = 0;\n    for (var i = 0; i < len; i++) {\n      carry = carry + (ws[i] | 0);\n\n      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n    }\n\n    // Pad with zeroes\n    for (i = 2 * len; i < N; ++i) {\n      rws[i] = 0;\n    }\n\n    assert(carry === 0);\n    assert((carry & ~0x1fff) === 0);\n  };\n\n  FFTM.prototype.stub = function stub (N) {\n    var ph = new Array(N);\n    for (var i = 0; i < N; i++) {\n      ph[i] = 0;\n    }\n\n    return ph;\n  };\n\n  FFTM.prototype.mulp = function mulp (x, y, out) {\n    var N = 2 * this.guessLen13b(x.length, y.length);\n\n    var rbt = this.makeRBT(N);\n\n    var _ = this.stub(N);\n\n    var rws = new Array(N);\n    var rwst = new Array(N);\n    var iwst = new Array(N);\n\n    var nrws = new Array(N);\n    var nrwst = new Array(N);\n    var niwst = new Array(N);\n\n    var rmws = out.words;\n    rmws.length = N;\n\n    this.convert13b(x.words, x.length, rws, N);\n    this.convert13b(y.words, y.length, nrws, N);\n\n    this.transform(rws, _, rwst, iwst, N, rbt);\n    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n    for (var i = 0; i < N; i++) {\n      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n      rwst[i] = rx;\n    }\n\n    this.conjugate(rwst, iwst, N);\n    this.transform(rwst, iwst, rmws, _, N, rbt);\n    this.conjugate(rmws, _, N);\n    this.normalize13b(rmws, N);\n\n    out.negative = x.negative ^ y.negative;\n    out.length = x.length + y.length;\n    return out.strip();\n  };\n\n  // Multiply `this` by `num`\n  BN.prototype.mul = function mul (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return this.mulTo(num, out);\n  };\n\n  // Multiply employing FFT\n  BN.prototype.mulf = function mulf (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return jumboMulTo(this, num, out);\n  };\n\n  // In-place Multiplication\n  BN.prototype.imul = function imul (num) {\n    return this.clone().mulTo(num, this);\n  };\n\n  BN.prototype.imuln = function imuln (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n\n    // Carry\n    var carry = 0;\n    for (var i = 0; i < this.length; i++) {\n      var w = (this.words[i] | 0) * num;\n      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n      carry >>= 26;\n      carry += (w / 0x4000000) | 0;\n      // NOTE: lo is 27bit maximum\n      carry += lo >>> 26;\n      this.words[i] = lo & 0x3ffffff;\n    }\n\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n\n    return this;\n  };\n\n  BN.prototype.muln = function muln (num) {\n    return this.clone().imuln(num);\n  };\n\n  // `this` * `this`\n  BN.prototype.sqr = function sqr () {\n    return this.mul(this);\n  };\n\n  // `this` * `this` in-place\n  BN.prototype.isqr = function isqr () {\n    return this.imul(this.clone());\n  };\n\n  // Math.pow(`this`, `num`)\n  BN.prototype.pow = function pow (num) {\n    var w = toBitArray(num);\n    if (w.length === 0) return new BN(1);\n\n    // Skip leading zeroes\n    var res = this;\n    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n      if (w[i] !== 0) break;\n    }\n\n    if (++i < w.length) {\n      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n        if (w[i] === 0) continue;\n\n        res = res.mul(q);\n      }\n    }\n\n    return res;\n  };\n\n  // Shift-left in-place\n  BN.prototype.iushln = function iushln (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n    var i;\n\n    if (r !== 0) {\n      var carry = 0;\n\n      for (i = 0; i < this.length; i++) {\n        var newCarry = this.words[i] & carryMask;\n        var c = ((this.words[i] | 0) - newCarry) << r;\n        this.words[i] = c | carry;\n        carry = newCarry >>> (26 - r);\n      }\n\n      if (carry) {\n        this.words[i] = carry;\n        this.length++;\n      }\n    }\n\n    if (s !== 0) {\n      for (i = this.length - 1; i >= 0; i--) {\n        this.words[i + s] = this.words[i];\n      }\n\n      for (i = 0; i < s; i++) {\n        this.words[i] = 0;\n      }\n\n      this.length += s;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ishln = function ishln (bits) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushln(bits);\n  };\n\n  // Shift-right in-place\n  // NOTE: `hint` is a lowest bit before trailing zeroes\n  // NOTE: if `extended` is present - it will be filled with destroyed bits\n  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var h;\n    if (hint) {\n      h = (hint - (hint % 26)) / 26;\n    } else {\n      h = 0;\n    }\n\n    var r = bits % 26;\n    var s = Math.min((bits - r) / 26, this.length);\n    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n    var maskedWords = extended;\n\n    h -= s;\n    h = Math.max(0, h);\n\n    // Extended mode, copy masked part\n    if (maskedWords) {\n      for (var i = 0; i < s; i++) {\n        maskedWords.words[i] = this.words[i];\n      }\n      maskedWords.length = s;\n    }\n\n    if (s === 0) {\n      // No-op, we should not move anything at all\n    } else if (this.length > s) {\n      this.length -= s;\n      for (i = 0; i < this.length; i++) {\n        this.words[i] = this.words[i + s];\n      }\n    } else {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    var carry = 0;\n    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n      var word = this.words[i] | 0;\n      this.words[i] = (carry << (26 - r)) | (word >>> r);\n      carry = word & mask;\n    }\n\n    // Push carried bits as a mask\n    if (maskedWords && carry !== 0) {\n      maskedWords.words[maskedWords.length++] = carry;\n    }\n\n    if (this.length === 0) {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushrn(bits, hint, extended);\n  };\n\n  // Shift-left\n  BN.prototype.shln = function shln (bits) {\n    return this.clone().ishln(bits);\n  };\n\n  BN.prototype.ushln = function ushln (bits) {\n    return this.clone().iushln(bits);\n  };\n\n  // Shift-right\n  BN.prototype.shrn = function shrn (bits) {\n    return this.clone().ishrn(bits);\n  };\n\n  BN.prototype.ushrn = function ushrn (bits) {\n    return this.clone().iushrn(bits);\n  };\n\n  // Test if n bit is set\n  BN.prototype.testn = function testn (bit) {\n    assert(typeof bit === 'number' && bit >= 0);\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) return false;\n\n    // Check bit and return\n    var w = this.words[s];\n\n    return !!(w & q);\n  };\n\n  // Return only lowers bits of number (in-place)\n  BN.prototype.imaskn = function imaskn (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n\n    assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n    if (this.length <= s) {\n      return this;\n    }\n\n    if (r !== 0) {\n      s++;\n    }\n    this.length = Math.min(s, this.length);\n\n    if (r !== 0) {\n      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n      this.words[this.length - 1] &= mask;\n    }\n\n    return this.strip();\n  };\n\n  // Return only lowers bits of number\n  BN.prototype.maskn = function maskn (bits) {\n    return this.clone().imaskn(bits);\n  };\n\n  // Add plain number `num` to `this`\n  BN.prototype.iaddn = function iaddn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.isubn(-num);\n\n    // Possible sign change\n    if (this.negative !== 0) {\n      if (this.length === 1 && (this.words[0] | 0) < num) {\n        this.words[0] = num - (this.words[0] | 0);\n        this.negative = 0;\n        return this;\n      }\n\n      this.negative = 0;\n      this.isubn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    // Add without checks\n    return this._iaddn(num);\n  };\n\n  BN.prototype._iaddn = function _iaddn (num) {\n    this.words[0] += num;\n\n    // Carry\n    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n      this.words[i] -= 0x4000000;\n      if (i === this.length - 1) {\n        this.words[i + 1] = 1;\n      } else {\n        this.words[i + 1]++;\n      }\n    }\n    this.length = Math.max(this.length, i + 1);\n\n    return this;\n  };\n\n  // Subtract plain number `num` from `this`\n  BN.prototype.isubn = function isubn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.iaddn(-num);\n\n    if (this.negative !== 0) {\n      this.negative = 0;\n      this.iaddn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    this.words[0] -= num;\n\n    if (this.length === 1 && this.words[0] < 0) {\n      this.words[0] = -this.words[0];\n      this.negative = 1;\n    } else {\n      // Carry\n      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n        this.words[i] += 0x4000000;\n        this.words[i + 1] -= 1;\n      }\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.addn = function addn (num) {\n    return this.clone().iaddn(num);\n  };\n\n  BN.prototype.subn = function subn (num) {\n    return this.clone().isubn(num);\n  };\n\n  BN.prototype.iabs = function iabs () {\n    this.negative = 0;\n\n    return this;\n  };\n\n  BN.prototype.abs = function abs () {\n    return this.clone().iabs();\n  };\n\n  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n    var len = num.length + shift;\n    var i;\n\n    this._expand(len);\n\n    var w;\n    var carry = 0;\n    for (i = 0; i < num.length; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      var right = (num.words[i] | 0) * mul;\n      w -= right & 0x3ffffff;\n      carry = (w >> 26) - ((right / 0x4000000) | 0);\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n    for (; i < this.length - shift; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      carry = w >> 26;\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    if (carry === 0) return this.strip();\n\n    // Subtraction overflow\n    assert(carry === -1);\n    carry = 0;\n    for (i = 0; i < this.length; i++) {\n      w = -(this.words[i] | 0) + carry;\n      carry = w >> 26;\n      this.words[i] = w & 0x3ffffff;\n    }\n    this.negative = 1;\n\n    return this.strip();\n  };\n\n  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n    var shift = this.length - num.length;\n\n    var a = this.clone();\n    var b = num;\n\n    // Normalize\n    var bhi = b.words[b.length - 1] | 0;\n    var bhiBits = this._countBits(bhi);\n    shift = 26 - bhiBits;\n    if (shift !== 0) {\n      b = b.ushln(shift);\n      a.iushln(shift);\n      bhi = b.words[b.length - 1] | 0;\n    }\n\n    // Initialize quotient\n    var m = a.length - b.length;\n    var q;\n\n    if (mode !== 'mod') {\n      q = new BN(null);\n      q.length = m + 1;\n      q.words = new Array(q.length);\n      for (var i = 0; i < q.length; i++) {\n        q.words[i] = 0;\n      }\n    }\n\n    var diff = a.clone()._ishlnsubmul(b, 1, m);\n    if (diff.negative === 0) {\n      a = diff;\n      if (q) {\n        q.words[m] = 1;\n      }\n    }\n\n    for (var j = m - 1; j >= 0; j--) {\n      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n        (a.words[b.length + j - 1] | 0);\n\n      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n      // (0x7ffffff)\n      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n      a._ishlnsubmul(b, qj, j);\n      while (a.negative !== 0) {\n        qj--;\n        a.negative = 0;\n        a._ishlnsubmul(b, 1, j);\n        if (!a.isZero()) {\n          a.negative ^= 1;\n        }\n      }\n      if (q) {\n        q.words[j] = qj;\n      }\n    }\n    if (q) {\n      q.strip();\n    }\n    a.strip();\n\n    // Denormalize\n    if (mode !== 'div' && shift !== 0) {\n      a.iushrn(shift);\n    }\n\n    return {\n      div: q || null,\n      mod: a\n    };\n  };\n\n  // NOTE: 1) `mode` can be set to `mod` to request mod only,\n  //       to `div` to request div only, or be absent to\n  //       request both div & mod\n  //       2) `positive` is true if unsigned mod is requested\n  BN.prototype.divmod = function divmod (num, mode, positive) {\n    assert(!num.isZero());\n\n    if (this.isZero()) {\n      return {\n        div: new BN(0),\n        mod: new BN(0)\n      };\n    }\n\n    var div, mod, res;\n    if (this.negative !== 0 && num.negative === 0) {\n      res = this.neg().divmod(num, mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.iadd(num);\n        }\n      }\n\n      return {\n        div: div,\n        mod: mod\n      };\n    }\n\n    if (this.negative === 0 && num.negative !== 0) {\n      res = this.divmod(num.neg(), mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      return {\n        div: div,\n        mod: res.mod\n      };\n    }\n\n    if ((this.negative & num.negative) !== 0) {\n      res = this.neg().divmod(num.neg(), mode);\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.isub(num);\n        }\n      }\n\n      return {\n        div: res.div,\n        mod: mod\n      };\n    }\n\n    // Both numbers are positive at this point\n\n    // Strip both numbers to approximate shift value\n    if (num.length > this.length || this.cmp(num) < 0) {\n      return {\n        div: new BN(0),\n        mod: this\n      };\n    }\n\n    // Very short reduction\n    if (num.length === 1) {\n      if (mode === 'div') {\n        return {\n          div: this.divn(num.words[0]),\n          mod: null\n        };\n      }\n\n      if (mode === 'mod') {\n        return {\n          div: null,\n          mod: new BN(this.modn(num.words[0]))\n        };\n      }\n\n      return {\n        div: this.divn(num.words[0]),\n        mod: new BN(this.modn(num.words[0]))\n      };\n    }\n\n    return this._wordDiv(num, mode);\n  };\n\n  // Find `this` / `num`\n  BN.prototype.div = function div (num) {\n    return this.divmod(num, 'div', false).div;\n  };\n\n  // Find `this` % `num`\n  BN.prototype.mod = function mod (num) {\n    return this.divmod(num, 'mod', false).mod;\n  };\n\n  BN.prototype.umod = function umod (num) {\n    return this.divmod(num, 'mod', true).mod;\n  };\n\n  // Find Round(`this` / `num`)\n  BN.prototype.divRound = function divRound (num) {\n    var dm = this.divmod(num);\n\n    // Fast case - exact division\n    if (dm.mod.isZero()) return dm.div;\n\n    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n    var half = num.ushrn(1);\n    var r2 = num.andln(1);\n    var cmp = mod.cmp(half);\n\n    // Round down\n    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;\n\n    // Round up\n    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n  };\n\n  BN.prototype.modn = function modn (num) {\n    assert(num <= 0x3ffffff);\n    var p = (1 << 26) % num;\n\n    var acc = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      acc = (p * acc + (this.words[i] | 0)) % num;\n    }\n\n    return acc;\n  };\n\n  // In-place division by number\n  BN.prototype.idivn = function idivn (num) {\n    assert(num <= 0x3ffffff);\n\n    var carry = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var w = (this.words[i] | 0) + carry * 0x4000000;\n      this.words[i] = (w / num) | 0;\n      carry = w % num;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.divn = function divn (num) {\n    return this.clone().idivn(num);\n  };\n\n  BN.prototype.egcd = function egcd (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var x = this;\n    var y = p.clone();\n\n    if (x.negative !== 0) {\n      x = x.umod(p);\n    } else {\n      x = x.clone();\n    }\n\n    // A * x + B * y = x\n    var A = new BN(1);\n    var B = new BN(0);\n\n    // C * x + D * y = y\n    var C = new BN(0);\n    var D = new BN(1);\n\n    var g = 0;\n\n    while (x.isEven() && y.isEven()) {\n      x.iushrn(1);\n      y.iushrn(1);\n      ++g;\n    }\n\n    var yp = y.clone();\n    var xp = x.clone();\n\n    while (!x.isZero()) {\n      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        x.iushrn(i);\n        while (i-- > 0) {\n          if (A.isOdd() || B.isOdd()) {\n            A.iadd(yp);\n            B.isub(xp);\n          }\n\n          A.iushrn(1);\n          B.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        y.iushrn(j);\n        while (j-- > 0) {\n          if (C.isOdd() || D.isOdd()) {\n            C.iadd(yp);\n            D.isub(xp);\n          }\n\n          C.iushrn(1);\n          D.iushrn(1);\n        }\n      }\n\n      if (x.cmp(y) >= 0) {\n        x.isub(y);\n        A.isub(C);\n        B.isub(D);\n      } else {\n        y.isub(x);\n        C.isub(A);\n        D.isub(B);\n      }\n    }\n\n    return {\n      a: C,\n      b: D,\n      gcd: y.iushln(g)\n    };\n  };\n\n  // This is reduced incarnation of the binary EEA\n  // above, designated to invert members of the\n  // _prime_ fields F(p) at a maximal speed\n  BN.prototype._invmp = function _invmp (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var a = this;\n    var b = p.clone();\n\n    if (a.negative !== 0) {\n      a = a.umod(p);\n    } else {\n      a = a.clone();\n    }\n\n    var x1 = new BN(1);\n    var x2 = new BN(0);\n\n    var delta = b.clone();\n\n    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        a.iushrn(i);\n        while (i-- > 0) {\n          if (x1.isOdd()) {\n            x1.iadd(delta);\n          }\n\n          x1.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        b.iushrn(j);\n        while (j-- > 0) {\n          if (x2.isOdd()) {\n            x2.iadd(delta);\n          }\n\n          x2.iushrn(1);\n        }\n      }\n\n      if (a.cmp(b) >= 0) {\n        a.isub(b);\n        x1.isub(x2);\n      } else {\n        b.isub(a);\n        x2.isub(x1);\n      }\n    }\n\n    var res;\n    if (a.cmpn(1) === 0) {\n      res = x1;\n    } else {\n      res = x2;\n    }\n\n    if (res.cmpn(0) < 0) {\n      res.iadd(p);\n    }\n\n    return res;\n  };\n\n  BN.prototype.gcd = function gcd (num) {\n    if (this.isZero()) return num.abs();\n    if (num.isZero()) return this.abs();\n\n    var a = this.clone();\n    var b = num.clone();\n    a.negative = 0;\n    b.negative = 0;\n\n    // Remove common factor of two\n    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n      a.iushrn(1);\n      b.iushrn(1);\n    }\n\n    do {\n      while (a.isEven()) {\n        a.iushrn(1);\n      }\n      while (b.isEven()) {\n        b.iushrn(1);\n      }\n\n      var r = a.cmp(b);\n      if (r < 0) {\n        // Swap `a` and `b` to make `a` always bigger than `b`\n        var t = a;\n        a = b;\n        b = t;\n      } else if (r === 0 || b.cmpn(1) === 0) {\n        break;\n      }\n\n      a.isub(b);\n    } while (true);\n\n    return b.iushln(shift);\n  };\n\n  // Invert number in the field F(num)\n  BN.prototype.invm = function invm (num) {\n    return this.egcd(num).a.umod(num);\n  };\n\n  BN.prototype.isEven = function isEven () {\n    return (this.words[0] & 1) === 0;\n  };\n\n  BN.prototype.isOdd = function isOdd () {\n    return (this.words[0] & 1) === 1;\n  };\n\n  // And first word and num\n  BN.prototype.andln = function andln (num) {\n    return this.words[0] & num;\n  };\n\n  // Increment at the bit position in-line\n  BN.prototype.bincn = function bincn (bit) {\n    assert(typeof bit === 'number');\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) {\n      this._expand(s + 1);\n      this.words[s] |= q;\n      return this;\n    }\n\n    // Add bit and propagate, if needed\n    var carry = q;\n    for (var i = s; carry !== 0 && i < this.length; i++) {\n      var w = this.words[i] | 0;\n      w += carry;\n      carry = w >>> 26;\n      w &= 0x3ffffff;\n      this.words[i] = w;\n    }\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n    return this;\n  };\n\n  BN.prototype.isZero = function isZero () {\n    return this.length === 1 && this.words[0] === 0;\n  };\n\n  BN.prototype.cmpn = function cmpn (num) {\n    var negative = num < 0;\n\n    if (this.negative !== 0 && !negative) return -1;\n    if (this.negative === 0 && negative) return 1;\n\n    this.strip();\n\n    var res;\n    if (this.length > 1) {\n      res = 1;\n    } else {\n      if (negative) {\n        num = -num;\n      }\n\n      assert(num <= 0x3ffffff, 'Number is too big');\n\n      var w = this.words[0] | 0;\n      res = w === num ? 0 : w < num ? -1 : 1;\n    }\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Compare two numbers and return:\n  // 1 - if `this` > `num`\n  // 0 - if `this` == `num`\n  // -1 - if `this` < `num`\n  BN.prototype.cmp = function cmp (num) {\n    if (this.negative !== 0 && num.negative === 0) return -1;\n    if (this.negative === 0 && num.negative !== 0) return 1;\n\n    var res = this.ucmp(num);\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Unsigned comparison\n  BN.prototype.ucmp = function ucmp (num) {\n    // At this point both numbers have the same sign\n    if (this.length > num.length) return 1;\n    if (this.length < num.length) return -1;\n\n    var res = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var a = this.words[i] | 0;\n      var b = num.words[i] | 0;\n\n      if (a === b) continue;\n      if (a < b) {\n        res = -1;\n      } else if (a > b) {\n        res = 1;\n      }\n      break;\n    }\n    return res;\n  };\n\n  BN.prototype.gtn = function gtn (num) {\n    return this.cmpn(num) === 1;\n  };\n\n  BN.prototype.gt = function gt (num) {\n    return this.cmp(num) === 1;\n  };\n\n  BN.prototype.gten = function gten (num) {\n    return this.cmpn(num) >= 0;\n  };\n\n  BN.prototype.gte = function gte (num) {\n    return this.cmp(num) >= 0;\n  };\n\n  BN.prototype.ltn = function ltn (num) {\n    return this.cmpn(num) === -1;\n  };\n\n  BN.prototype.lt = function lt (num) {\n    return this.cmp(num) === -1;\n  };\n\n  BN.prototype.lten = function lten (num) {\n    return this.cmpn(num) <= 0;\n  };\n\n  BN.prototype.lte = function lte (num) {\n    return this.cmp(num) <= 0;\n  };\n\n  BN.prototype.eqn = function eqn (num) {\n    return this.cmpn(num) === 0;\n  };\n\n  BN.prototype.eq = function eq (num) {\n    return this.cmp(num) === 0;\n  };\n\n  //\n  // A reduce context, could be using montgomery or something better, depending\n  // on the `m` itself.\n  //\n  BN.red = function red (num) {\n    return new Red(num);\n  };\n\n  BN.prototype.toRed = function toRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    assert(this.negative === 0, 'red works only with positives');\n    return ctx.convertTo(this)._forceRed(ctx);\n  };\n\n  BN.prototype.fromRed = function fromRed () {\n    assert(this.red, 'fromRed works only with numbers in reduction context');\n    return this.red.convertFrom(this);\n  };\n\n  BN.prototype._forceRed = function _forceRed (ctx) {\n    this.red = ctx;\n    return this;\n  };\n\n  BN.prototype.forceRed = function forceRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    return this._forceRed(ctx);\n  };\n\n  BN.prototype.redAdd = function redAdd (num) {\n    assert(this.red, 'redAdd works only with red numbers');\n    return this.red.add(this, num);\n  };\n\n  BN.prototype.redIAdd = function redIAdd (num) {\n    assert(this.red, 'redIAdd works only with red numbers');\n    return this.red.iadd(this, num);\n  };\n\n  BN.prototype.redSub = function redSub (num) {\n    assert(this.red, 'redSub works only with red numbers');\n    return this.red.sub(this, num);\n  };\n\n  BN.prototype.redISub = function redISub (num) {\n    assert(this.red, 'redISub works only with red numbers');\n    return this.red.isub(this, num);\n  };\n\n  BN.prototype.redShl = function redShl (num) {\n    assert(this.red, 'redShl works only with red numbers');\n    return this.red.shl(this, num);\n  };\n\n  BN.prototype.redMul = function redMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.mul(this, num);\n  };\n\n  BN.prototype.redIMul = function redIMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.imul(this, num);\n  };\n\n  BN.prototype.redSqr = function redSqr () {\n    assert(this.red, 'redSqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqr(this);\n  };\n\n  BN.prototype.redISqr = function redISqr () {\n    assert(this.red, 'redISqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.isqr(this);\n  };\n\n  // Square root over p\n  BN.prototype.redSqrt = function redSqrt () {\n    assert(this.red, 'redSqrt works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqrt(this);\n  };\n\n  BN.prototype.redInvm = function redInvm () {\n    assert(this.red, 'redInvm works only with red numbers');\n    this.red._verify1(this);\n    return this.red.invm(this);\n  };\n\n  // Return negative clone of `this` % `red modulo`\n  BN.prototype.redNeg = function redNeg () {\n    assert(this.red, 'redNeg works only with red numbers');\n    this.red._verify1(this);\n    return this.red.neg(this);\n  };\n\n  BN.prototype.redPow = function redPow (num) {\n    assert(this.red && !num.red, 'redPow(normalNum)');\n    this.red._verify1(this);\n    return this.red.pow(this, num);\n  };\n\n  // Prime numbers with efficient reduction\n  var primes = {\n    k256: null,\n    p224: null,\n    p192: null,\n    p25519: null\n  };\n\n  // Pseudo-Mersenne prime\n  function MPrime (name, p) {\n    // P = 2 ^ N - K\n    this.name = name;\n    this.p = new BN(p, 16);\n    this.n = this.p.bitLength();\n    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n    this.tmp = this._tmp();\n  }\n\n  MPrime.prototype._tmp = function _tmp () {\n    var tmp = new BN(null);\n    tmp.words = new Array(Math.ceil(this.n / 13));\n    return tmp;\n  };\n\n  MPrime.prototype.ireduce = function ireduce (num) {\n    // Assumes that `num` is less than `P^2`\n    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n    var r = num;\n    var rlen;\n\n    do {\n      this.split(r, this.tmp);\n      r = this.imulK(r);\n      r = r.iadd(this.tmp);\n      rlen = r.bitLength();\n    } while (rlen > this.n);\n\n    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n    if (cmp === 0) {\n      r.words[0] = 0;\n      r.length = 1;\n    } else if (cmp > 0) {\n      r.isub(this.p);\n    } else {\n      if (r.strip !== undefined) {\n        // r is BN v4 instance\n        r.strip();\n      } else {\n        // r is BN v5 instance\n        r._strip();\n      }\n    }\n\n    return r;\n  };\n\n  MPrime.prototype.split = function split (input, out) {\n    input.iushrn(this.n, 0, out);\n  };\n\n  MPrime.prototype.imulK = function imulK (num) {\n    return num.imul(this.k);\n  };\n\n  function K256 () {\n    MPrime.call(\n      this,\n      'k256',\n      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n  }\n  inherits(K256, MPrime);\n\n  K256.prototype.split = function split (input, output) {\n    // 256 = 9 * 26 + 22\n    var mask = 0x3fffff;\n\n    var outLen = Math.min(input.length, 9);\n    for (var i = 0; i < outLen; i++) {\n      output.words[i] = input.words[i];\n    }\n    output.length = outLen;\n\n    if (input.length <= 9) {\n      input.words[0] = 0;\n      input.length = 1;\n      return;\n    }\n\n    // Shift by 9 limbs\n    var prev = input.words[9];\n    output.words[output.length++] = prev & mask;\n\n    for (i = 10; i < input.length; i++) {\n      var next = input.words[i] | 0;\n      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n      prev = next;\n    }\n    prev >>>= 22;\n    input.words[i - 10] = prev;\n    if (prev === 0 && input.length > 10) {\n      input.length -= 10;\n    } else {\n      input.length -= 9;\n    }\n  };\n\n  K256.prototype.imulK = function imulK (num) {\n    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n    num.words[num.length] = 0;\n    num.words[num.length + 1] = 0;\n    num.length += 2;\n\n    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n    var lo = 0;\n    for (var i = 0; i < num.length; i++) {\n      var w = num.words[i] | 0;\n      lo += w * 0x3d1;\n      num.words[i] = lo & 0x3ffffff;\n      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n    }\n\n    // Fast length reduction\n    if (num.words[num.length - 1] === 0) {\n      num.length--;\n      if (num.words[num.length - 1] === 0) {\n        num.length--;\n      }\n    }\n    return num;\n  };\n\n  function P224 () {\n    MPrime.call(\n      this,\n      'p224',\n      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n  }\n  inherits(P224, MPrime);\n\n  function P192 () {\n    MPrime.call(\n      this,\n      'p192',\n      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n  }\n  inherits(P192, MPrime);\n\n  function P25519 () {\n    // 2 ^ 255 - 19\n    MPrime.call(\n      this,\n      '25519',\n      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n  }\n  inherits(P25519, MPrime);\n\n  P25519.prototype.imulK = function imulK (num) {\n    // K = 0x13\n    var carry = 0;\n    for (var i = 0; i < num.length; i++) {\n      var hi = (num.words[i] | 0) * 0x13 + carry;\n      var lo = hi & 0x3ffffff;\n      hi >>>= 26;\n\n      num.words[i] = lo;\n      carry = hi;\n    }\n    if (carry !== 0) {\n      num.words[num.length++] = carry;\n    }\n    return num;\n  };\n\n  // Exported mostly for testing purposes, use plain name instead\n  BN._prime = function prime (name) {\n    // Cached version of prime\n    if (primes[name]) return primes[name];\n\n    var prime;\n    if (name === 'k256') {\n      prime = new K256();\n    } else if (name === 'p224') {\n      prime = new P224();\n    } else if (name === 'p192') {\n      prime = new P192();\n    } else if (name === 'p25519') {\n      prime = new P25519();\n    } else {\n      throw new Error('Unknown prime ' + name);\n    }\n    primes[name] = prime;\n\n    return prime;\n  };\n\n  //\n  // Base reduction engine\n  //\n  function Red (m) {\n    if (typeof m === 'string') {\n      var prime = BN._prime(m);\n      this.m = prime.p;\n      this.prime = prime;\n    } else {\n      assert(m.gtn(1), 'modulus must be greater than 1');\n      this.m = m;\n      this.prime = null;\n    }\n  }\n\n  Red.prototype._verify1 = function _verify1 (a) {\n    assert(a.negative === 0, 'red works only with positives');\n    assert(a.red, 'red works only with red numbers');\n  };\n\n  Red.prototype._verify2 = function _verify2 (a, b) {\n    assert((a.negative | b.negative) === 0, 'red works only with positives');\n    assert(a.red && a.red === b.red,\n      'red works only with red numbers');\n  };\n\n  Red.prototype.imod = function imod (a) {\n    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n    return a.umod(this.m)._forceRed(this);\n  };\n\n  Red.prototype.neg = function neg (a) {\n    if (a.isZero()) {\n      return a.clone();\n    }\n\n    return this.m.sub(a)._forceRed(this);\n  };\n\n  Red.prototype.add = function add (a, b) {\n    this._verify2(a, b);\n\n    var res = a.add(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.iadd = function iadd (a, b) {\n    this._verify2(a, b);\n\n    var res = a.iadd(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.sub = function sub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.sub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.isub = function isub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.isub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.shl = function shl (a, num) {\n    this._verify1(a);\n    return this.imod(a.ushln(num));\n  };\n\n  Red.prototype.imul = function imul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.imul(b));\n  };\n\n  Red.prototype.mul = function mul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.mul(b));\n  };\n\n  Red.prototype.isqr = function isqr (a) {\n    return this.imul(a, a.clone());\n  };\n\n  Red.prototype.sqr = function sqr (a) {\n    return this.mul(a, a);\n  };\n\n  Red.prototype.sqrt = function sqrt (a) {\n    if (a.isZero()) return a.clone();\n\n    var mod3 = this.m.andln(3);\n    assert(mod3 % 2 === 1);\n\n    // Fast case\n    if (mod3 === 3) {\n      var pow = this.m.add(new BN(1)).iushrn(2);\n      return this.pow(a, pow);\n    }\n\n    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n    //\n    // Find Q and S, that Q * 2 ^ S = (P - 1)\n    var q = this.m.subn(1);\n    var s = 0;\n    while (!q.isZero() && q.andln(1) === 0) {\n      s++;\n      q.iushrn(1);\n    }\n    assert(!q.isZero());\n\n    var one = new BN(1).toRed(this);\n    var nOne = one.redNeg();\n\n    // Find quadratic non-residue\n    // NOTE: Max is such because of generalized Riemann hypothesis.\n    var lpow = this.m.subn(1).iushrn(1);\n    var z = this.m.bitLength();\n    z = new BN(2 * z * z).toRed(this);\n\n    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n      z.redIAdd(nOne);\n    }\n\n    var c = this.pow(z, q);\n    var r = this.pow(a, q.addn(1).iushrn(1));\n    var t = this.pow(a, q);\n    var m = s;\n    while (t.cmp(one) !== 0) {\n      var tmp = t;\n      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n        tmp = tmp.redSqr();\n      }\n      assert(i < m);\n      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n      r = r.redMul(b);\n      c = b.redSqr();\n      t = t.redMul(c);\n      m = i;\n    }\n\n    return r;\n  };\n\n  Red.prototype.invm = function invm (a) {\n    var inv = a._invmp(this.m);\n    if (inv.negative !== 0) {\n      inv.negative = 0;\n      return this.imod(inv).redNeg();\n    } else {\n      return this.imod(inv);\n    }\n  };\n\n  Red.prototype.pow = function pow (a, num) {\n    if (num.isZero()) return new BN(1).toRed(this);\n    if (num.cmpn(1) === 0) return a.clone();\n\n    var windowSize = 4;\n    var wnd = new Array(1 << windowSize);\n    wnd[0] = new BN(1).toRed(this);\n    wnd[1] = a;\n    for (var i = 2; i < wnd.length; i++) {\n      wnd[i] = this.mul(wnd[i - 1], a);\n    }\n\n    var res = wnd[0];\n    var current = 0;\n    var currentLen = 0;\n    var start = num.bitLength() % 26;\n    if (start === 0) {\n      start = 26;\n    }\n\n    for (i = num.length - 1; i >= 0; i--) {\n      var word = num.words[i];\n      for (var j = start - 1; j >= 0; j--) {\n        var bit = (word >> j) & 1;\n        if (res !== wnd[0]) {\n          res = this.sqr(res);\n        }\n\n        if (bit === 0 && current === 0) {\n          currentLen = 0;\n          continue;\n        }\n\n        current <<= 1;\n        current |= bit;\n        currentLen++;\n        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n        res = this.mul(res, wnd[current]);\n        currentLen = 0;\n        current = 0;\n      }\n      start = 26;\n    }\n\n    return res;\n  };\n\n  Red.prototype.convertTo = function convertTo (num) {\n    var r = num.umod(this.m);\n\n    return r === num ? r.clone() : r;\n  };\n\n  Red.prototype.convertFrom = function convertFrom (num) {\n    var res = num.clone();\n    res.red = null;\n    return res;\n  };\n\n  //\n  // Montgomery method engine\n  //\n\n  BN.mont = function mont (num) {\n    return new Mont(num);\n  };\n\n  function Mont (m) {\n    Red.call(this, m);\n\n    this.shift = this.m.bitLength();\n    if (this.shift % 26 !== 0) {\n      this.shift += 26 - (this.shift % 26);\n    }\n\n    this.r = new BN(1).iushln(this.shift);\n    this.r2 = this.imod(this.r.sqr());\n    this.rinv = this.r._invmp(this.m);\n\n    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n    this.minv = this.minv.umod(this.r);\n    this.minv = this.r.sub(this.minv);\n  }\n  inherits(Mont, Red);\n\n  Mont.prototype.convertTo = function convertTo (num) {\n    return this.imod(num.ushln(this.shift));\n  };\n\n  Mont.prototype.convertFrom = function convertFrom (num) {\n    var r = this.imod(num.mul(this.rinv));\n    r.red = null;\n    return r;\n  };\n\n  Mont.prototype.imul = function imul (a, b) {\n    if (a.isZero() || b.isZero()) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    var t = a.imul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.mul = function mul (a, b) {\n    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n    var t = a.mul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.invm = function invm (a) {\n    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n    var res = this.imod(a._invmp(this.m).mul(this.r2));\n    return res._forceRed(this);\n  };\n})( false || module, this);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack://Fabric/./node_modules/bn.js/lib/bn.js?");
./assets/service.js:eval("/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {\n  'use strict';\n\n  // Utils\n  function assert (val, msg) {\n    if (!val) throw new Error(msg || 'Assertion failed');\n  }\n\n  // Could use `inherits` module, but don't want to move from single file\n  // architecture yet.\n  function inherits (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  }\n\n  // BN\n\n  function BN (number, base, endian) {\n    if (BN.isBN(number)) {\n      return number;\n    }\n\n    this.negative = 0;\n    this.words = null;\n    this.length = 0;\n\n    // Reduction context\n    this.red = null;\n\n    if (number !== null) {\n      if (base === 'le' || base === 'be') {\n        endian = base;\n        base = 10;\n      }\n\n      this._init(number || 0, base || 10, endian || 'be');\n    }\n  }\n  if (typeof module === 'object') {\n    module.exports = BN;\n  } else {\n    exports.BN = BN;\n  }\n\n  BN.BN = BN;\n  BN.wordSize = 26;\n\n  var Buffer;\n  try {\n    Buffer = __webpack_require__(/*! buffer */ 8).Buffer;\n  } catch (e) {\n  }\n\n  BN.isBN = function isBN (num) {\n    if (num instanceof BN) {\n      return true;\n    }\n\n    return num !== null && typeof num === 'object' &&\n      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n  };\n\n  BN.max = function max (left, right) {\n    if (left.cmp(right) > 0) return left;\n    return right;\n  };\n\n  BN.min = function min (left, right) {\n    if (left.cmp(right) < 0) return left;\n    return right;\n  };\n\n  BN.prototype._init = function init (number, base, endian) {\n    if (typeof number === 'number') {\n      return this._initNumber(number, base, endian);\n    }\n\n    if (typeof number === 'object') {\n      return this._initArray(number, base, endian);\n    }\n\n    if (base === 'hex') {\n      base = 16;\n    }\n    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n    number = number.toString().replace(/\\s+/g, '');\n    var start = 0;\n    if (number[0] === '-') {\n      start++;\n    }\n\n    if (base === 16) {\n      this._parseHex(number, start);\n    } else {\n      this._parseBase(number, base, start);\n    }\n\n    if (number[0] === '-') {\n      this.negative = 1;\n    }\n\n    this._strip();\n\n    if (endian !== 'le') return;\n\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n    if (number < 0) {\n      this.negative = 1;\n      number = -number;\n    }\n    if (number < 0x4000000) {\n      this.words = [number & 0x3ffffff];\n      this.length = 1;\n    } else if (number < 0x10000000000000) {\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff\n      ];\n      this.length = 2;\n    } else {\n      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff,\n        1\n      ];\n      this.length = 3;\n    }\n\n    if (endian !== 'le') return;\n\n    // Reverse the bytes\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initArray = function _initArray (number, base, endian) {\n    // Perhaps a Uint8Array\n    assert(typeof number.length === 'number');\n    if (number.length <= 0) {\n      this.words = [0];\n      this.length = 1;\n      return this;\n    }\n\n    this.length = Math.ceil(number.length / 3);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    var off = 0;\n    if (endian === 'be') {\n      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    } else if (endian === 'le') {\n      for (i = 0, j = 0; i < number.length; i += 3) {\n        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    }\n    return this._strip();\n  };\n\n  function parseHex (str, start, end) {\n    var r = 0;\n    var len = Math.min(str.length, end);\n    var z = 0;\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r <<= 4;\n\n      var b;\n\n      // 'a' - 'f'\n      if (c >= 49 && c <= 54) {\n        b = c - 49 + 0xa;\n\n      // 'A' - 'F'\n      } else if (c >= 17 && c <= 22) {\n        b = c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        b = c;\n      }\n\n      r |= b;\n      z |= b;\n    }\n\n    assert(!(z & 0xf0), 'Invalid character in ' + str);\n    return r;\n  }\n\n  BN.prototype._parseHex = function _parseHex (number, start) {\n    // Create possibly bigger array to ensure that it fits the number\n    this.length = Math.ceil((number.length - start) / 6);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    // Scan 24-bit chunks and add them to the number\n    var off = 0;\n    for (i = number.length - 6, j = 0; i >= start; i -= 6) {\n      w = parseHex(number, i, i + 6);\n      this.words[j] |= (w << off) & 0x3ffffff;\n      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb\n      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n      off += 24;\n      if (off >= 26) {\n        off -= 26;\n        j++;\n      }\n    }\n    if (i + 6 !== start) {\n      w = parseHex(number, start, i + 6);\n      this.words[j] |= (w << off) & 0x3ffffff;\n      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n    }\n    this._strip();\n  };\n\n  function parseBase (str, start, end, mul) {\n    var r = 0;\n    var b = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r *= mul;\n\n      // 'a'\n      if (c >= 49) {\n        b = c - 49 + 0xa;\n\n      // 'A'\n      } else if (c >= 17) {\n        b = c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        b = c;\n      }\n      assert(c >= 0 && b < mul, 'Invalid character');\n      r += b;\n    }\n    return r;\n  }\n\n  BN.prototype._parseBase = function _parseBase (number, base, start) {\n    // Initialize as zero\n    this.words = [0];\n    this.length = 1;\n\n    // Find length of limb in base\n    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n      limbLen++;\n    }\n    limbLen--;\n    limbPow = (limbPow / base) | 0;\n\n    var total = number.length - start;\n    var mod = total % limbLen;\n    var end = Math.min(total, total - mod) + start;\n\n    var word = 0;\n    for (var i = start; i < end; i += limbLen) {\n      word = parseBase(number, i, i + limbLen, base);\n\n      this.imuln(limbPow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    if (mod !== 0) {\n      var pow = 1;\n      word = parseBase(number, i, number.length, base);\n\n      for (i = 0; i < mod; i++) {\n        pow *= base;\n      }\n\n      this.imuln(pow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n  };\n\n  BN.prototype.copy = function copy (dest) {\n    dest.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      dest.words[i] = this.words[i];\n    }\n    dest.length = this.length;\n    dest.negative = this.negative;\n    dest.red = this.red;\n  };\n\n  function move (dest, src) {\n    dest.words = src.words;\n    dest.length = src.length;\n    dest.negative = src.negative;\n    dest.red = src.red;\n  }\n\n  BN.prototype._move = function _move (dest) {\n    move(dest, this);\n  };\n\n  BN.prototype.clone = function clone () {\n    var r = new BN(null);\n    this.copy(r);\n    return r;\n  };\n\n  BN.prototype._expand = function _expand (size) {\n    while (this.length < size) {\n      this.words[this.length++] = 0;\n    }\n    return this;\n  };\n\n  // Remove leading `0` from `this`\n  BN.prototype._strip = function strip () {\n    while (this.length > 1 && this.words[this.length - 1] === 0) {\n      this.length--;\n    }\n    return this._normSign();\n  };\n\n  BN.prototype._normSign = function _normSign () {\n    // -0 = 0\n    if (this.length === 1 && this.words[0] === 0) {\n      this.negative = 0;\n    }\n    return this;\n  };\n\n  // Check Symbol.for because not everywhere where Symbol defined\n  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility\n  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {\n    try {\n      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;\n    } catch (e) {\n      BN.prototype.inspect = inspect;\n    }\n  } else {\n    BN.prototype.inspect = inspect;\n  }\n\n  function inspect () {\n    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n  }\n\n  /*\n\n  var zeros = [];\n  var groupSizes = [];\n  var groupBases = [];\n\n  var s = '';\n  var i = -1;\n  while (++i < BN.wordSize) {\n    zeros[i] = s;\n    s += '0';\n  }\n  groupSizes[0] = 0;\n  groupSizes[1] = 0;\n  groupBases[0] = 0;\n  groupBases[1] = 0;\n  var base = 2 - 1;\n  while (++base < 36 + 1) {\n    var groupSize = 0;\n    var groupBase = 1;\n    while (groupBase < (1 << BN.wordSize) / base) {\n      groupBase *= base;\n      groupSize += 1;\n    }\n    groupSizes[base] = groupSize;\n    groupBases[base] = groupBase;\n  }\n\n  */\n\n  var zeros = [\n    '',\n    '0',\n    '00',\n    '000',\n    '0000',\n    '00000',\n    '000000',\n    '0000000',\n    '00000000',\n    '000000000',\n    '0000000000',\n    '00000000000',\n    '000000000000',\n    '0000000000000',\n    '00000000000000',\n    '000000000000000',\n    '0000000000000000',\n    '00000000000000000',\n    '000000000000000000',\n    '0000000000000000000',\n    '00000000000000000000',\n    '000000000000000000000',\n    '0000000000000000000000',\n    '00000000000000000000000',\n    '000000000000000000000000',\n    '0000000000000000000000000'\n  ];\n\n  var groupSizes = [\n    0, 0,\n    25, 16, 12, 11, 10, 9, 8,\n    8, 7, 7, 7, 7, 6, 6,\n    6, 6, 6, 6, 6, 5, 5,\n    5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5\n  ];\n\n  var groupBases = [\n    0, 0,\n    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n  ];\n\n  BN.prototype.toString = function toString (base, padding) {\n    base = base || 10;\n    padding = padding | 0 || 1;\n\n    var out;\n    if (base === 16 || base === 'hex') {\n      out = '';\n      var off = 0;\n      var carry = 0;\n      for (var i = 0; i < this.length; i++) {\n        var w = this.words[i];\n        var word = (((w << off) | carry) & 0xffffff).toString(16);\n        carry = (w >>> (24 - off)) & 0xffffff;\n        if (carry !== 0 || i !== this.length - 1) {\n          out = zeros[6 - word.length] + word + out;\n        } else {\n          out = word + out;\n        }\n        off += 2;\n        if (off >= 26) {\n          off -= 26;\n          i--;\n        }\n      }\n      if (carry !== 0) {\n        out = carry.toString(16) + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    if (base === (base | 0) && base >= 2 && base <= 36) {\n      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n      var groupSize = groupSizes[base];\n      // var groupBase = Math.pow(base, groupSize);\n      var groupBase = groupBases[base];\n      out = '';\n      var c = this.clone();\n      c.negative = 0;\n      while (!c.isZero()) {\n        var r = c.modrn(groupBase).toString(base);\n        c = c.idivn(groupBase);\n\n        if (!c.isZero()) {\n          out = zeros[groupSize - r.length] + r + out;\n        } else {\n          out = r + out;\n        }\n      }\n      if (this.isZero()) {\n        out = '0' + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    assert(false, 'Base should be between 2 and 36');\n  };\n\n  BN.prototype.toNumber = function toNumber () {\n    var ret = this.words[0];\n    if (this.length === 2) {\n      ret += this.words[1] * 0x4000000;\n    } else if (this.length === 3 && this.words[2] === 0x01) {\n      // NOTE: at this stage it is known that the top bit is set\n      ret += 0x10000000000000 + (this.words[1] * 0x4000000);\n    } else if (this.length > 2) {\n      assert(false, 'Number can only safely store up to 53 bits');\n    }\n    return (this.negative !== 0) ? -ret : ret;\n  };\n\n  BN.prototype.toJSON = function toJSON () {\n    return this.toString(16, 2);\n  };\n\n  if (Buffer) {\n    BN.prototype.toBuffer = function toBuffer (endian, length) {\n      return this.toArrayLike(Buffer, endian, length);\n    };\n  }\n\n  BN.prototype.toArray = function toArray (endian, length) {\n    return this.toArrayLike(Array, endian, length);\n  };\n\n  var allocate = function allocate (ArrayType, size) {\n    if (ArrayType.allocUnsafe) {\n      return ArrayType.allocUnsafe(size);\n    }\n    return new ArrayType(size);\n  };\n\n  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {\n    this._strip();\n\n    var byteLength = this.byteLength();\n    var reqLength = length || Math.max(1, byteLength);\n    assert(byteLength <= reqLength, 'byte array longer than desired length');\n    assert(reqLength > 0, 'Requested array length <= 0');\n\n    var res = allocate(ArrayType, reqLength);\n    var postfix = endian === 'le' ? 'LE' : 'BE';\n    this['_toArrayLike' + postfix](res, byteLength);\n    return res;\n  };\n\n  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {\n    var position = 0;\n    var carry = 0;\n\n    for (var i = 0, shift = 0; i < this.length; i++) {\n      var word = (this.words[i] << shift) | carry;\n\n      res[position++] = word & 0xff;\n      if (position < res.length) {\n        res[position++] = (word >> 8) & 0xff;\n      }\n      if (position < res.length) {\n        res[position++] = (word >> 16) & 0xff;\n      }\n\n      if (shift === 6) {\n        if (position < res.length) {\n          res[position++] = (word >> 24) & 0xff;\n        }\n        carry = 0;\n        shift = 0;\n      } else {\n        carry = word >>> 24;\n        shift += 2;\n      }\n    }\n\n    if (position < res.length) {\n      res[position++] = carry;\n\n      while (position < res.length) {\n        res[position++] = 0;\n      }\n    }\n  };\n\n  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {\n    var position = res.length - 1;\n    var carry = 0;\n\n    for (var i = 0, shift = 0; i < this.length; i++) {\n      var word = (this.words[i] << shift) | carry;\n\n      res[position--] = word & 0xff;\n      if (position >= 0) {\n        res[position--] = (word >> 8) & 0xff;\n      }\n      if (position >= 0) {\n        res[position--] = (word >> 16) & 0xff;\n      }\n\n      if (shift === 6) {\n        if (position >= 0) {\n          res[position--] = (word >> 24) & 0xff;\n        }\n        carry = 0;\n        shift = 0;\n      } else {\n        carry = word >>> 24;\n        shift += 2;\n      }\n    }\n\n    if (position >= 0) {\n      res[position--] = carry;\n\n      while (position >= 0) {\n        res[position--] = 0;\n      }\n    }\n  };\n\n  if (Math.clz32) {\n    BN.prototype._countBits = function _countBits (w) {\n      return 32 - Math.clz32(w);\n    };\n  } else {\n    BN.prototype._countBits = function _countBits (w) {\n      var t = w;\n      var r = 0;\n      if (t >= 0x1000) {\n        r += 13;\n        t >>>= 13;\n      }\n      if (t >= 0x40) {\n        r += 7;\n        t >>>= 7;\n      }\n      if (t >= 0x8) {\n        r += 4;\n        t >>>= 4;\n      }\n      if (t >= 0x02) {\n        r += 2;\n        t >>>= 2;\n      }\n      return r + t;\n    };\n  }\n\n  BN.prototype._zeroBits = function _zeroBits (w) {\n    // Short-cut\n    if (w === 0) return 26;\n\n    var t = w;\n    var r = 0;\n    if ((t & 0x1fff) === 0) {\n      r += 13;\n      t >>>= 13;\n    }\n    if ((t & 0x7f) === 0) {\n      r += 7;\n      t >>>= 7;\n    }\n    if ((t & 0xf) === 0) {\n      r += 4;\n      t >>>= 4;\n    }\n    if ((t & 0x3) === 0) {\n      r += 2;\n      t >>>= 2;\n    }\n    if ((t & 0x1) === 0) {\n      r++;\n    }\n    return r;\n  };\n\n  // Return number of used bits in a BN\n  BN.prototype.bitLength = function bitLength () {\n    var w = this.words[this.length - 1];\n    var hi = this._countBits(w);\n    return (this.length - 1) * 26 + hi;\n  };\n\n  function toBitArray (num) {\n    var w = new Array(num.bitLength());\n\n    for (var bit = 0; bit < w.length; bit++) {\n      var off = (bit / 26) | 0;\n      var wbit = bit % 26;\n\n      w[bit] = (num.words[off] >>> wbit) & 0x01;\n    }\n\n    return w;\n  }\n\n  // Number of trailing zero bits\n  BN.prototype.zeroBits = function zeroBits () {\n    if (this.isZero()) return 0;\n\n    var r = 0;\n    for (var i = 0; i < this.length; i++) {\n      var b = this._zeroBits(this.words[i]);\n      r += b;\n      if (b !== 26) break;\n    }\n    return r;\n  };\n\n  BN.prototype.byteLength = function byteLength () {\n    return Math.ceil(this.bitLength() / 8);\n  };\n\n  BN.prototype.toTwos = function toTwos (width) {\n    if (this.negative !== 0) {\n      return this.abs().inotn(width).iaddn(1);\n    }\n    return this.clone();\n  };\n\n  BN.prototype.fromTwos = function fromTwos (width) {\n    if (this.testn(width - 1)) {\n      return this.notn(width).iaddn(1).ineg();\n    }\n    return this.clone();\n  };\n\n  BN.prototype.isNeg = function isNeg () {\n    return this.negative !== 0;\n  };\n\n  // Return negative clone of `this`\n  BN.prototype.neg = function neg () {\n    return this.clone().ineg();\n  };\n\n  BN.prototype.ineg = function ineg () {\n    if (!this.isZero()) {\n      this.negative ^= 1;\n    }\n\n    return this;\n  };\n\n  // Or `num` with `this` in-place\n  BN.prototype.iuor = function iuor (num) {\n    while (this.length < num.length) {\n      this.words[this.length++] = 0;\n    }\n\n    for (var i = 0; i < num.length; i++) {\n      this.words[i] = this.words[i] | num.words[i];\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ior = function ior (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuor(num);\n  };\n\n  // Or `num` with `this`\n  BN.prototype.or = function or (num) {\n    if (this.length > num.length) return this.clone().ior(num);\n    return num.clone().ior(this);\n  };\n\n  BN.prototype.uor = function uor (num) {\n    if (this.length > num.length) return this.clone().iuor(num);\n    return num.clone().iuor(this);\n  };\n\n  // And `num` with `this` in-place\n  BN.prototype.iuand = function iuand (num) {\n    // b = min-length(num, this)\n    var b;\n    if (this.length > num.length) {\n      b = num;\n    } else {\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = this.words[i] & num.words[i];\n    }\n\n    this.length = b.length;\n\n    return this._strip();\n  };\n\n  BN.prototype.iand = function iand (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuand(num);\n  };\n\n  // And `num` with `this`\n  BN.prototype.and = function and (num) {\n    if (this.length > num.length) return this.clone().iand(num);\n    return num.clone().iand(this);\n  };\n\n  BN.prototype.uand = function uand (num) {\n    if (this.length > num.length) return this.clone().iuand(num);\n    return num.clone().iuand(this);\n  };\n\n  // Xor `num` with `this` in-place\n  BN.prototype.iuxor = function iuxor (num) {\n    // a.length > b.length\n    var a;\n    var b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = a.words[i] ^ b.words[i];\n    }\n\n    if (this !== a) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = a.length;\n\n    return this._strip();\n  };\n\n  BN.prototype.ixor = function ixor (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuxor(num);\n  };\n\n  // Xor `num` with `this`\n  BN.prototype.xor = function xor (num) {\n    if (this.length > num.length) return this.clone().ixor(num);\n    return num.clone().ixor(this);\n  };\n\n  BN.prototype.uxor = function uxor (num) {\n    if (this.length > num.length) return this.clone().iuxor(num);\n    return num.clone().iuxor(this);\n  };\n\n  // Not ``this`` with ``width`` bitwidth\n  BN.prototype.inotn = function inotn (width) {\n    assert(typeof width === 'number' && width >= 0);\n\n    var bytesNeeded = Math.ceil(width / 26) | 0;\n    var bitsLeft = width % 26;\n\n    // Extend the buffer with leading zeroes\n    this._expand(bytesNeeded);\n\n    if (bitsLeft > 0) {\n      bytesNeeded--;\n    }\n\n    // Handle complete words\n    for (var i = 0; i < bytesNeeded; i++) {\n      this.words[i] = ~this.words[i] & 0x3ffffff;\n    }\n\n    // Handle the residue\n    if (bitsLeft > 0) {\n      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n    }\n\n    // And remove leading zeroes\n    return this._strip();\n  };\n\n  BN.prototype.notn = function notn (width) {\n    return this.clone().inotn(width);\n  };\n\n  // Set `bit` of `this`\n  BN.prototype.setn = function setn (bit, val) {\n    assert(typeof bit === 'number' && bit >= 0);\n\n    var off = (bit / 26) | 0;\n    var wbit = bit % 26;\n\n    this._expand(off + 1);\n\n    if (val) {\n      this.words[off] = this.words[off] | (1 << wbit);\n    } else {\n      this.words[off] = this.words[off] & ~(1 << wbit);\n    }\n\n    return this._strip();\n  };\n\n  // Add `num` to `this` in-place\n  BN.prototype.iadd = function iadd (num) {\n    var r;\n\n    // negative + positive\n    if (this.negative !== 0 && num.negative === 0) {\n      this.negative = 0;\n      r = this.isub(num);\n      this.negative ^= 1;\n      return this._normSign();\n\n    // positive + negative\n    } else if (this.negative === 0 && num.negative !== 0) {\n      num.negative = 0;\n      r = this.isub(num);\n      num.negative = 1;\n      return r._normSign();\n    }\n\n    // a.length > b.length\n    var a, b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    this.length = a.length;\n    if (carry !== 0) {\n      this.words[this.length] = carry;\n      this.length++;\n    // Copy the rest of the words\n    } else if (a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    return this;\n  };\n\n  // Add `num` to `this`\n  BN.prototype.add = function add (num) {\n    var res;\n    if (num.negative !== 0 && this.negative === 0) {\n      num.negative = 0;\n      res = this.sub(num);\n      num.negative ^= 1;\n      return res;\n    } else if (num.negative === 0 && this.negative !== 0) {\n      this.negative = 0;\n      res = num.sub(this);\n      this.negative = 1;\n      return res;\n    }\n\n    if (this.length > num.length) return this.clone().iadd(num);\n\n    return num.clone().iadd(this);\n  };\n\n  // Subtract `num` from `this` in-place\n  BN.prototype.isub = function isub (num) {\n    // this - (-num) = this + num\n    if (num.negative !== 0) {\n      num.negative = 0;\n      var r = this.iadd(num);\n      num.negative = 1;\n      return r._normSign();\n\n    // -this - num = -(this + num)\n    } else if (this.negative !== 0) {\n      this.negative = 0;\n      this.iadd(num);\n      this.negative = 1;\n      return this._normSign();\n    }\n\n    // At this point both numbers are positive\n    var cmp = this.cmp(num);\n\n    // Optimization - zeroify\n    if (cmp === 0) {\n      this.negative = 0;\n      this.length = 1;\n      this.words[0] = 0;\n      return this;\n    }\n\n    // a > b\n    var a, b;\n    if (cmp > 0) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n\n    // Copy rest of the words\n    if (carry === 0 && i < a.length && a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = Math.max(this.length, i);\n\n    if (a !== this) {\n      this.negative = 1;\n    }\n\n    return this._strip();\n  };\n\n  // Subtract `num` from `this`\n  BN.prototype.sub = function sub (num) {\n    return this.clone().isub(num);\n  };\n\n  function smallMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    var len = (self.length + num.length) | 0;\n    out.length = len;\n    len = (len - 1) | 0;\n\n    // Peel one iteration (compiler can't do it, because of code complexity)\n    var a = self.words[0] | 0;\n    var b = num.words[0] | 0;\n    var r = a * b;\n\n    var lo = r & 0x3ffffff;\n    var carry = (r / 0x4000000) | 0;\n    out.words[0] = lo;\n\n    for (var k = 1; k < len; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = carry >>> 26;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = (k - j) | 0;\n        a = self.words[i] | 0;\n        b = num.words[j] | 0;\n        r = a * b + rword;\n        ncarry += (r / 0x4000000) | 0;\n        rword = r & 0x3ffffff;\n      }\n      out.words[k] = rword | 0;\n      carry = ncarry | 0;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry | 0;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  }\n\n  // TODO(indutny): it may be reasonable to omit it for users who don't need\n  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n  // multiplication (like elliptic secp256k1).\n  var comb10MulTo = function comb10MulTo (self, num, out) {\n    var a = self.words;\n    var b = num.words;\n    var o = out.words;\n    var c = 0;\n    var lo;\n    var mid;\n    var hi;\n    var a0 = a[0] | 0;\n    var al0 = a0 & 0x1fff;\n    var ah0 = a0 >>> 13;\n    var a1 = a[1] | 0;\n    var al1 = a1 & 0x1fff;\n    var ah1 = a1 >>> 13;\n    var a2 = a[2] | 0;\n    var al2 = a2 & 0x1fff;\n    var ah2 = a2 >>> 13;\n    var a3 = a[3] | 0;\n    var al3 = a3 & 0x1fff;\n    var ah3 = a3 >>> 13;\n    var a4 = a[4] | 0;\n    var al4 = a4 & 0x1fff;\n    var ah4 = a4 >>> 13;\n    var a5 = a[5] | 0;\n    var al5 = a5 & 0x1fff;\n    var ah5 = a5 >>> 13;\n    var a6 = a[6] | 0;\n    var al6 = a6 & 0x1fff;\n    var ah6 = a6 >>> 13;\n    var a7 = a[7] | 0;\n    var al7 = a7 & 0x1fff;\n    var ah7 = a7 >>> 13;\n    var a8 = a[8] | 0;\n    var al8 = a8 & 0x1fff;\n    var ah8 = a8 >>> 13;\n    var a9 = a[9] | 0;\n    var al9 = a9 & 0x1fff;\n    var ah9 = a9 >>> 13;\n    var b0 = b[0] | 0;\n    var bl0 = b0 & 0x1fff;\n    var bh0 = b0 >>> 13;\n    var b1 = b[1] | 0;\n    var bl1 = b1 & 0x1fff;\n    var bh1 = b1 >>> 13;\n    var b2 = b[2] | 0;\n    var bl2 = b2 & 0x1fff;\n    var bh2 = b2 >>> 13;\n    var b3 = b[3] | 0;\n    var bl3 = b3 & 0x1fff;\n    var bh3 = b3 >>> 13;\n    var b4 = b[4] | 0;\n    var bl4 = b4 & 0x1fff;\n    var bh4 = b4 >>> 13;\n    var b5 = b[5] | 0;\n    var bl5 = b5 & 0x1fff;\n    var bh5 = b5 >>> 13;\n    var b6 = b[6] | 0;\n    var bl6 = b6 & 0x1fff;\n    var bh6 = b6 >>> 13;\n    var b7 = b[7] | 0;\n    var bl7 = b7 & 0x1fff;\n    var bh7 = b7 >>> 13;\n    var b8 = b[8] | 0;\n    var bl8 = b8 & 0x1fff;\n    var bh8 = b8 >>> 13;\n    var b9 = b[9] | 0;\n    var bl9 = b9 & 0x1fff;\n    var bh9 = b9 >>> 13;\n\n    out.negative = self.negative ^ num.negative;\n    out.length = 19;\n    /* k = 0 */\n    lo = Math.imul(al0, bl0);\n    mid = Math.imul(al0, bh0);\n    mid = (mid + Math.imul(ah0, bl0)) | 0;\n    hi = Math.imul(ah0, bh0);\n    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\n    w0 &= 0x3ffffff;\n    /* k = 1 */\n    lo = Math.imul(al1, bl0);\n    mid = Math.imul(al1, bh0);\n    mid = (mid + Math.imul(ah1, bl0)) | 0;\n    hi = Math.imul(ah1, bh0);\n    lo = (lo + Math.imul(al0, bl1)) | 0;\n    mid = (mid + Math.imul(al0, bh1)) | 0;\n    mid = (mid + Math.imul(ah0, bl1)) | 0;\n    hi = (hi + Math.imul(ah0, bh1)) | 0;\n    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\n    w1 &= 0x3ffffff;\n    /* k = 2 */\n    lo = Math.imul(al2, bl0);\n    mid = Math.imul(al2, bh0);\n    mid = (mid + Math.imul(ah2, bl0)) | 0;\n    hi = Math.imul(ah2, bh0);\n    lo = (lo + Math.imul(al1, bl1)) | 0;\n    mid = (mid + Math.imul(al1, bh1)) | 0;\n    mid = (mid + Math.imul(ah1, bl1)) | 0;\n    hi = (hi + Math.imul(ah1, bh1)) | 0;\n    lo = (lo + Math.imul(al0, bl2)) | 0;\n    mid = (mid + Math.imul(al0, bh2)) | 0;\n    mid = (mid + Math.imul(ah0, bl2)) | 0;\n    hi = (hi + Math.imul(ah0, bh2)) | 0;\n    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\n    w2 &= 0x3ffffff;\n    /* k = 3 */\n    lo = Math.imul(al3, bl0);\n    mid = Math.imul(al3, bh0);\n    mid = (mid + Math.imul(ah3, bl0)) | 0;\n    hi = Math.imul(ah3, bh0);\n    lo = (lo + Math.imul(al2, bl1)) | 0;\n    mid = (mid + Math.imul(al2, bh1)) | 0;\n    mid = (mid + Math.imul(ah2, bl1)) | 0;\n    hi = (hi + Math.imul(ah2, bh1)) | 0;\n    lo = (lo + Math.imul(al1, bl2)) | 0;\n    mid = (mid + Math.imul(al1, bh2)) | 0;\n    mid = (mid + Math.imul(ah1, bl2)) | 0;\n    hi = (hi + Math.imul(ah1, bh2)) | 0;\n    lo = (lo + Math.imul(al0, bl3)) | 0;\n    mid = (mid + Math.imul(al0, bh3)) | 0;\n    mid = (mid + Math.imul(ah0, bl3)) | 0;\n    hi = (hi + Math.imul(ah0, bh3)) | 0;\n    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\n    w3 &= 0x3ffffff;\n    /* k = 4 */\n    lo = Math.imul(al4, bl0);\n    mid = Math.imul(al4, bh0);\n    mid = (mid + Math.imul(ah4, bl0)) | 0;\n    hi = Math.imul(ah4, bh0);\n    lo = (lo + Math.imul(al3, bl1)) | 0;\n    mid = (mid + Math.imul(al3, bh1)) | 0;\n    mid = (mid + Math.imul(ah3, bl1)) | 0;\n    hi = (hi + Math.imul(ah3, bh1)) | 0;\n    lo = (lo + Math.imul(al2, bl2)) | 0;\n    mid = (mid + Math.imul(al2, bh2)) | 0;\n    mid = (mid + Math.imul(ah2, bl2)) | 0;\n    hi = (hi + Math.imul(ah2, bh2)) | 0;\n    lo = (lo + Math.imul(al1, bl3)) | 0;\n    mid = (mid + Math.imul(al1, bh3)) | 0;\n    mid = (mid + Math.imul(ah1, bl3)) | 0;\n    hi = (hi + Math.imul(ah1, bh3)) | 0;\n    lo = (lo + Math.imul(al0, bl4)) | 0;\n    mid = (mid + Math.imul(al0, bh4)) | 0;\n    mid = (mid + Math.imul(ah0, bl4)) | 0;\n    hi = (hi + Math.imul(ah0, bh4)) | 0;\n    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\n    w4 &= 0x3ffffff;\n    /* k = 5 */\n    lo = Math.imul(al5, bl0);\n    mid = Math.imul(al5, bh0);\n    mid = (mid + Math.imul(ah5, bl0)) | 0;\n    hi = Math.imul(ah5, bh0);\n    lo = (lo + Math.imul(al4, bl1)) | 0;\n    mid = (mid + Math.imul(al4, bh1)) | 0;\n    mid = (mid + Math.imul(ah4, bl1)) | 0;\n    hi = (hi + Math.imul(ah4, bh1)) | 0;\n    lo = (lo + Math.imul(al3, bl2)) | 0;\n    mid = (mid + Math.imul(al3, bh2)) | 0;\n    mid = (mid + Math.imul(ah3, bl2)) | 0;\n    hi = (hi + Math.imul(ah3, bh2)) | 0;\n    lo = (lo + Math.imul(al2, bl3)) | 0;\n    mid = (mid + Math.imul(al2, bh3)) | 0;\n    mid = (mid + Math.imul(ah2, bl3)) | 0;\n    hi = (hi + Math.imul(ah2, bh3)) | 0;\n    lo = (lo + Math.imul(al1, bl4)) | 0;\n    mid = (mid + Math.imul(al1, bh4)) | 0;\n    mid = (mid + Math.imul(ah1, bl4)) | 0;\n    hi = (hi + Math.imul(ah1, bh4)) | 0;\n    lo = (lo + Math.imul(al0, bl5)) | 0;\n    mid = (mid + Math.imul(al0, bh5)) | 0;\n    mid = (mid + Math.imul(ah0, bl5)) | 0;\n    hi = (hi + Math.imul(ah0, bh5)) | 0;\n    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\n    w5 &= 0x3ffffff;\n    /* k = 6 */\n    lo = Math.imul(al6, bl0);\n    mid = Math.imul(al6, bh0);\n    mid = (mid + Math.imul(ah6, bl0)) | 0;\n    hi = Math.imul(ah6, bh0);\n    lo = (lo + Math.imul(al5, bl1)) | 0;\n    mid = (mid + Math.imul(al5, bh1)) | 0;\n    mid = (mid + Math.imul(ah5, bl1)) | 0;\n    hi = (hi + Math.imul(ah5, bh1)) | 0;\n    lo = (lo + Math.imul(al4, bl2)) | 0;\n    mid = (mid + Math.imul(al4, bh2)) | 0;\n    mid = (mid + Math.imul(ah4, bl2)) | 0;\n    hi = (hi + Math.imul(ah4, bh2)) | 0;\n    lo = (lo + Math.imul(al3, bl3)) | 0;\n    mid = (mid + Math.imul(al3, bh3)) | 0;\n    mid = (mid + Math.imul(ah3, bl3)) | 0;\n    hi = (hi + Math.imul(ah3, bh3)) | 0;\n    lo = (lo + Math.imul(al2, bl4)) | 0;\n    mid = (mid + Math.imul(al2, bh4)) | 0;\n    mid = (mid + Math.imul(ah2, bl4)) | 0;\n    hi = (hi + Math.imul(ah2, bh4)) | 0;\n    lo = (lo + Math.imul(al1, bl5)) | 0;\n    mid = (mid + Math.imul(al1, bh5)) | 0;\n    mid = (mid + Math.imul(ah1, bl5)) | 0;\n    hi = (hi + Math.imul(ah1, bh5)) | 0;\n    lo = (lo + Math.imul(al0, bl6)) | 0;\n    mid = (mid + Math.imul(al0, bh6)) | 0;\n    mid = (mid + Math.imul(ah0, bl6)) | 0;\n    hi = (hi + Math.imul(ah0, bh6)) | 0;\n    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\n    w6 &= 0x3ffffff;\n    /* k = 7 */\n    lo = Math.imul(al7, bl0);\n    mid = Math.imul(al7, bh0);\n    mid = (mid + Math.imul(ah7, bl0)) | 0;\n    hi = Math.imul(ah7, bh0);\n    lo = (lo + Math.imul(al6, bl1)) | 0;\n    mid = (mid + Math.imul(al6, bh1)) | 0;\n    mid = (mid + Math.imul(ah6, bl1)) | 0;\n    hi = (hi + Math.imul(ah6, bh1)) | 0;\n    lo = (lo + Math.imul(al5, bl2)) | 0;\n    mid = (mid + Math.imul(al5, bh2)) | 0;\n    mid = (mid + Math.imul(ah5, bl2)) | 0;\n    hi = (hi + Math.imul(ah5, bh2)) | 0;\n    lo = (lo + Math.imul(al4, bl3)) | 0;\n    mid = (mid + Math.imul(al4, bh3)) | 0;\n    mid = (mid + Math.imul(ah4, bl3)) | 0;\n    hi = (hi + Math.imul(ah4, bh3)) | 0;\n    lo = (lo + Math.imul(al3, bl4)) | 0;\n    mid = (mid + Math.imul(al3, bh4)) | 0;\n    mid = (mid + Math.imul(ah3, bl4)) | 0;\n    hi = (hi + Math.imul(ah3, bh4)) | 0;\n    lo = (lo + Math.imul(al2, bl5)) | 0;\n    mid = (mid + Math.imul(al2, bh5)) | 0;\n    mid = (mid + Math.imul(ah2, bl5)) | 0;\n    hi = (hi + Math.imul(ah2, bh5)) | 0;\n    lo = (lo + Math.imul(al1, bl6)) | 0;\n    mid = (mid + Math.imul(al1, bh6)) | 0;\n    mid = (mid + Math.imul(ah1, bl6)) | 0;\n    hi = (hi + Math.imul(ah1, bh6)) | 0;\n    lo = (lo + Math.imul(al0, bl7)) | 0;\n    mid = (mid + Math.imul(al0, bh7)) | 0;\n    mid = (mid + Math.imul(ah0, bl7)) | 0;\n    hi = (hi + Math.imul(ah0, bh7)) | 0;\n    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\n    w7 &= 0x3ffffff;\n    /* k = 8 */\n    lo = Math.imul(al8, bl0);\n    mid = Math.imul(al8, bh0);\n    mid = (mid + Math.imul(ah8, bl0)) | 0;\n    hi = Math.imul(ah8, bh0);\n    lo = (lo + Math.imul(al7, bl1)) | 0;\n    mid = (mid + Math.imul(al7, bh1)) | 0;\n    mid = (mid + Math.imul(ah7, bl1)) | 0;\n    hi = (hi + Math.imul(ah7, bh1)) | 0;\n    lo = (lo + Math.imul(al6, bl2)) | 0;\n    mid = (mid + Math.imul(al6, bh2)) | 0;\n    mid = (mid + Math.imul(ah6, bl2)) | 0;\n    hi = (hi + Math.imul(ah6, bh2)) | 0;\n    lo = (lo + Math.imul(al5, bl3)) | 0;\n    mid = (mid + Math.imul(al5, bh3)) | 0;\n    mid = (mid + Math.imul(ah5, bl3)) | 0;\n    hi = (hi + Math.imul(ah5, bh3)) | 0;\n    lo = (lo + Math.imul(al4, bl4)) | 0;\n    mid = (mid + Math.imul(al4, bh4)) | 0;\n    mid = (mid + Math.imul(ah4, bl4)) | 0;\n    hi = (hi + Math.imul(ah4, bh4)) | 0;\n    lo = (lo + Math.imul(al3, bl5)) | 0;\n    mid = (mid + Math.imul(al3, bh5)) | 0;\n    mid = (mid + Math.imul(ah3, bl5)) | 0;\n    hi = (hi + Math.imul(ah3, bh5)) | 0;\n    lo = (lo + Math.imul(al2, bl6)) | 0;\n    mid = (mid + Math.imul(al2, bh6)) | 0;\n    mid = (mid + Math.imul(ah2, bl6)) | 0;\n    hi = (hi + Math.imul(ah2, bh6)) | 0;\n    lo = (lo + Math.imul(al1, bl7)) | 0;\n    mid = (mid + Math.imul(al1, bh7)) | 0;\n    mid = (mid + Math.imul(ah1, bl7)) | 0;\n    hi = (hi + Math.imul(ah1, bh7)) | 0;\n    lo = (lo + Math.imul(al0, bl8)) | 0;\n    mid = (mid + Math.imul(al0, bh8)) | 0;\n    mid = (mid + Math.imul(ah0, bl8)) | 0;\n    hi = (hi + Math.imul(ah0, bh8)) | 0;\n    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\n    w8 &= 0x3ffffff;\n    /* k = 9 */\n    lo = Math.imul(al9, bl0);\n    mid = Math.imul(al9, bh0);\n    mid = (mid + Math.imul(ah9, bl0)) | 0;\n    hi = Math.imul(ah9, bh0);\n    lo = (lo + Math.imul(al8, bl1)) | 0;\n    mid = (mid + Math.imul(al8, bh1)) | 0;\n    mid = (mid + Math.imul(ah8, bl1)) | 0;\n    hi = (hi + Math.imul(ah8, bh1)) | 0;\n    lo = (lo + Math.imul(al7, bl2)) | 0;\n    mid = (mid + Math.imul(al7, bh2)) | 0;\n    mid = (mid + Math.imul(ah7, bl2)) | 0;\n    hi = (hi + Math.imul(ah7, bh2)) | 0;\n    lo = (lo + Math.imul(al6, bl3)) | 0;\n    mid = (mid + Math.imul(al6, bh3)) | 0;\n    mid = (mid + Math.imul(ah6, bl3)) | 0;\n    hi = (hi + Math.imul(ah6, bh3)) | 0;\n    lo = (lo + Math.imul(al5, bl4)) | 0;\n    mid = (mid + Math.imul(al5, bh4)) | 0;\n    mid = (mid + Math.imul(ah5, bl4)) | 0;\n    hi = (hi + Math.imul(ah5, bh4)) | 0;\n    lo = (lo + Math.imul(al4, bl5)) | 0;\n    mid = (mid + Math.imul(al4, bh5)) | 0;\n    mid = (mid + Math.imul(ah4, bl5)) | 0;\n    hi = (hi + Math.imul(ah4, bh5)) | 0;\n    lo = (lo + Math.imul(al3, bl6)) | 0;\n    mid = (mid + Math.imul(al3, bh6)) | 0;\n    mid = (mid + Math.imul(ah3, bl6)) | 0;\n    hi = (hi + Math.imul(ah3, bh6)) | 0;\n    lo = (lo + Math.imul(al2, bl7)) | 0;\n    mid = (mid + Math.imul(al2, bh7)) | 0;\n    mid = (mid + Math.imul(ah2, bl7)) | 0;\n    hi = (hi + Math.imul(ah2, bh7)) | 0;\n    lo = (lo + Math.imul(al1, bl8)) | 0;\n    mid = (mid + Math.imul(al1, bh8)) | 0;\n    mid = (mid + Math.imul(ah1, bl8)) | 0;\n    hi = (hi + Math.imul(ah1, bh8)) | 0;\n    lo = (lo + Math.imul(al0, bl9)) | 0;\n    mid = (mid + Math.imul(al0, bh9)) | 0;\n    mid = (mid + Math.imul(ah0, bl9)) | 0;\n    hi = (hi + Math.imul(ah0, bh9)) | 0;\n    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\n    w9 &= 0x3ffffff;\n    /* k = 10 */\n    lo = Math.imul(al9, bl1);\n    mid = Math.imul(al9, bh1);\n    mid = (mid + Math.imul(ah9, bl1)) | 0;\n    hi = Math.imul(ah9, bh1);\n    lo = (lo + Math.imul(al8, bl2)) | 0;\n    mid = (mid + Math.imul(al8, bh2)) | 0;\n    mid = (mid + Math.imul(ah8, bl2)) | 0;\n    hi = (hi + Math.imul(ah8, bh2)) | 0;\n    lo = (lo + Math.imul(al7, bl3)) | 0;\n    mid = (mid + Math.imul(al7, bh3)) | 0;\n    mid = (mid + Math.imul(ah7, bl3)) | 0;\n    hi = (hi + Math.imul(ah7, bh3)) | 0;\n    lo = (lo + Math.imul(al6, bl4)) | 0;\n    mid = (mid + Math.imul(al6, bh4)) | 0;\n    mid = (mid + Math.imul(ah6, bl4)) | 0;\n    hi = (hi + Math.imul(ah6, bh4)) | 0;\n    lo = (lo + Math.imul(al5, bl5)) | 0;\n    mid = (mid + Math.imul(al5, bh5)) | 0;\n    mid = (mid + Math.imul(ah5, bl5)) | 0;\n    hi = (hi + Math.imul(ah5, bh5)) | 0;\n    lo = (lo + Math.imul(al4, bl6)) | 0;\n    mid = (mid + Math.imul(al4, bh6)) | 0;\n    mid = (mid + Math.imul(ah4, bl6)) | 0;\n    hi = (hi + Math.imul(ah4, bh6)) | 0;\n    lo = (lo + Math.imul(al3, bl7)) | 0;\n    mid = (mid + Math.imul(al3, bh7)) | 0;\n    mid = (mid + Math.imul(ah3, bl7)) | 0;\n    hi = (hi + Math.imul(ah3, bh7)) | 0;\n    lo = (lo + Math.imul(al2, bl8)) | 0;\n    mid = (mid + Math.imul(al2, bh8)) | 0;\n    mid = (mid + Math.imul(ah2, bl8)) | 0;\n    hi = (hi + Math.imul(ah2, bh8)) | 0;\n    lo = (lo + Math.imul(al1, bl9)) | 0;\n    mid = (mid + Math.imul(al1, bh9)) | 0;\n    mid = (mid + Math.imul(ah1, bl9)) | 0;\n    hi = (hi + Math.imul(ah1, bh9)) | 0;\n    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\n    w10 &= 0x3ffffff;\n    /* k = 11 */\n    lo = Math.imul(al9, bl2);\n    mid = Math.imul(al9, bh2);\n    mid = (mid + Math.imul(ah9, bl2)) | 0;\n    hi = Math.imul(ah9, bh2);\n    lo = (lo + Math.imul(al8, bl3)) | 0;\n    mid = (mid + Math.imul(al8, bh3)) | 0;\n    mid = (mid + Math.imul(ah8, bl3)) | 0;\n    hi = (hi + Math.imul(ah8, bh3)) | 0;\n    lo = (lo + Math.imul(al7, bl4)) | 0;\n    mid = (mid + Math.imul(al7, bh4)) | 0;\n    mid = (mid + Math.imul(ah7, bl4)) | 0;\n    hi = (hi + Math.imul(ah7, bh4)) | 0;\n    lo = (lo + Math.imul(al6, bl5)) | 0;\n    mid = (mid + Math.imul(al6, bh5)) | 0;\n    mid = (mid + Math.imul(ah6, bl5)) | 0;\n    hi = (hi + Math.imul(ah6, bh5)) | 0;\n    lo = (lo + Math.imul(al5, bl6)) | 0;\n    mid = (mid + Math.imul(al5, bh6)) | 0;\n    mid = (mid + Math.imul(ah5, bl6)) | 0;\n    hi = (hi + Math.imul(ah5, bh6)) | 0;\n    lo = (lo + Math.imul(al4, bl7)) | 0;\n    mid = (mid + Math.imul(al4, bh7)) | 0;\n    mid = (mid + Math.imul(ah4, bl7)) | 0;\n    hi = (hi + Math.imul(ah4, bh7)) | 0;\n    lo = (lo + Math.imul(al3, bl8)) | 0;\n    mid = (mid + Math.imul(al3, bh8)) | 0;\n    mid = (mid + Math.imul(ah3, bl8)) | 0;\n    hi = (hi + Math.imul(ah3, bh8)) | 0;\n    lo = (lo + Math.imul(al2, bl9)) | 0;\n    mid = (mid + Math.imul(al2, bh9)) | 0;\n    mid = (mid + Math.imul(ah2, bl9)) | 0;\n    hi = (hi + Math.imul(ah2, bh9)) | 0;\n    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\n    w11 &= 0x3ffffff;\n    /* k = 12 */\n    lo = Math.imul(al9, bl3);\n    mid = Math.imul(al9, bh3);\n    mid = (mid + Math.imul(ah9, bl3)) | 0;\n    hi = Math.imul(ah9, bh3);\n    lo = (lo + Math.imul(al8, bl4)) | 0;\n    mid = (mid + Math.imul(al8, bh4)) | 0;\n    mid = (mid + Math.imul(ah8, bl4)) | 0;\n    hi = (hi + Math.imul(ah8, bh4)) | 0;\n    lo = (lo + Math.imul(al7, bl5)) | 0;\n    mid = (mid + Math.imul(al7, bh5)) | 0;\n    mid = (mid + Math.imul(ah7, bl5)) | 0;\n    hi = (hi + Math.imul(ah7, bh5)) | 0;\n    lo = (lo + Math.imul(al6, bl6)) | 0;\n    mid = (mid + Math.imul(al6, bh6)) | 0;\n    mid = (mid + Math.imul(ah6, bl6)) | 0;\n    hi = (hi + Math.imul(ah6, bh6)) | 0;\n    lo = (lo + Math.imul(al5, bl7)) | 0;\n    mid = (mid + Math.imul(al5, bh7)) | 0;\n    mid = (mid + Math.imul(ah5, bl7)) | 0;\n    hi = (hi + Math.imul(ah5, bh7)) | 0;\n    lo = (lo + Math.imul(al4, bl8)) | 0;\n    mid = (mid + Math.imul(al4, bh8)) | 0;\n    mid = (mid + Math.imul(ah4, bl8)) | 0;\n    hi = (hi + Math.imul(ah4, bh8)) | 0;\n    lo = (lo + Math.imul(al3, bl9)) | 0;\n    mid = (mid + Math.imul(al3, bh9)) | 0;\n    mid = (mid + Math.imul(ah3, bl9)) | 0;\n    hi = (hi + Math.imul(ah3, bh9)) | 0;\n    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\n    w12 &= 0x3ffffff;\n    /* k = 13 */\n    lo = Math.imul(al9, bl4);\n    mid = Math.imul(al9, bh4);\n    mid = (mid + Math.imul(ah9, bl4)) | 0;\n    hi = Math.imul(ah9, bh4);\n    lo = (lo + Math.imul(al8, bl5)) | 0;\n    mid = (mid + Math.imul(al8, bh5)) | 0;\n    mid = (mid + Math.imul(ah8, bl5)) | 0;\n    hi = (hi + Math.imul(ah8, bh5)) | 0;\n    lo = (lo + Math.imul(al7, bl6)) | 0;\n    mid = (mid + Math.imul(al7, bh6)) | 0;\n    mid = (mid + Math.imul(ah7, bl6)) | 0;\n    hi = (hi + Math.imul(ah7, bh6)) | 0;\n    lo = (lo + Math.imul(al6, bl7)) | 0;\n    mid = (mid + Math.imul(al6, bh7)) | 0;\n    mid = (mid + Math.imul(ah6, bl7)) | 0;\n    hi = (hi + Math.imul(ah6, bh7)) | 0;\n    lo = (lo + Math.imul(al5, bl8)) | 0;\n    mid = (mid + Math.imul(al5, bh8)) | 0;\n    mid = (mid + Math.imul(ah5, bl8)) | 0;\n    hi = (hi + Math.imul(ah5, bh8)) | 0;\n    lo = (lo + Math.imul(al4, bl9)) | 0;\n    mid = (mid + Math.imul(al4, bh9)) | 0;\n    mid = (mid + Math.imul(ah4, bl9)) | 0;\n    hi = (hi + Math.imul(ah4, bh9)) | 0;\n    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\n    w13 &= 0x3ffffff;\n    /* k = 14 */\n    lo = Math.imul(al9, bl5);\n    mid = Math.imul(al9, bh5);\n    mid = (mid + Math.imul(ah9, bl5)) | 0;\n    hi = Math.imul(ah9, bh5);\n    lo = (lo + Math.imul(al8, bl6)) | 0;\n    mid = (mid + Math.imul(al8, bh6)) | 0;\n    mid = (mid + Math.imul(ah8, bl6)) | 0;\n    hi = (hi + Math.imul(ah8, bh6)) | 0;\n    lo = (lo + Math.imul(al7, bl7)) | 0;\n    mid = (mid + Math.imul(al7, bh7)) | 0;\n    mid = (mid + Math.imul(ah7, bl7)) | 0;\n    hi = (hi + Math.imul(ah7, bh7)) | 0;\n    lo = (lo + Math.imul(al6, bl8)) | 0;\n    mid = (mid + Math.imul(al6, bh8)) | 0;\n    mid = (mid + Math.imul(ah6, bl8)) | 0;\n    hi = (hi + Math.imul(ah6, bh8)) | 0;\n    lo = (lo + Math.imul(al5, bl9)) | 0;\n    mid = (mid + Math.imul(al5, bh9)) | 0;\n    mid = (mid + Math.imul(ah5, bl9)) | 0;\n    hi = (hi + Math.imul(ah5, bh9)) | 0;\n    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\n    w14 &= 0x3ffffff;\n    /* k = 15 */\n    lo = Math.imul(al9, bl6);\n    mid = Math.imul(al9, bh6);\n    mid = (mid + Math.imul(ah9, bl6)) | 0;\n    hi = Math.imul(ah9, bh6);\n    lo = (lo + Math.imul(al8, bl7)) | 0;\n    mid = (mid + Math.imul(al8, bh7)) | 0;\n    mid = (mid + Math.imul(ah8, bl7)) | 0;\n    hi = (hi + Math.imul(ah8, bh7)) | 0;\n    lo = (lo + Math.imul(al7, bl8)) | 0;\n    mid = (mid + Math.imul(al7, bh8)) | 0;\n    mid = (mid + Math.imul(ah7, bl8)) | 0;\n    hi = (hi + Math.imul(ah7, bh8)) | 0;\n    lo = (lo + Math.imul(al6, bl9)) | 0;\n    mid = (mid + Math.imul(al6, bh9)) | 0;\n    mid = (mid + Math.imul(ah6, bl9)) | 0;\n    hi = (hi + Math.imul(ah6, bh9)) | 0;\n    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\n    w15 &= 0x3ffffff;\n    /* k = 16 */\n    lo = Math.imul(al9, bl7);\n    mid = Math.imul(al9, bh7);\n    mid = (mid + Math.imul(ah9, bl7)) | 0;\n    hi = Math.imul(ah9, bh7);\n    lo = (lo + Math.imul(al8, bl8)) | 0;\n    mid = (mid + Math.imul(al8, bh8)) | 0;\n    mid = (mid + Math.imul(ah8, bl8)) | 0;\n    hi = (hi + Math.imul(ah8, bh8)) | 0;\n    lo = (lo + Math.imul(al7, bl9)) | 0;\n    mid = (mid + Math.imul(al7, bh9)) | 0;\n    mid = (mid + Math.imul(ah7, bl9)) | 0;\n    hi = (hi + Math.imul(ah7, bh9)) | 0;\n    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\n    w16 &= 0x3ffffff;\n    /* k = 17 */\n    lo = Math.imul(al9, bl8);\n    mid = Math.imul(al9, bh8);\n    mid = (mid + Math.imul(ah9, bl8)) | 0;\n    hi = Math.imul(ah9, bh8);\n    lo = (lo + Math.imul(al8, bl9)) | 0;\n    mid = (mid + Math.imul(al8, bh9)) | 0;\n    mid = (mid + Math.imul(ah8, bl9)) | 0;\n    hi = (hi + Math.imul(ah8, bh9)) | 0;\n    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\n    w17 &= 0x3ffffff;\n    /* k = 18 */\n    lo = Math.imul(al9, bl9);\n    mid = Math.imul(al9, bh9);\n    mid = (mid + Math.imul(ah9, bl9)) | 0;\n    hi = Math.imul(ah9, bh9);\n    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\n    w18 &= 0x3ffffff;\n    o[0] = w0;\n    o[1] = w1;\n    o[2] = w2;\n    o[3] = w3;\n    o[4] = w4;\n    o[5] = w5;\n    o[6] = w6;\n    o[7] = w7;\n    o[8] = w8;\n    o[9] = w9;\n    o[10] = w10;\n    o[11] = w11;\n    o[12] = w12;\n    o[13] = w13;\n    o[14] = w14;\n    o[15] = w15;\n    o[16] = w16;\n    o[17] = w17;\n    o[18] = w18;\n    if (c !== 0) {\n      o[19] = c;\n      out.length++;\n    }\n    return out;\n  };\n\n  // Polyfill comb\n  if (!Math.imul) {\n    comb10MulTo = smallMulTo;\n  }\n\n  function bigMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    out.length = self.length + num.length;\n\n    var carry = 0;\n    var hncarry = 0;\n    for (var k = 0; k < out.length - 1; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = hncarry;\n      hncarry = 0;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = k - j;\n        var a = self.words[i] | 0;\n        var b = num.words[j] | 0;\n        var r = a * b;\n\n        var lo = r & 0x3ffffff;\n        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n        lo = (lo + rword) | 0;\n        rword = lo & 0x3ffffff;\n        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n        hncarry += ncarry >>> 26;\n        ncarry &= 0x3ffffff;\n      }\n      out.words[k] = rword;\n      carry = ncarry;\n      ncarry = hncarry;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  }\n\n  function jumboMulTo (self, num, out) {\n    // Temporary disable, see https://github.com/indutny/bn.js/issues/211\n    // var fftm = new FFTM();\n    // return fftm.mulp(self, num, out);\n    return bigMulTo(self, num, out);\n  }\n\n  BN.prototype.mulTo = function mulTo (num, out) {\n    var res;\n    var len = this.length + num.length;\n    if (this.length === 10 && num.length === 10) {\n      res = comb10MulTo(this, num, out);\n    } else if (len < 63) {\n      res = smallMulTo(this, num, out);\n    } else if (len < 1024) {\n      res = bigMulTo(this, num, out);\n    } else {\n      res = jumboMulTo(this, num, out);\n    }\n\n    return res;\n  };\n\n  // Cooley-Tukey algorithm for FFT\n  // slightly revisited to rely on looping instead of recursion\n\n  function FFTM (x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  FFTM.prototype.makeRBT = function makeRBT (N) {\n    var t = new Array(N);\n    var l = BN.prototype._countBits(N) - 1;\n    for (var i = 0; i < N; i++) {\n      t[i] = this.revBin(i, l, N);\n    }\n\n    return t;\n  };\n\n  // Returns binary-reversed representation of `x`\n  FFTM.prototype.revBin = function revBin (x, l, N) {\n    if (x === 0 || x === N - 1) return x;\n\n    var rb = 0;\n    for (var i = 0; i < l; i++) {\n      rb |= (x & 1) << (l - i - 1);\n      x >>= 1;\n    }\n\n    return rb;\n  };\n\n  // Performs \"tweedling\" phase, therefore 'emulating'\n  // behaviour of the recursive algorithm\n  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n    for (var i = 0; i < N; i++) {\n      rtws[i] = rws[rbt[i]];\n      itws[i] = iws[rbt[i]];\n    }\n  };\n\n  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n    this.permute(rbt, rws, iws, rtws, itws, N);\n\n    for (var s = 1; s < N; s <<= 1) {\n      var l = s << 1;\n\n      var rtwdf = Math.cos(2 * Math.PI / l);\n      var itwdf = Math.sin(2 * Math.PI / l);\n\n      for (var p = 0; p < N; p += l) {\n        var rtwdf_ = rtwdf;\n        var itwdf_ = itwdf;\n\n        for (var j = 0; j < s; j++) {\n          var re = rtws[p + j];\n          var ie = itws[p + j];\n\n          var ro = rtws[p + j + s];\n          var io = itws[p + j + s];\n\n          var rx = rtwdf_ * ro - itwdf_ * io;\n\n          io = rtwdf_ * io + itwdf_ * ro;\n          ro = rx;\n\n          rtws[p + j] = re + ro;\n          itws[p + j] = ie + io;\n\n          rtws[p + j + s] = re - ro;\n          itws[p + j + s] = ie - io;\n\n          /* jshint maxdepth : false */\n          if (j !== l) {\n            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n            rtwdf_ = rx;\n          }\n        }\n      }\n    }\n  };\n\n  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n    var N = Math.max(m, n) | 1;\n    var odd = N & 1;\n    var i = 0;\n    for (N = N / 2 | 0; N; N = N >>> 1) {\n      i++;\n    }\n\n    return 1 << i + 1 + odd;\n  };\n\n  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n    if (N <= 1) return;\n\n    for (var i = 0; i < N / 2; i++) {\n      var t = rws[i];\n\n      rws[i] = rws[N - i - 1];\n      rws[N - i - 1] = t;\n\n      t = iws[i];\n\n      iws[i] = -iws[N - i - 1];\n      iws[N - i - 1] = -t;\n    }\n  };\n\n  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n    var carry = 0;\n    for (var i = 0; i < N / 2; i++) {\n      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n        Math.round(ws[2 * i] / N) +\n        carry;\n\n      ws[i] = w & 0x3ffffff;\n\n      if (w < 0x4000000) {\n        carry = 0;\n      } else {\n        carry = w / 0x4000000 | 0;\n      }\n    }\n\n    return ws;\n  };\n\n  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n    var carry = 0;\n    for (var i = 0; i < len; i++) {\n      carry = carry + (ws[i] | 0);\n\n      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n    }\n\n    // Pad with zeroes\n    for (i = 2 * len; i < N; ++i) {\n      rws[i] = 0;\n    }\n\n    assert(carry === 0);\n    assert((carry & ~0x1fff) === 0);\n  };\n\n  FFTM.prototype.stub = function stub (N) {\n    var ph = new Array(N);\n    for (var i = 0; i < N; i++) {\n      ph[i] = 0;\n    }\n\n    return ph;\n  };\n\n  FFTM.prototype.mulp = function mulp (x, y, out) {\n    var N = 2 * this.guessLen13b(x.length, y.length);\n\n    var rbt = this.makeRBT(N);\n\n    var _ = this.stub(N);\n\n    var rws = new Array(N);\n    var rwst = new Array(N);\n    var iwst = new Array(N);\n\n    var nrws = new Array(N);\n    var nrwst = new Array(N);\n    var niwst = new Array(N);\n\n    var rmws = out.words;\n    rmws.length = N;\n\n    this.convert13b(x.words, x.length, rws, N);\n    this.convert13b(y.words, y.length, nrws, N);\n\n    this.transform(rws, _, rwst, iwst, N, rbt);\n    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n    for (var i = 0; i < N; i++) {\n      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n      rwst[i] = rx;\n    }\n\n    this.conjugate(rwst, iwst, N);\n    this.transform(rwst, iwst, rmws, _, N, rbt);\n    this.conjugate(rmws, _, N);\n    this.normalize13b(rmws, N);\n\n    out.negative = x.negative ^ y.negative;\n    out.length = x.length + y.length;\n    return out._strip();\n  };\n\n  // Multiply `this` by `num`\n  BN.prototype.mul = function mul (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return this.mulTo(num, out);\n  };\n\n  // Multiply employing FFT\n  BN.prototype.mulf = function mulf (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return jumboMulTo(this, num, out);\n  };\n\n  // In-place Multiplication\n  BN.prototype.imul = function imul (num) {\n    return this.clone().mulTo(num, this);\n  };\n\n  BN.prototype.imuln = function imuln (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n\n    // Carry\n    var carry = 0;\n    for (var i = 0; i < this.length; i++) {\n      var w = (this.words[i] | 0) * num;\n      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n      carry >>= 26;\n      carry += (w / 0x4000000) | 0;\n      // NOTE: lo is 27bit maximum\n      carry += lo >>> 26;\n      this.words[i] = lo & 0x3ffffff;\n    }\n\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.muln = function muln (num) {\n    return this.clone().imuln(num);\n  };\n\n  // `this` * `this`\n  BN.prototype.sqr = function sqr () {\n    return this.mul(this);\n  };\n\n  // `this` * `this` in-place\n  BN.prototype.isqr = function isqr () {\n    return this.imul(this.clone());\n  };\n\n  // Math.pow(`this`, `num`)\n  BN.prototype.pow = function pow (num) {\n    var w = toBitArray(num);\n    if (w.length === 0) return new BN(1);\n\n    // Skip leading zeroes\n    var res = this;\n    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n      if (w[i] !== 0) break;\n    }\n\n    if (++i < w.length) {\n      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n        if (w[i] === 0) continue;\n\n        res = res.mul(q);\n      }\n    }\n\n    return res;\n  };\n\n  // Shift-left in-place\n  BN.prototype.iushln = function iushln (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n    var i;\n\n    if (r !== 0) {\n      var carry = 0;\n\n      for (i = 0; i < this.length; i++) {\n        var newCarry = this.words[i] & carryMask;\n        var c = ((this.words[i] | 0) - newCarry) << r;\n        this.words[i] = c | carry;\n        carry = newCarry >>> (26 - r);\n      }\n\n      if (carry) {\n        this.words[i] = carry;\n        this.length++;\n      }\n    }\n\n    if (s !== 0) {\n      for (i = this.length - 1; i >= 0; i--) {\n        this.words[i + s] = this.words[i];\n      }\n\n      for (i = 0; i < s; i++) {\n        this.words[i] = 0;\n      }\n\n      this.length += s;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishln = function ishln (bits) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushln(bits);\n  };\n\n  // Shift-right in-place\n  // NOTE: `hint` is a lowest bit before trailing zeroes\n  // NOTE: if `extended` is present - it will be filled with destroyed bits\n  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var h;\n    if (hint) {\n      h = (hint - (hint % 26)) / 26;\n    } else {\n      h = 0;\n    }\n\n    var r = bits % 26;\n    var s = Math.min((bits - r) / 26, this.length);\n    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n    var maskedWords = extended;\n\n    h -= s;\n    h = Math.max(0, h);\n\n    // Extended mode, copy masked part\n    if (maskedWords) {\n      for (var i = 0; i < s; i++) {\n        maskedWords.words[i] = this.words[i];\n      }\n      maskedWords.length = s;\n    }\n\n    if (s === 0) {\n      // No-op, we should not move anything at all\n    } else if (this.length > s) {\n      this.length -= s;\n      for (i = 0; i < this.length; i++) {\n        this.words[i] = this.words[i + s];\n      }\n    } else {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    var carry = 0;\n    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n      var word = this.words[i] | 0;\n      this.words[i] = (carry << (26 - r)) | (word >>> r);\n      carry = word & mask;\n    }\n\n    // Push carried bits as a mask\n    if (maskedWords && carry !== 0) {\n      maskedWords.words[maskedWords.length++] = carry;\n    }\n\n    if (this.length === 0) {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushrn(bits, hint, extended);\n  };\n\n  // Shift-left\n  BN.prototype.shln = function shln (bits) {\n    return this.clone().ishln(bits);\n  };\n\n  BN.prototype.ushln = function ushln (bits) {\n    return this.clone().iushln(bits);\n  };\n\n  // Shift-right\n  BN.prototype.shrn = function shrn (bits) {\n    return this.clone().ishrn(bits);\n  };\n\n  BN.prototype.ushrn = function ushrn (bits) {\n    return this.clone().iushrn(bits);\n  };\n\n  // Test if n bit is set\n  BN.prototype.testn = function testn (bit) {\n    assert(typeof bit === 'number' && bit >= 0);\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) return false;\n\n    // Check bit and return\n    var w = this.words[s];\n\n    return !!(w & q);\n  };\n\n  // Return only lowers bits of number (in-place)\n  BN.prototype.imaskn = function imaskn (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n\n    assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n    if (this.length <= s) {\n      return this;\n    }\n\n    if (r !== 0) {\n      s++;\n    }\n    this.length = Math.min(s, this.length);\n\n    if (r !== 0) {\n      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n      this.words[this.length - 1] &= mask;\n    }\n\n    return this._strip();\n  };\n\n  // Return only lowers bits of number\n  BN.prototype.maskn = function maskn (bits) {\n    return this.clone().imaskn(bits);\n  };\n\n  // Add plain number `num` to `this`\n  BN.prototype.iaddn = function iaddn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.isubn(-num);\n\n    // Possible sign change\n    if (this.negative !== 0) {\n      if (this.length === 1 && (this.words[0] | 0) <= num) {\n        this.words[0] = num - (this.words[0] | 0);\n        this.negative = 0;\n        return this;\n      }\n\n      this.negative = 0;\n      this.isubn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    // Add without checks\n    return this._iaddn(num);\n  };\n\n  BN.prototype._iaddn = function _iaddn (num) {\n    this.words[0] += num;\n\n    // Carry\n    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n      this.words[i] -= 0x4000000;\n      if (i === this.length - 1) {\n        this.words[i + 1] = 1;\n      } else {\n        this.words[i + 1]++;\n      }\n    }\n    this.length = Math.max(this.length, i + 1);\n\n    return this;\n  };\n\n  // Subtract plain number `num` from `this`\n  BN.prototype.isubn = function isubn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.iaddn(-num);\n\n    if (this.negative !== 0) {\n      this.negative = 0;\n      this.iaddn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    this.words[0] -= num;\n\n    if (this.length === 1 && this.words[0] < 0) {\n      this.words[0] = -this.words[0];\n      this.negative = 1;\n    } else {\n      // Carry\n      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n        this.words[i] += 0x4000000;\n        this.words[i + 1] -= 1;\n      }\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.addn = function addn (num) {\n    return this.clone().iaddn(num);\n  };\n\n  BN.prototype.subn = function subn (num) {\n    return this.clone().isubn(num);\n  };\n\n  BN.prototype.iabs = function iabs () {\n    this.negative = 0;\n\n    return this;\n  };\n\n  BN.prototype.abs = function abs () {\n    return this.clone().iabs();\n  };\n\n  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n    var len = num.length + shift;\n    var i;\n\n    this._expand(len);\n\n    var w;\n    var carry = 0;\n    for (i = 0; i < num.length; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      var right = (num.words[i] | 0) * mul;\n      w -= right & 0x3ffffff;\n      carry = (w >> 26) - ((right / 0x4000000) | 0);\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n    for (; i < this.length - shift; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      carry = w >> 26;\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    if (carry === 0) return this._strip();\n\n    // Subtraction overflow\n    assert(carry === -1);\n    carry = 0;\n    for (i = 0; i < this.length; i++) {\n      w = -(this.words[i] | 0) + carry;\n      carry = w >> 26;\n      this.words[i] = w & 0x3ffffff;\n    }\n    this.negative = 1;\n\n    return this._strip();\n  };\n\n  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n    var shift = this.length - num.length;\n\n    var a = this.clone();\n    var b = num;\n\n    // Normalize\n    var bhi = b.words[b.length - 1] | 0;\n    var bhiBits = this._countBits(bhi);\n    shift = 26 - bhiBits;\n    if (shift !== 0) {\n      b = b.ushln(shift);\n      a.iushln(shift);\n      bhi = b.words[b.length - 1] | 0;\n    }\n\n    // Initialize quotient\n    var m = a.length - b.length;\n    var q;\n\n    if (mode !== 'mod') {\n      q = new BN(null);\n      q.length = m + 1;\n      q.words = new Array(q.length);\n      for (var i = 0; i < q.length; i++) {\n        q.words[i] = 0;\n      }\n    }\n\n    var diff = a.clone()._ishlnsubmul(b, 1, m);\n    if (diff.negative === 0) {\n      a = diff;\n      if (q) {\n        q.words[m] = 1;\n      }\n    }\n\n    for (var j = m - 1; j >= 0; j--) {\n      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n        (a.words[b.length + j - 1] | 0);\n\n      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n      // (0x7ffffff)\n      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n      a._ishlnsubmul(b, qj, j);\n      while (a.negative !== 0) {\n        qj--;\n        a.negative = 0;\n        a._ishlnsubmul(b, 1, j);\n        if (!a.isZero()) {\n          a.negative ^= 1;\n        }\n      }\n      if (q) {\n        q.words[j] = qj;\n      }\n    }\n    if (q) {\n      q._strip();\n    }\n    a._strip();\n\n    // Denormalize\n    if (mode !== 'div' && shift !== 0) {\n      a.iushrn(shift);\n    }\n\n    return {\n      div: q || null,\n      mod: a\n    };\n  };\n\n  // NOTE: 1) `mode` can be set to `mod` to request mod only,\n  //       to `div` to request div only, or be absent to\n  //       request both div & mod\n  //       2) `positive` is true if unsigned mod is requested\n  BN.prototype.divmod = function divmod (num, mode, positive) {\n    assert(!num.isZero());\n\n    if (this.isZero()) {\n      return {\n        div: new BN(0),\n        mod: new BN(0)\n      };\n    }\n\n    var div, mod, res;\n    if (this.negative !== 0 && num.negative === 0) {\n      res = this.neg().divmod(num, mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.iadd(num);\n        }\n      }\n\n      return {\n        div: div,\n        mod: mod\n      };\n    }\n\n    if (this.negative === 0 && num.negative !== 0) {\n      res = this.divmod(num.neg(), mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      return {\n        div: div,\n        mod: res.mod\n      };\n    }\n\n    if ((this.negative & num.negative) !== 0) {\n      res = this.neg().divmod(num.neg(), mode);\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.isub(num);\n        }\n      }\n\n      return {\n        div: res.div,\n        mod: mod\n      };\n    }\n\n    // Both numbers are positive at this point\n\n    // Strip both numbers to approximate shift value\n    if (num.length > this.length || this.cmp(num) < 0) {\n      return {\n        div: new BN(0),\n        mod: this\n      };\n    }\n\n    // Very short reduction\n    if (num.length === 1) {\n      if (mode === 'div') {\n        return {\n          div: this.divn(num.words[0]),\n          mod: null\n        };\n      }\n\n      if (mode === 'mod') {\n        return {\n          div: null,\n          mod: new BN(this.modrn(num.words[0]))\n        };\n      }\n\n      return {\n        div: this.divn(num.words[0]),\n        mod: new BN(this.modrn(num.words[0]))\n      };\n    }\n\n    return this._wordDiv(num, mode);\n  };\n\n  // Find `this` / `num`\n  BN.prototype.div = function div (num) {\n    return this.divmod(num, 'div', false).div;\n  };\n\n  // Find `this` % `num`\n  BN.prototype.mod = function mod (num) {\n    return this.divmod(num, 'mod', false).mod;\n  };\n\n  BN.prototype.umod = function umod (num) {\n    return this.divmod(num, 'mod', true).mod;\n  };\n\n  // Find Round(`this` / `num`)\n  BN.prototype.divRound = function divRound (num) {\n    var dm = this.divmod(num);\n\n    // Fast case - exact division\n    if (dm.mod.isZero()) return dm.div;\n\n    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n    var half = num.ushrn(1);\n    var r2 = num.andln(1);\n    var cmp = mod.cmp(half);\n\n    // Round down\n    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;\n\n    // Round up\n    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n  };\n\n  BN.prototype.modrn = function modrn (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(num <= 0x3ffffff);\n    var p = (1 << 26) % num;\n\n    var acc = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      acc = (p * acc + (this.words[i] | 0)) % num;\n    }\n\n    return isNegNum ? -acc : acc;\n  };\n\n  // WARNING: DEPRECATED\n  BN.prototype.modn = function modn (num) {\n    return this.modrn(num);\n  };\n\n  // In-place division by number\n  BN.prototype.idivn = function idivn (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(num <= 0x3ffffff);\n\n    var carry = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var w = (this.words[i] | 0) + carry * 0x4000000;\n      this.words[i] = (w / num) | 0;\n      carry = w % num;\n    }\n\n    this._strip();\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.divn = function divn (num) {\n    return this.clone().idivn(num);\n  };\n\n  BN.prototype.egcd = function egcd (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var x = this;\n    var y = p.clone();\n\n    if (x.negative !== 0) {\n      x = x.umod(p);\n    } else {\n      x = x.clone();\n    }\n\n    // A * x + B * y = x\n    var A = new BN(1);\n    var B = new BN(0);\n\n    // C * x + D * y = y\n    var C = new BN(0);\n    var D = new BN(1);\n\n    var g = 0;\n\n    while (x.isEven() && y.isEven()) {\n      x.iushrn(1);\n      y.iushrn(1);\n      ++g;\n    }\n\n    var yp = y.clone();\n    var xp = x.clone();\n\n    while (!x.isZero()) {\n      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        x.iushrn(i);\n        while (i-- > 0) {\n          if (A.isOdd() || B.isOdd()) {\n            A.iadd(yp);\n            B.isub(xp);\n          }\n\n          A.iushrn(1);\n          B.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        y.iushrn(j);\n        while (j-- > 0) {\n          if (C.isOdd() || D.isOdd()) {\n            C.iadd(yp);\n            D.isub(xp);\n          }\n\n          C.iushrn(1);\n          D.iushrn(1);\n        }\n      }\n\n      if (x.cmp(y) >= 0) {\n        x.isub(y);\n        A.isub(C);\n        B.isub(D);\n      } else {\n        y.isub(x);\n        C.isub(A);\n        D.isub(B);\n      }\n    }\n\n    return {\n      a: C,\n      b: D,\n      gcd: y.iushln(g)\n    };\n  };\n\n  // This is reduced incarnation of the binary EEA\n  // above, designated to invert members of the\n  // _prime_ fields F(p) at a maximal speed\n  BN.prototype._invmp = function _invmp (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var a = this;\n    var b = p.clone();\n\n    if (a.negative !== 0) {\n      a = a.umod(p);\n    } else {\n      a = a.clone();\n    }\n\n    var x1 = new BN(1);\n    var x2 = new BN(0);\n\n    var delta = b.clone();\n\n    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        a.iushrn(i);\n        while (i-- > 0) {\n          if (x1.isOdd()) {\n            x1.iadd(delta);\n          }\n\n          x1.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        b.iushrn(j);\n        while (j-- > 0) {\n          if (x2.isOdd()) {\n            x2.iadd(delta);\n          }\n\n          x2.iushrn(1);\n        }\n      }\n\n      if (a.cmp(b) >= 0) {\n        a.isub(b);\n        x1.isub(x2);\n      } else {\n        b.isub(a);\n        x2.isub(x1);\n      }\n    }\n\n    var res;\n    if (a.cmpn(1) === 0) {\n      res = x1;\n    } else {\n      res = x2;\n    }\n\n    if (res.cmpn(0) < 0) {\n      res.iadd(p);\n    }\n\n    return res;\n  };\n\n  BN.prototype.gcd = function gcd (num) {\n    if (this.isZero()) return num.abs();\n    if (num.isZero()) return this.abs();\n\n    var a = this.clone();\n    var b = num.clone();\n    a.negative = 0;\n    b.negative = 0;\n\n    // Remove common factor of two\n    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n      a.iushrn(1);\n      b.iushrn(1);\n    }\n\n    do {\n      while (a.isEven()) {\n        a.iushrn(1);\n      }\n      while (b.isEven()) {\n        b.iushrn(1);\n      }\n\n      var r = a.cmp(b);\n      if (r < 0) {\n        // Swap `a` and `b` to make `a` always bigger than `b`\n        var t = a;\n        a = b;\n        b = t;\n      } else if (r === 0 || b.cmpn(1) === 0) {\n        break;\n      }\n\n      a.isub(b);\n    } while (true);\n\n    return b.iushln(shift);\n  };\n\n  // Invert number in the field F(num)\n  BN.prototype.invm = function invm (num) {\n    return this.egcd(num).a.umod(num);\n  };\n\n  BN.prototype.isEven = function isEven () {\n    return (this.words[0] & 1) === 0;\n  };\n\n  BN.prototype.isOdd = function isOdd () {\n    return (this.words[0] & 1) === 1;\n  };\n\n  // And first word and num\n  BN.prototype.andln = function andln (num) {\n    return this.words[0] & num;\n  };\n\n  // Increment at the bit position in-line\n  BN.prototype.bincn = function bincn (bit) {\n    assert(typeof bit === 'number');\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) {\n      this._expand(s + 1);\n      this.words[s] |= q;\n      return this;\n    }\n\n    // Add bit and propagate, if needed\n    var carry = q;\n    for (var i = s; carry !== 0 && i < this.length; i++) {\n      var w = this.words[i] | 0;\n      w += carry;\n      carry = w >>> 26;\n      w &= 0x3ffffff;\n      this.words[i] = w;\n    }\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n    return this;\n  };\n\n  BN.prototype.isZero = function isZero () {\n    return this.length === 1 && this.words[0] === 0;\n  };\n\n  BN.prototype.cmpn = function cmpn (num) {\n    var negative = num < 0;\n\n    if (this.negative !== 0 && !negative) return -1;\n    if (this.negative === 0 && negative) return 1;\n\n    this._strip();\n\n    var res;\n    if (this.length > 1) {\n      res = 1;\n    } else {\n      if (negative) {\n        num = -num;\n      }\n\n      assert(num <= 0x3ffffff, 'Number is too big');\n\n      var w = this.words[0] | 0;\n      res = w === num ? 0 : w < num ? -1 : 1;\n    }\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Compare two numbers and return:\n  // 1 - if `this` > `num`\n  // 0 - if `this` == `num`\n  // -1 - if `this` < `num`\n  BN.prototype.cmp = function cmp (num) {\n    if (this.negative !== 0 && num.negative === 0) return -1;\n    if (this.negative === 0 && num.negative !== 0) return 1;\n\n    var res = this.ucmp(num);\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Unsigned comparison\n  BN.prototype.ucmp = function ucmp (num) {\n    // At this point both numbers have the same sign\n    if (this.length > num.length) return 1;\n    if (this.length < num.length) return -1;\n\n    var res = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var a = this.words[i] | 0;\n      var b = num.words[i] | 0;\n\n      if (a === b) continue;\n      if (a < b) {\n        res = -1;\n      } else if (a > b) {\n        res = 1;\n      }\n      break;\n    }\n    return res;\n  };\n\n  BN.prototype.gtn = function gtn (num) {\n    return this.cmpn(num) === 1;\n  };\n\n  BN.prototype.gt = function gt (num) {\n    return this.cmp(num) === 1;\n  };\n\n  BN.prototype.gten = function gten (num) {\n    return this.cmpn(num) >= 0;\n  };\n\n  BN.prototype.gte = function gte (num) {\n    return this.cmp(num) >= 0;\n  };\n\n  BN.prototype.ltn = function ltn (num) {\n    return this.cmpn(num) === -1;\n  };\n\n  BN.prototype.lt = function lt (num) {\n    return this.cmp(num) === -1;\n  };\n\n  BN.prototype.lten = function lten (num) {\n    return this.cmpn(num) <= 0;\n  };\n\n  BN.prototype.lte = function lte (num) {\n    return this.cmp(num) <= 0;\n  };\n\n  BN.prototype.eqn = function eqn (num) {\n    return this.cmpn(num) === 0;\n  };\n\n  BN.prototype.eq = function eq (num) {\n    return this.cmp(num) === 0;\n  };\n\n  //\n  // A reduce context, could be using montgomery or something better, depending\n  // on the `m` itself.\n  //\n  BN.red = function red (num) {\n    return new Red(num);\n  };\n\n  BN.prototype.toRed = function toRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    assert(this.negative === 0, 'red works only with positives');\n    return ctx.convertTo(this)._forceRed(ctx);\n  };\n\n  BN.prototype.fromRed = function fromRed () {\n    assert(this.red, 'fromRed works only with numbers in reduction context');\n    return this.red.convertFrom(this);\n  };\n\n  BN.prototype._forceRed = function _forceRed (ctx) {\n    this.red = ctx;\n    return this;\n  };\n\n  BN.prototype.forceRed = function forceRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    return this._forceRed(ctx);\n  };\n\n  BN.prototype.redAdd = function redAdd (num) {\n    assert(this.red, 'redAdd works only with red numbers');\n    return this.red.add(this, num);\n  };\n\n  BN.prototype.redIAdd = function redIAdd (num) {\n    assert(this.red, 'redIAdd works only with red numbers');\n    return this.red.iadd(this, num);\n  };\n\n  BN.prototype.redSub = function redSub (num) {\n    assert(this.red, 'redSub works only with red numbers');\n    return this.red.sub(this, num);\n  };\n\n  BN.prototype.redISub = function redISub (num) {\n    assert(this.red, 'redISub works only with red numbers');\n    return this.red.isub(this, num);\n  };\n\n  BN.prototype.redShl = function redShl (num) {\n    assert(this.red, 'redShl works only with red numbers');\n    return this.red.shl(this, num);\n  };\n\n  BN.prototype.redMul = function redMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.mul(this, num);\n  };\n\n  BN.prototype.redIMul = function redIMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.imul(this, num);\n  };\n\n  BN.prototype.redSqr = function redSqr () {\n    assert(this.red, 'redSqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqr(this);\n  };\n\n  BN.prototype.redISqr = function redISqr () {\n    assert(this.red, 'redISqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.isqr(this);\n  };\n\n  // Square root over p\n  BN.prototype.redSqrt = function redSqrt () {\n    assert(this.red, 'redSqrt works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqrt(this);\n  };\n\n  BN.prototype.redInvm = function redInvm () {\n    assert(this.red, 'redInvm works only with red numbers');\n    this.red._verify1(this);\n    return this.red.invm(this);\n  };\n\n  // Return negative clone of `this` % `red modulo`\n  BN.prototype.redNeg = function redNeg () {\n    assert(this.red, 'redNeg works only with red numbers');\n    this.red._verify1(this);\n    return this.red.neg(this);\n  };\n\n  BN.prototype.redPow = function redPow (num) {\n    assert(this.red && !num.red, 'redPow(normalNum)');\n    this.red._verify1(this);\n    return this.red.pow(this, num);\n  };\n\n  // Prime numbers with efficient reduction\n  var primes = {\n    k256: null,\n    p224: null,\n    p192: null,\n    p25519: null\n  };\n\n  // Pseudo-Mersenne prime\n  function MPrime (name, p) {\n    // P = 2 ^ N - K\n    this.name = name;\n    this.p = new BN(p, 16);\n    this.n = this.p.bitLength();\n    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n    this.tmp = this._tmp();\n  }\n\n  MPrime.prototype._tmp = function _tmp () {\n    var tmp = new BN(null);\n    tmp.words = new Array(Math.ceil(this.n / 13));\n    return tmp;\n  };\n\n  MPrime.prototype.ireduce = function ireduce (num) {\n    // Assumes that `num` is less than `P^2`\n    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n    var r = num;\n    var rlen;\n\n    do {\n      this.split(r, this.tmp);\n      r = this.imulK(r);\n      r = r.iadd(this.tmp);\n      rlen = r.bitLength();\n    } while (rlen > this.n);\n\n    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n    if (cmp === 0) {\n      r.words[0] = 0;\n      r.length = 1;\n    } else if (cmp > 0) {\n      r.isub(this.p);\n    } else {\n      if (r.strip !== undefined) {\n        // r is a BN v4 instance\n        r.strip();\n      } else {\n        // r is a BN v5 instance\n        r._strip();\n      }\n    }\n\n    return r;\n  };\n\n  MPrime.prototype.split = function split (input, out) {\n    input.iushrn(this.n, 0, out);\n  };\n\n  MPrime.prototype.imulK = function imulK (num) {\n    return num.imul(this.k);\n  };\n\n  function K256 () {\n    MPrime.call(\n      this,\n      'k256',\n      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n  }\n  inherits(K256, MPrime);\n\n  K256.prototype.split = function split (input, output) {\n    // 256 = 9 * 26 + 22\n    var mask = 0x3fffff;\n\n    var outLen = Math.min(input.length, 9);\n    for (var i = 0; i < outLen; i++) {\n      output.words[i] = input.words[i];\n    }\n    output.length = outLen;\n\n    if (input.length <= 9) {\n      input.words[0] = 0;\n      input.length = 1;\n      return;\n    }\n\n    // Shift by 9 limbs\n    var prev = input.words[9];\n    output.words[output.length++] = prev & mask;\n\n    for (i = 10; i < input.length; i++) {\n      var next = input.words[i] | 0;\n      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n      prev = next;\n    }\n    prev >>>= 22;\n    input.words[i - 10] = prev;\n    if (prev === 0 && input.length > 10) {\n      input.length -= 10;\n    } else {\n      input.length -= 9;\n    }\n  };\n\n  K256.prototype.imulK = function imulK (num) {\n    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n    num.words[num.length] = 0;\n    num.words[num.length + 1] = 0;\n    num.length += 2;\n\n    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n    var lo = 0;\n    for (var i = 0; i < num.length; i++) {\n      var w = num.words[i] | 0;\n      lo += w * 0x3d1;\n      num.words[i] = lo & 0x3ffffff;\n      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n    }\n\n    // Fast length reduction\n    if (num.words[num.length - 1] === 0) {\n      num.length--;\n      if (num.words[num.length - 1] === 0) {\n        num.length--;\n      }\n    }\n    return num;\n  };\n\n  function P224 () {\n    MPrime.call(\n      this,\n      'p224',\n      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n  }\n  inherits(P224, MPrime);\n\n  function P192 () {\n    MPrime.call(\n      this,\n      'p192',\n      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n  }\n  inherits(P192, MPrime);\n\n  function P25519 () {\n    // 2 ^ 255 - 19\n    MPrime.call(\n      this,\n      '25519',\n      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n  }\n  inherits(P25519, MPrime);\n\n  P25519.prototype.imulK = function imulK (num) {\n    // K = 0x13\n    var carry = 0;\n    for (var i = 0; i < num.length; i++) {\n      var hi = (num.words[i] | 0) * 0x13 + carry;\n      var lo = hi & 0x3ffffff;\n      hi >>>= 26;\n\n      num.words[i] = lo;\n      carry = hi;\n    }\n    if (carry !== 0) {\n      num.words[num.length++] = carry;\n    }\n    return num;\n  };\n\n  // Exported mostly for testing purposes, use plain name instead\n  BN._prime = function prime (name) {\n    // Cached version of prime\n    if (primes[name]) return primes[name];\n\n    var prime;\n    if (name === 'k256') {\n      prime = new K256();\n    } else if (name === 'p224') {\n      prime = new P224();\n    } else if (name === 'p192') {\n      prime = new P192();\n    } else if (name === 'p25519') {\n      prime = new P25519();\n    } else {\n      throw new Error('Unknown prime ' + name);\n    }\n    primes[name] = prime;\n\n    return prime;\n  };\n\n  //\n  // Base reduction engine\n  //\n  function Red (m) {\n    if (typeof m === 'string') {\n      var prime = BN._prime(m);\n      this.m = prime.p;\n      this.prime = prime;\n    } else {\n      assert(m.gtn(1), 'modulus must be greater than 1');\n      this.m = m;\n      this.prime = null;\n    }\n  }\n\n  Red.prototype._verify1 = function _verify1 (a) {\n    assert(a.negative === 0, 'red works only with positives');\n    assert(a.red, 'red works only with red numbers');\n  };\n\n  Red.prototype._verify2 = function _verify2 (a, b) {\n    assert((a.negative | b.negative) === 0, 'red works only with positives');\n    assert(a.red && a.red === b.red,\n      'red works only with red numbers');\n  };\n\n  Red.prototype.imod = function imod (a) {\n    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n\n    move(a, a.umod(this.m)._forceRed(this));\n    return a;\n  };\n\n  Red.prototype.neg = function neg (a) {\n    if (a.isZero()) {\n      return a.clone();\n    }\n\n    return this.m.sub(a)._forceRed(this);\n  };\n\n  Red.prototype.add = function add (a, b) {\n    this._verify2(a, b);\n\n    var res = a.add(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.iadd = function iadd (a, b) {\n    this._verify2(a, b);\n\n    var res = a.iadd(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.sub = function sub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.sub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.isub = function isub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.isub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.shl = function shl (a, num) {\n    this._verify1(a);\n    return this.imod(a.ushln(num));\n  };\n\n  Red.prototype.imul = function imul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.imul(b));\n  };\n\n  Red.prototype.mul = function mul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.mul(b));\n  };\n\n  Red.prototype.isqr = function isqr (a) {\n    return this.imul(a, a.clone());\n  };\n\n  Red.prototype.sqr = function sqr (a) {\n    return this.mul(a, a);\n  };\n\n  Red.prototype.sqrt = function sqrt (a) {\n    if (a.isZero()) return a.clone();\n\n    var mod3 = this.m.andln(3);\n    assert(mod3 % 2 === 1);\n\n    // Fast case\n    if (mod3 === 3) {\n      var pow = this.m.add(new BN(1)).iushrn(2);\n      return this.pow(a, pow);\n    }\n\n    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n    //\n    // Find Q and S, that Q * 2 ^ S = (P - 1)\n    var q = this.m.subn(1);\n    var s = 0;\n    while (!q.isZero() && q.andln(1) === 0) {\n      s++;\n      q.iushrn(1);\n    }\n    assert(!q.isZero());\n\n    var one = new BN(1).toRed(this);\n    var nOne = one.redNeg();\n\n    // Find quadratic non-residue\n    // NOTE: Max is such because of generalized Riemann hypothesis.\n    var lpow = this.m.subn(1).iushrn(1);\n    var z = this.m.bitLength();\n    z = new BN(2 * z * z).toRed(this);\n\n    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n      z.redIAdd(nOne);\n    }\n\n    var c = this.pow(z, q);\n    var r = this.pow(a, q.addn(1).iushrn(1));\n    var t = this.pow(a, q);\n    var m = s;\n    while (t.cmp(one) !== 0) {\n      var tmp = t;\n      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n        tmp = tmp.redSqr();\n      }\n      assert(i < m);\n      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n      r = r.redMul(b);\n      c = b.redSqr();\n      t = t.redMul(c);\n      m = i;\n    }\n\n    return r;\n  };\n\n  Red.prototype.invm = function invm (a) {\n    var inv = a._invmp(this.m);\n    if (inv.negative !== 0) {\n      inv.negative = 0;\n      return this.imod(inv).redNeg();\n    } else {\n      return this.imod(inv);\n    }\n  };\n\n  Red.prototype.pow = function pow (a, num) {\n    if (num.isZero()) return new BN(1).toRed(this);\n    if (num.cmpn(1) === 0) return a.clone();\n\n    var windowSize = 4;\n    var wnd = new Array(1 << windowSize);\n    wnd[0] = new BN(1).toRed(this);\n    wnd[1] = a;\n    for (var i = 2; i < wnd.length; i++) {\n      wnd[i] = this.mul(wnd[i - 1], a);\n    }\n\n    var res = wnd[0];\n    var current = 0;\n    var currentLen = 0;\n    var start = num.bitLength() % 26;\n    if (start === 0) {\n      start = 26;\n    }\n\n    for (i = num.length - 1; i >= 0; i--) {\n      var word = num.words[i];\n      for (var j = start - 1; j >= 0; j--) {\n        var bit = (word >> j) & 1;\n        if (res !== wnd[0]) {\n          res = this.sqr(res);\n        }\n\n        if (bit === 0 && current === 0) {\n          currentLen = 0;\n          continue;\n        }\n\n        current <<= 1;\n        current |= bit;\n        currentLen++;\n        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n        res = this.mul(res, wnd[current]);\n        currentLen = 0;\n        current = 0;\n      }\n      start = 26;\n    }\n\n    return res;\n  };\n\n  Red.prototype.convertTo = function convertTo (num) {\n    var r = num.umod(this.m);\n\n    return r === num ? r.clone() : r;\n  };\n\n  Red.prototype.convertFrom = function convertFrom (num) {\n    var res = num.clone();\n    res.red = null;\n    return res;\n  };\n\n  //\n  // Montgomery method engine\n  //\n\n  BN.mont = function mont (num) {\n    return new Mont(num);\n  };\n\n  function Mont (m) {\n    Red.call(this, m);\n\n    this.shift = this.m.bitLength();\n    if (this.shift % 26 !== 0) {\n      this.shift += 26 - (this.shift % 26);\n    }\n\n    this.r = new BN(1).iushln(this.shift);\n    this.r2 = this.imod(this.r.sqr());\n    this.rinv = this.r._invmp(this.m);\n\n    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n    this.minv = this.minv.umod(this.r);\n    this.minv = this.r.sub(this.minv);\n  }\n  inherits(Mont, Red);\n\n  Mont.prototype.convertTo = function convertTo (num) {\n    return this.imod(num.ushln(this.shift));\n  };\n\n  Mont.prototype.convertFrom = function convertFrom (num) {\n    var r = this.imod(num.mul(this.rinv));\n    r.red = null;\n    return r;\n  };\n\n  Mont.prototype.imul = function imul (a, b) {\n    if (a.isZero() || b.isZero()) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    var t = a.imul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.mul = function mul (a, b) {\n    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n    var t = a.mul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.invm = function invm (a) {\n    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n    var res = this.imod(a._invmp(this.m).mul(this.r2));\n    return res._forceRed(this);\n  };\n})( false || module, this);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack://Fabric/./node_modules/browserify-rsa/node_modules/bn.js/lib/bn.js?");
./assets/service.js:eval("/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {\n  'use strict';\n\n  // Utils\n  function assert (val, msg) {\n    if (!val) throw new Error(msg || 'Assertion failed');\n  }\n\n  // Could use `inherits` module, but don't want to move from single file\n  // architecture yet.\n  function inherits (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  }\n\n  // BN\n\n  function BN (number, base, endian) {\n    if (BN.isBN(number)) {\n      return number;\n    }\n\n    this.negative = 0;\n    this.words = null;\n    this.length = 0;\n\n    // Reduction context\n    this.red = null;\n\n    if (number !== null) {\n      if (base === 'le' || base === 'be') {\n        endian = base;\n        base = 10;\n      }\n\n      this._init(number || 0, base || 10, endian || 'be');\n    }\n  }\n  if (typeof module === 'object') {\n    module.exports = BN;\n  } else {\n    exports.BN = BN;\n  }\n\n  BN.BN = BN;\n  BN.wordSize = 26;\n\n  var Buffer;\n  try {\n    Buffer = __webpack_require__(/*! buffer */ 9).Buffer;\n  } catch (e) {\n  }\n\n  BN.isBN = function isBN (num) {\n    if (num instanceof BN) {\n      return true;\n    }\n\n    return num !== null && typeof num === 'object' &&\n      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n  };\n\n  BN.max = function max (left, right) {\n    if (left.cmp(right) > 0) return left;\n    return right;\n  };\n\n  BN.min = function min (left, right) {\n    if (left.cmp(right) < 0) return left;\n    return right;\n  };\n\n  BN.prototype._init = function init (number, base, endian) {\n    if (typeof number === 'number') {\n      return this._initNumber(number, base, endian);\n    }\n\n    if (typeof number === 'object') {\n      return this._initArray(number, base, endian);\n    }\n\n    if (base === 'hex') {\n      base = 16;\n    }\n    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n    number = number.toString().replace(/\\s+/g, '');\n    var start = 0;\n    if (number[0] === '-') {\n      start++;\n    }\n\n    if (base === 16) {\n      this._parseHex(number, start);\n    } else {\n      this._parseBase(number, base, start);\n    }\n\n    if (number[0] === '-') {\n      this.negative = 1;\n    }\n\n    this._strip();\n\n    if (endian !== 'le') return;\n\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n    if (number < 0) {\n      this.negative = 1;\n      number = -number;\n    }\n    if (number < 0x4000000) {\n      this.words = [number & 0x3ffffff];\n      this.length = 1;\n    } else if (number < 0x10000000000000) {\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff\n      ];\n      this.length = 2;\n    } else {\n      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff,\n        1\n      ];\n      this.length = 3;\n    }\n\n    if (endian !== 'le') return;\n\n    // Reverse the bytes\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initArray = function _initArray (number, base, endian) {\n    // Perhaps a Uint8Array\n    assert(typeof number.length === 'number');\n    if (number.length <= 0) {\n      this.words = [0];\n      this.length = 1;\n      return this;\n    }\n\n    this.length = Math.ceil(number.length / 3);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    var off = 0;\n    if (endian === 'be') {\n      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    } else if (endian === 'le') {\n      for (i = 0, j = 0; i < number.length; i += 3) {\n        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    }\n    return this._strip();\n  };\n\n  function parseHex (str, start, end) {\n    var r = 0;\n    var len = Math.min(str.length, end);\n    var z = 0;\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r <<= 4;\n\n      var b;\n\n      // 'a' - 'f'\n      if (c >= 49 && c <= 54) {\n        b = c - 49 + 0xa;\n\n      // 'A' - 'F'\n      } else if (c >= 17 && c <= 22) {\n        b = c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        b = c;\n      }\n\n      r |= b;\n      z |= b;\n    }\n\n    assert(!(z & 0xf0), 'Invalid character in ' + str);\n    return r;\n  }\n\n  BN.prototype._parseHex = function _parseHex (number, start) {\n    // Create possibly bigger array to ensure that it fits the number\n    this.length = Math.ceil((number.length - start) / 6);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    // Scan 24-bit chunks and add them to the number\n    var off = 0;\n    for (i = number.length - 6, j = 0; i >= start; i -= 6) {\n      w = parseHex(number, i, i + 6);\n      this.words[j] |= (w << off) & 0x3ffffff;\n      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb\n      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n      off += 24;\n      if (off >= 26) {\n        off -= 26;\n        j++;\n      }\n    }\n    if (i + 6 !== start) {\n      w = parseHex(number, start, i + 6);\n      this.words[j] |= (w << off) & 0x3ffffff;\n      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n    }\n    this._strip();\n  };\n\n  function parseBase (str, start, end, mul) {\n    var r = 0;\n    var b = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r *= mul;\n\n      // 'a'\n      if (c >= 49) {\n        b = c - 49 + 0xa;\n\n      // 'A'\n      } else if (c >= 17) {\n        b = c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        b = c;\n      }\n      assert(c >= 0 && b < mul, 'Invalid character');\n      r += b;\n    }\n    return r;\n  }\n\n  BN.prototype._parseBase = function _parseBase (number, base, start) {\n    // Initialize as zero\n    this.words = [0];\n    this.length = 1;\n\n    // Find length of limb in base\n    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n      limbLen++;\n    }\n    limbLen--;\n    limbPow = (limbPow / base) | 0;\n\n    var total = number.length - start;\n    var mod = total % limbLen;\n    var end = Math.min(total, total - mod) + start;\n\n    var word = 0;\n    for (var i = start; i < end; i += limbLen) {\n      word = parseBase(number, i, i + limbLen, base);\n\n      this.imuln(limbPow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    if (mod !== 0) {\n      var pow = 1;\n      word = parseBase(number, i, number.length, base);\n\n      for (i = 0; i < mod; i++) {\n        pow *= base;\n      }\n\n      this.imuln(pow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n  };\n\n  BN.prototype.copy = function copy (dest) {\n    dest.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      dest.words[i] = this.words[i];\n    }\n    dest.length = this.length;\n    dest.negative = this.negative;\n    dest.red = this.red;\n  };\n\n  function move (dest, src) {\n    dest.words = src.words;\n    dest.length = src.length;\n    dest.negative = src.negative;\n    dest.red = src.red;\n  }\n\n  BN.prototype._move = function _move (dest) {\n    move(dest, this);\n  };\n\n  BN.prototype.clone = function clone () {\n    var r = new BN(null);\n    this.copy(r);\n    return r;\n  };\n\n  BN.prototype._expand = function _expand (size) {\n    while (this.length < size) {\n      this.words[this.length++] = 0;\n    }\n    return this;\n  };\n\n  // Remove leading `0` from `this`\n  BN.prototype._strip = function strip () {\n    while (this.length > 1 && this.words[this.length - 1] === 0) {\n      this.length--;\n    }\n    return this._normSign();\n  };\n\n  BN.prototype._normSign = function _normSign () {\n    // -0 = 0\n    if (this.length === 1 && this.words[0] === 0) {\n      this.negative = 0;\n    }\n    return this;\n  };\n\n  // Check Symbol.for because not everywhere where Symbol defined\n  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility\n  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {\n    try {\n      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;\n    } catch (e) {\n      BN.prototype.inspect = inspect;\n    }\n  } else {\n    BN.prototype.inspect = inspect;\n  }\n\n  function inspect () {\n    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n  }\n\n  /*\n\n  var zeros = [];\n  var groupSizes = [];\n  var groupBases = [];\n\n  var s = '';\n  var i = -1;\n  while (++i < BN.wordSize) {\n    zeros[i] = s;\n    s += '0';\n  }\n  groupSizes[0] = 0;\n  groupSizes[1] = 0;\n  groupBases[0] = 0;\n  groupBases[1] = 0;\n  var base = 2 - 1;\n  while (++base < 36 + 1) {\n    var groupSize = 0;\n    var groupBase = 1;\n    while (groupBase < (1 << BN.wordSize) / base) {\n      groupBase *= base;\n      groupSize += 1;\n    }\n    groupSizes[base] = groupSize;\n    groupBases[base] = groupBase;\n  }\n\n  */\n\n  var zeros = [\n    '',\n    '0',\n    '00',\n    '000',\n    '0000',\n    '00000',\n    '000000',\n    '0000000',\n    '00000000',\n    '000000000',\n    '0000000000',\n    '00000000000',\n    '000000000000',\n    '0000000000000',\n    '00000000000000',\n    '000000000000000',\n    '0000000000000000',\n    '00000000000000000',\n    '000000000000000000',\n    '0000000000000000000',\n    '00000000000000000000',\n    '000000000000000000000',\n    '0000000000000000000000',\n    '00000000000000000000000',\n    '000000000000000000000000',\n    '0000000000000000000000000'\n  ];\n\n  var groupSizes = [\n    0, 0,\n    25, 16, 12, 11, 10, 9, 8,\n    8, 7, 7, 7, 7, 6, 6,\n    6, 6, 6, 6, 6, 5, 5,\n    5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5\n  ];\n\n  var groupBases = [\n    0, 0,\n    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n  ];\n\n  BN.prototype.toString = function toString (base, padding) {\n    base = base || 10;\n    padding = padding | 0 || 1;\n\n    var out;\n    if (base === 16 || base === 'hex') {\n      out = '';\n      var off = 0;\n      var carry = 0;\n      for (var i = 0; i < this.length; i++) {\n        var w = this.words[i];\n        var word = (((w << off) | carry) & 0xffffff).toString(16);\n        carry = (w >>> (24 - off)) & 0xffffff;\n        if (carry !== 0 || i !== this.length - 1) {\n          out = zeros[6 - word.length] + word + out;\n        } else {\n          out = word + out;\n        }\n        off += 2;\n        if (off >= 26) {\n          off -= 26;\n          i--;\n        }\n      }\n      if (carry !== 0) {\n        out = carry.toString(16) + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    if (base === (base | 0) && base >= 2 && base <= 36) {\n      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n      var groupSize = groupSizes[base];\n      // var groupBase = Math.pow(base, groupSize);\n      var groupBase = groupBases[base];\n      out = '';\n      var c = this.clone();\n      c.negative = 0;\n      while (!c.isZero()) {\n        var r = c.modrn(groupBase).toString(base);\n        c = c.idivn(groupBase);\n\n        if (!c.isZero()) {\n          out = zeros[groupSize - r.length] + r + out;\n        } else {\n          out = r + out;\n        }\n      }\n      if (this.isZero()) {\n        out = '0' + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    assert(false, 'Base should be between 2 and 36');\n  };\n\n  BN.prototype.toNumber = function toNumber () {\n    var ret = this.words[0];\n    if (this.length === 2) {\n      ret += this.words[1] * 0x4000000;\n    } else if (this.length === 3 && this.words[2] === 0x01) {\n      // NOTE: at this stage it is known that the top bit is set\n      ret += 0x10000000000000 + (this.words[1] * 0x4000000);\n    } else if (this.length > 2) {\n      assert(false, 'Number can only safely store up to 53 bits');\n    }\n    return (this.negative !== 0) ? -ret : ret;\n  };\n\n  BN.prototype.toJSON = function toJSON () {\n    return this.toString(16, 2);\n  };\n\n  if (Buffer) {\n    BN.prototype.toBuffer = function toBuffer (endian, length) {\n      return this.toArrayLike(Buffer, endian, length);\n    };\n  }\n\n  BN.prototype.toArray = function toArray (endian, length) {\n    return this.toArrayLike(Array, endian, length);\n  };\n\n  var allocate = function allocate (ArrayType, size) {\n    if (ArrayType.allocUnsafe) {\n      return ArrayType.allocUnsafe(size);\n    }\n    return new ArrayType(size);\n  };\n\n  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {\n    this._strip();\n\n    var byteLength = this.byteLength();\n    var reqLength = length || Math.max(1, byteLength);\n    assert(byteLength <= reqLength, 'byte array longer than desired length');\n    assert(reqLength > 0, 'Requested array length <= 0');\n\n    var res = allocate(ArrayType, reqLength);\n    var postfix = endian === 'le' ? 'LE' : 'BE';\n    this['_toArrayLike' + postfix](res, byteLength);\n    return res;\n  };\n\n  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {\n    var position = 0;\n    var carry = 0;\n\n    for (var i = 0, shift = 0; i < this.length; i++) {\n      var word = (this.words[i] << shift) | carry;\n\n      res[position++] = word & 0xff;\n      if (position < res.length) {\n        res[position++] = (word >> 8) & 0xff;\n      }\n      if (position < res.length) {\n        res[position++] = (word >> 16) & 0xff;\n      }\n\n      if (shift === 6) {\n        if (position < res.length) {\n          res[position++] = (word >> 24) & 0xff;\n        }\n        carry = 0;\n        shift = 0;\n      } else {\n        carry = word >>> 24;\n        shift += 2;\n      }\n    }\n\n    if (position < res.length) {\n      res[position++] = carry;\n\n      while (position < res.length) {\n        res[position++] = 0;\n      }\n    }\n  };\n\n  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {\n    var position = res.length - 1;\n    var carry = 0;\n\n    for (var i = 0, shift = 0; i < this.length; i++) {\n      var word = (this.words[i] << shift) | carry;\n\n      res[position--] = word & 0xff;\n      if (position >= 0) {\n        res[position--] = (word >> 8) & 0xff;\n      }\n      if (position >= 0) {\n        res[position--] = (word >> 16) & 0xff;\n      }\n\n      if (shift === 6) {\n        if (position >= 0) {\n          res[position--] = (word >> 24) & 0xff;\n        }\n        carry = 0;\n        shift = 0;\n      } else {\n        carry = word >>> 24;\n        shift += 2;\n      }\n    }\n\n    if (position >= 0) {\n      res[position--] = carry;\n\n      while (position >= 0) {\n        res[position--] = 0;\n      }\n    }\n  };\n\n  if (Math.clz32) {\n    BN.prototype._countBits = function _countBits (w) {\n      return 32 - Math.clz32(w);\n    };\n  } else {\n    BN.prototype._countBits = function _countBits (w) {\n      var t = w;\n      var r = 0;\n      if (t >= 0x1000) {\n        r += 13;\n        t >>>= 13;\n      }\n      if (t >= 0x40) {\n        r += 7;\n        t >>>= 7;\n      }\n      if (t >= 0x8) {\n        r += 4;\n        t >>>= 4;\n      }\n      if (t >= 0x02) {\n        r += 2;\n        t >>>= 2;\n      }\n      return r + t;\n    };\n  }\n\n  BN.prototype._zeroBits = function _zeroBits (w) {\n    // Short-cut\n    if (w === 0) return 26;\n\n    var t = w;\n    var r = 0;\n    if ((t & 0x1fff) === 0) {\n      r += 13;\n      t >>>= 13;\n    }\n    if ((t & 0x7f) === 0) {\n      r += 7;\n      t >>>= 7;\n    }\n    if ((t & 0xf) === 0) {\n      r += 4;\n      t >>>= 4;\n    }\n    if ((t & 0x3) === 0) {\n      r += 2;\n      t >>>= 2;\n    }\n    if ((t & 0x1) === 0) {\n      r++;\n    }\n    return r;\n  };\n\n  // Return number of used bits in a BN\n  BN.prototype.bitLength = function bitLength () {\n    var w = this.words[this.length - 1];\n    var hi = this._countBits(w);\n    return (this.length - 1) * 26 + hi;\n  };\n\n  function toBitArray (num) {\n    var w = new Array(num.bitLength());\n\n    for (var bit = 0; bit < w.length; bit++) {\n      var off = (bit / 26) | 0;\n      var wbit = bit % 26;\n\n      w[bit] = (num.words[off] >>> wbit) & 0x01;\n    }\n\n    return w;\n  }\n\n  // Number of trailing zero bits\n  BN.prototype.zeroBits = function zeroBits () {\n    if (this.isZero()) return 0;\n\n    var r = 0;\n    for (var i = 0; i < this.length; i++) {\n      var b = this._zeroBits(this.words[i]);\n      r += b;\n      if (b !== 26) break;\n    }\n    return r;\n  };\n\n  BN.prototype.byteLength = function byteLength () {\n    return Math.ceil(this.bitLength() / 8);\n  };\n\n  BN.prototype.toTwos = function toTwos (width) {\n    if (this.negative !== 0) {\n      return this.abs().inotn(width).iaddn(1);\n    }\n    return this.clone();\n  };\n\n  BN.prototype.fromTwos = function fromTwos (width) {\n    if (this.testn(width - 1)) {\n      return this.notn(width).iaddn(1).ineg();\n    }\n    return this.clone();\n  };\n\n  BN.prototype.isNeg = function isNeg () {\n    return this.negative !== 0;\n  };\n\n  // Return negative clone of `this`\n  BN.prototype.neg = function neg () {\n    return this.clone().ineg();\n  };\n\n  BN.prototype.ineg = function ineg () {\n    if (!this.isZero()) {\n      this.negative ^= 1;\n    }\n\n    return this;\n  };\n\n  // Or `num` with `this` in-place\n  BN.prototype.iuor = function iuor (num) {\n    while (this.length < num.length) {\n      this.words[this.length++] = 0;\n    }\n\n    for (var i = 0; i < num.length; i++) {\n      this.words[i] = this.words[i] | num.words[i];\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ior = function ior (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuor(num);\n  };\n\n  // Or `num` with `this`\n  BN.prototype.or = function or (num) {\n    if (this.length > num.length) return this.clone().ior(num);\n    return num.clone().ior(this);\n  };\n\n  BN.prototype.uor = function uor (num) {\n    if (this.length > num.length) return this.clone().iuor(num);\n    return num.clone().iuor(this);\n  };\n\n  // And `num` with `this` in-place\n  BN.prototype.iuand = function iuand (num) {\n    // b = min-length(num, this)\n    var b;\n    if (this.length > num.length) {\n      b = num;\n    } else {\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = this.words[i] & num.words[i];\n    }\n\n    this.length = b.length;\n\n    return this._strip();\n  };\n\n  BN.prototype.iand = function iand (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuand(num);\n  };\n\n  // And `num` with `this`\n  BN.prototype.and = function and (num) {\n    if (this.length > num.length) return this.clone().iand(num);\n    return num.clone().iand(this);\n  };\n\n  BN.prototype.uand = function uand (num) {\n    if (this.length > num.length) return this.clone().iuand(num);\n    return num.clone().iuand(this);\n  };\n\n  // Xor `num` with `this` in-place\n  BN.prototype.iuxor = function iuxor (num) {\n    // a.length > b.length\n    var a;\n    var b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = a.words[i] ^ b.words[i];\n    }\n\n    if (this !== a) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = a.length;\n\n    return this._strip();\n  };\n\n  BN.prototype.ixor = function ixor (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuxor(num);\n  };\n\n  // Xor `num` with `this`\n  BN.prototype.xor = function xor (num) {\n    if (this.length > num.length) return this.clone().ixor(num);\n    return num.clone().ixor(this);\n  };\n\n  BN.prototype.uxor = function uxor (num) {\n    if (this.length > num.length) return this.clone().iuxor(num);\n    return num.clone().iuxor(this);\n  };\n\n  // Not ``this`` with ``width`` bitwidth\n  BN.prototype.inotn = function inotn (width) {\n    assert(typeof width === 'number' && width >= 0);\n\n    var bytesNeeded = Math.ceil(width / 26) | 0;\n    var bitsLeft = width % 26;\n\n    // Extend the buffer with leading zeroes\n    this._expand(bytesNeeded);\n\n    if (bitsLeft > 0) {\n      bytesNeeded--;\n    }\n\n    // Handle complete words\n    for (var i = 0; i < bytesNeeded; i++) {\n      this.words[i] = ~this.words[i] & 0x3ffffff;\n    }\n\n    // Handle the residue\n    if (bitsLeft > 0) {\n      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n    }\n\n    // And remove leading zeroes\n    return this._strip();\n  };\n\n  BN.prototype.notn = function notn (width) {\n    return this.clone().inotn(width);\n  };\n\n  // Set `bit` of `this`\n  BN.prototype.setn = function setn (bit, val) {\n    assert(typeof bit === 'number' && bit >= 0);\n\n    var off = (bit / 26) | 0;\n    var wbit = bit % 26;\n\n    this._expand(off + 1);\n\n    if (val) {\n      this.words[off] = this.words[off] | (1 << wbit);\n    } else {\n      this.words[off] = this.words[off] & ~(1 << wbit);\n    }\n\n    return this._strip();\n  };\n\n  // Add `num` to `this` in-place\n  BN.prototype.iadd = function iadd (num) {\n    var r;\n\n    // negative + positive\n    if (this.negative !== 0 && num.negative === 0) {\n      this.negative = 0;\n      r = this.isub(num);\n      this.negative ^= 1;\n      return this._normSign();\n\n    // positive + negative\n    } else if (this.negative === 0 && num.negative !== 0) {\n      num.negative = 0;\n      r = this.isub(num);\n      num.negative = 1;\n      return r._normSign();\n    }\n\n    // a.length > b.length\n    var a, b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    this.length = a.length;\n    if (carry !== 0) {\n      this.words[this.length] = carry;\n      this.length++;\n    // Copy the rest of the words\n    } else if (a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    return this;\n  };\n\n  // Add `num` to `this`\n  BN.prototype.add = function add (num) {\n    var res;\n    if (num.negative !== 0 && this.negative === 0) {\n      num.negative = 0;\n      res = this.sub(num);\n      num.negative ^= 1;\n      return res;\n    } else if (num.negative === 0 && this.negative !== 0) {\n      this.negative = 0;\n      res = num.sub(this);\n      this.negative = 1;\n      return res;\n    }\n\n    if (this.length > num.length) return this.clone().iadd(num);\n\n    return num.clone().iadd(this);\n  };\n\n  // Subtract `num` from `this` in-place\n  BN.prototype.isub = function isub (num) {\n    // this - (-num) = this + num\n    if (num.negative !== 0) {\n      num.negative = 0;\n      var r = this.iadd(num);\n      num.negative = 1;\n      return r._normSign();\n\n    // -this - num = -(this + num)\n    } else if (this.negative !== 0) {\n      this.negative = 0;\n      this.iadd(num);\n      this.negative = 1;\n      return this._normSign();\n    }\n\n    // At this point both numbers are positive\n    var cmp = this.cmp(num);\n\n    // Optimization - zeroify\n    if (cmp === 0) {\n      this.negative = 0;\n      this.length = 1;\n      this.words[0] = 0;\n      return this;\n    }\n\n    // a > b\n    var a, b;\n    if (cmp > 0) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n\n    // Copy rest of the words\n    if (carry === 0 && i < a.length && a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = Math.max(this.length, i);\n\n    if (a !== this) {\n      this.negative = 1;\n    }\n\n    return this._strip();\n  };\n\n  // Subtract `num` from `this`\n  BN.prototype.sub = function sub (num) {\n    return this.clone().isub(num);\n  };\n\n  function smallMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    var len = (self.length + num.length) | 0;\n    out.length = len;\n    len = (len - 1) | 0;\n\n    // Peel one iteration (compiler can't do it, because of code complexity)\n    var a = self.words[0] | 0;\n    var b = num.words[0] | 0;\n    var r = a * b;\n\n    var lo = r & 0x3ffffff;\n    var carry = (r / 0x4000000) | 0;\n    out.words[0] = lo;\n\n    for (var k = 1; k < len; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = carry >>> 26;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = (k - j) | 0;\n        a = self.words[i] | 0;\n        b = num.words[j] | 0;\n        r = a * b + rword;\n        ncarry += (r / 0x4000000) | 0;\n        rword = r & 0x3ffffff;\n      }\n      out.words[k] = rword | 0;\n      carry = ncarry | 0;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry | 0;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  }\n\n  // TODO(indutny): it may be reasonable to omit it for users who don't need\n  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n  // multiplication (like elliptic secp256k1).\n  var comb10MulTo = function comb10MulTo (self, num, out) {\n    var a = self.words;\n    var b = num.words;\n    var o = out.words;\n    var c = 0;\n    var lo;\n    var mid;\n    var hi;\n    var a0 = a[0] | 0;\n    var al0 = a0 & 0x1fff;\n    var ah0 = a0 >>> 13;\n    var a1 = a[1] | 0;\n    var al1 = a1 & 0x1fff;\n    var ah1 = a1 >>> 13;\n    var a2 = a[2] | 0;\n    var al2 = a2 & 0x1fff;\n    var ah2 = a2 >>> 13;\n    var a3 = a[3] | 0;\n    var al3 = a3 & 0x1fff;\n    var ah3 = a3 >>> 13;\n    var a4 = a[4] | 0;\n    var al4 = a4 & 0x1fff;\n    var ah4 = a4 >>> 13;\n    var a5 = a[5] | 0;\n    var al5 = a5 & 0x1fff;\n    var ah5 = a5 >>> 13;\n    var a6 = a[6] | 0;\n    var al6 = a6 & 0x1fff;\n    var ah6 = a6 >>> 13;\n    var a7 = a[7] | 0;\n    var al7 = a7 & 0x1fff;\n    var ah7 = a7 >>> 13;\n    var a8 = a[8] | 0;\n    var al8 = a8 & 0x1fff;\n    var ah8 = a8 >>> 13;\n    var a9 = a[9] | 0;\n    var al9 = a9 & 0x1fff;\n    var ah9 = a9 >>> 13;\n    var b0 = b[0] | 0;\n    var bl0 = b0 & 0x1fff;\n    var bh0 = b0 >>> 13;\n    var b1 = b[1] | 0;\n    var bl1 = b1 & 0x1fff;\n    var bh1 = b1 >>> 13;\n    var b2 = b[2] | 0;\n    var bl2 = b2 & 0x1fff;\n    var bh2 = b2 >>> 13;\n    var b3 = b[3] | 0;\n    var bl3 = b3 & 0x1fff;\n    var bh3 = b3 >>> 13;\n    var b4 = b[4] | 0;\n    var bl4 = b4 & 0x1fff;\n    var bh4 = b4 >>> 13;\n    var b5 = b[5] | 0;\n    var bl5 = b5 & 0x1fff;\n    var bh5 = b5 >>> 13;\n    var b6 = b[6] | 0;\n    var bl6 = b6 & 0x1fff;\n    var bh6 = b6 >>> 13;\n    var b7 = b[7] | 0;\n    var bl7 = b7 & 0x1fff;\n    var bh7 = b7 >>> 13;\n    var b8 = b[8] | 0;\n    var bl8 = b8 & 0x1fff;\n    var bh8 = b8 >>> 13;\n    var b9 = b[9] | 0;\n    var bl9 = b9 & 0x1fff;\n    var bh9 = b9 >>> 13;\n\n    out.negative = self.negative ^ num.negative;\n    out.length = 19;\n    /* k = 0 */\n    lo = Math.imul(al0, bl0);\n    mid = Math.imul(al0, bh0);\n    mid = (mid + Math.imul(ah0, bl0)) | 0;\n    hi = Math.imul(ah0, bh0);\n    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\n    w0 &= 0x3ffffff;\n    /* k = 1 */\n    lo = Math.imul(al1, bl0);\n    mid = Math.imul(al1, bh0);\n    mid = (mid + Math.imul(ah1, bl0)) | 0;\n    hi = Math.imul(ah1, bh0);\n    lo = (lo + Math.imul(al0, bl1)) | 0;\n    mid = (mid + Math.imul(al0, bh1)) | 0;\n    mid = (mid + Math.imul(ah0, bl1)) | 0;\n    hi = (hi + Math.imul(ah0, bh1)) | 0;\n    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\n    w1 &= 0x3ffffff;\n    /* k = 2 */\n    lo = Math.imul(al2, bl0);\n    mid = Math.imul(al2, bh0);\n    mid = (mid + Math.imul(ah2, bl0)) | 0;\n    hi = Math.imul(ah2, bh0);\n    lo = (lo + Math.imul(al1, bl1)) | 0;\n    mid = (mid + Math.imul(al1, bh1)) | 0;\n    mid = (mid + Math.imul(ah1, bl1)) | 0;\n    hi = (hi + Math.imul(ah1, bh1)) | 0;\n    lo = (lo + Math.imul(al0, bl2)) | 0;\n    mid = (mid + Math.imul(al0, bh2)) | 0;\n    mid = (mid + Math.imul(ah0, bl2)) | 0;\n    hi = (hi + Math.imul(ah0, bh2)) | 0;\n    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\n    w2 &= 0x3ffffff;\n    /* k = 3 */\n    lo = Math.imul(al3, bl0);\n    mid = Math.imul(al3, bh0);\n    mid = (mid + Math.imul(ah3, bl0)) | 0;\n    hi = Math.imul(ah3, bh0);\n    lo = (lo + Math.imul(al2, bl1)) | 0;\n    mid = (mid + Math.imul(al2, bh1)) | 0;\n    mid = (mid + Math.imul(ah2, bl1)) | 0;\n    hi = (hi + Math.imul(ah2, bh1)) | 0;\n    lo = (lo + Math.imul(al1, bl2)) | 0;\n    mid = (mid + Math.imul(al1, bh2)) | 0;\n    mid = (mid + Math.imul(ah1, bl2)) | 0;\n    hi = (hi + Math.imul(ah1, bh2)) | 0;\n    lo = (lo + Math.imul(al0, bl3)) | 0;\n    mid = (mid + Math.imul(al0, bh3)) | 0;\n    mid = (mid + Math.imul(ah0, bl3)) | 0;\n    hi = (hi + Math.imul(ah0, bh3)) | 0;\n    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\n    w3 &= 0x3ffffff;\n    /* k = 4 */\n    lo = Math.imul(al4, bl0);\n    mid = Math.imul(al4, bh0);\n    mid = (mid + Math.imul(ah4, bl0)) | 0;\n    hi = Math.imul(ah4, bh0);\n    lo = (lo + Math.imul(al3, bl1)) | 0;\n    mid = (mid + Math.imul(al3, bh1)) | 0;\n    mid = (mid + Math.imul(ah3, bl1)) | 0;\n    hi = (hi + Math.imul(ah3, bh1)) | 0;\n    lo = (lo + Math.imul(al2, bl2)) | 0;\n    mid = (mid + Math.imul(al2, bh2)) | 0;\n    mid = (mid + Math.imul(ah2, bl2)) | 0;\n    hi = (hi + Math.imul(ah2, bh2)) | 0;\n    lo = (lo + Math.imul(al1, bl3)) | 0;\n    mid = (mid + Math.imul(al1, bh3)) | 0;\n    mid = (mid + Math.imul(ah1, bl3)) | 0;\n    hi = (hi + Math.imul(ah1, bh3)) | 0;\n    lo = (lo + Math.imul(al0, bl4)) | 0;\n    mid = (mid + Math.imul(al0, bh4)) | 0;\n    mid = (mid + Math.imul(ah0, bl4)) | 0;\n    hi = (hi + Math.imul(ah0, bh4)) | 0;\n    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\n    w4 &= 0x3ffffff;\n    /* k = 5 */\n    lo = Math.imul(al5, bl0);\n    mid = Math.imul(al5, bh0);\n    mid = (mid + Math.imul(ah5, bl0)) | 0;\n    hi = Math.imul(ah5, bh0);\n    lo = (lo + Math.imul(al4, bl1)) | 0;\n    mid = (mid + Math.imul(al4, bh1)) | 0;\n    mid = (mid + Math.imul(ah4, bl1)) | 0;\n    hi = (hi + Math.imul(ah4, bh1)) | 0;\n    lo = (lo + Math.imul(al3, bl2)) | 0;\n    mid = (mid + Math.imul(al3, bh2)) | 0;\n    mid = (mid + Math.imul(ah3, bl2)) | 0;\n    hi = (hi + Math.imul(ah3, bh2)) | 0;\n    lo = (lo + Math.imul(al2, bl3)) | 0;\n    mid = (mid + Math.imul(al2, bh3)) | 0;\n    mid = (mid + Math.imul(ah2, bl3)) | 0;\n    hi = (hi + Math.imul(ah2, bh3)) | 0;\n    lo = (lo + Math.imul(al1, bl4)) | 0;\n    mid = (mid + Math.imul(al1, bh4)) | 0;\n    mid = (mid + Math.imul(ah1, bl4)) | 0;\n    hi = (hi + Math.imul(ah1, bh4)) | 0;\n    lo = (lo + Math.imul(al0, bl5)) | 0;\n    mid = (mid + Math.imul(al0, bh5)) | 0;\n    mid = (mid + Math.imul(ah0, bl5)) | 0;\n    hi = (hi + Math.imul(ah0, bh5)) | 0;\n    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\n    w5 &= 0x3ffffff;\n    /* k = 6 */\n    lo = Math.imul(al6, bl0);\n    mid = Math.imul(al6, bh0);\n    mid = (mid + Math.imul(ah6, bl0)) | 0;\n    hi = Math.imul(ah6, bh0);\n    lo = (lo + Math.imul(al5, bl1)) | 0;\n    mid = (mid + Math.imul(al5, bh1)) | 0;\n    mid = (mid + Math.imul(ah5, bl1)) | 0;\n    hi = (hi + Math.imul(ah5, bh1)) | 0;\n    lo = (lo + Math.imul(al4, bl2)) | 0;\n    mid = (mid + Math.imul(al4, bh2)) | 0;\n    mid = (mid + Math.imul(ah4, bl2)) | 0;\n    hi = (hi + Math.imul(ah4, bh2)) | 0;\n    lo = (lo + Math.imul(al3, bl3)) | 0;\n    mid = (mid + Math.imul(al3, bh3)) | 0;\n    mid = (mid + Math.imul(ah3, bl3)) | 0;\n    hi = (hi + Math.imul(ah3, bh3)) | 0;\n    lo = (lo + Math.imul(al2, bl4)) | 0;\n    mid = (mid + Math.imul(al2, bh4)) | 0;\n    mid = (mid + Math.imul(ah2, bl4)) | 0;\n    hi = (hi + Math.imul(ah2, bh4)) | 0;\n    lo = (lo + Math.imul(al1, bl5)) | 0;\n    mid = (mid + Math.imul(al1, bh5)) | 0;\n    mid = (mid + Math.imul(ah1, bl5)) | 0;\n    hi = (hi + Math.imul(ah1, bh5)) | 0;\n    lo = (lo + Math.imul(al0, bl6)) | 0;\n    mid = (mid + Math.imul(al0, bh6)) | 0;\n    mid = (mid + Math.imul(ah0, bl6)) | 0;\n    hi = (hi + Math.imul(ah0, bh6)) | 0;\n    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\n    w6 &= 0x3ffffff;\n    /* k = 7 */\n    lo = Math.imul(al7, bl0);\n    mid = Math.imul(al7, bh0);\n    mid = (mid + Math.imul(ah7, bl0)) | 0;\n    hi = Math.imul(ah7, bh0);\n    lo = (lo + Math.imul(al6, bl1)) | 0;\n    mid = (mid + Math.imul(al6, bh1)) | 0;\n    mid = (mid + Math.imul(ah6, bl1)) | 0;\n    hi = (hi + Math.imul(ah6, bh1)) | 0;\n    lo = (lo + Math.imul(al5, bl2)) | 0;\n    mid = (mid + Math.imul(al5, bh2)) | 0;\n    mid = (mid + Math.imul(ah5, bl2)) | 0;\n    hi = (hi + Math.imul(ah5, bh2)) | 0;\n    lo = (lo + Math.imul(al4, bl3)) | 0;\n    mid = (mid + Math.imul(al4, bh3)) | 0;\n    mid = (mid + Math.imul(ah4, bl3)) | 0;\n    hi = (hi + Math.imul(ah4, bh3)) | 0;\n    lo = (lo + Math.imul(al3, bl4)) | 0;\n    mid = (mid + Math.imul(al3, bh4)) | 0;\n    mid = (mid + Math.imul(ah3, bl4)) | 0;\n    hi = (hi + Math.imul(ah3, bh4)) | 0;\n    lo = (lo + Math.imul(al2, bl5)) | 0;\n    mid = (mid + Math.imul(al2, bh5)) | 0;\n    mid = (mid + Math.imul(ah2, bl5)) | 0;\n    hi = (hi + Math.imul(ah2, bh5)) | 0;\n    lo = (lo + Math.imul(al1, bl6)) | 0;\n    mid = (mid + Math.imul(al1, bh6)) | 0;\n    mid = (mid + Math.imul(ah1, bl6)) | 0;\n    hi = (hi + Math.imul(ah1, bh6)) | 0;\n    lo = (lo + Math.imul(al0, bl7)) | 0;\n    mid = (mid + Math.imul(al0, bh7)) | 0;\n    mid = (mid + Math.imul(ah0, bl7)) | 0;\n    hi = (hi + Math.imul(ah0, bh7)) | 0;\n    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\n    w7 &= 0x3ffffff;\n    /* k = 8 */\n    lo = Math.imul(al8, bl0);\n    mid = Math.imul(al8, bh0);\n    mid = (mid + Math.imul(ah8, bl0)) | 0;\n    hi = Math.imul(ah8, bh0);\n    lo = (lo + Math.imul(al7, bl1)) | 0;\n    mid = (mid + Math.imul(al7, bh1)) | 0;\n    mid = (mid + Math.imul(ah7, bl1)) | 0;\n    hi = (hi + Math.imul(ah7, bh1)) | 0;\n    lo = (lo + Math.imul(al6, bl2)) | 0;\n    mid = (mid + Math.imul(al6, bh2)) | 0;\n    mid = (mid + Math.imul(ah6, bl2)) | 0;\n    hi = (hi + Math.imul(ah6, bh2)) | 0;\n    lo = (lo + Math.imul(al5, bl3)) | 0;\n    mid = (mid + Math.imul(al5, bh3)) | 0;\n    mid = (mid + Math.imul(ah5, bl3)) | 0;\n    hi = (hi + Math.imul(ah5, bh3)) | 0;\n    lo = (lo + Math.imul(al4, bl4)) | 0;\n    mid = (mid + Math.imul(al4, bh4)) | 0;\n    mid = (mid + Math.imul(ah4, bl4)) | 0;\n    hi = (hi + Math.imul(ah4, bh4)) | 0;\n    lo = (lo + Math.imul(al3, bl5)) | 0;\n    mid = (mid + Math.imul(al3, bh5)) | 0;\n    mid = (mid + Math.imul(ah3, bl5)) | 0;\n    hi = (hi + Math.imul(ah3, bh5)) | 0;\n    lo = (lo + Math.imul(al2, bl6)) | 0;\n    mid = (mid + Math.imul(al2, bh6)) | 0;\n    mid = (mid + Math.imul(ah2, bl6)) | 0;\n    hi = (hi + Math.imul(ah2, bh6)) | 0;\n    lo = (lo + Math.imul(al1, bl7)) | 0;\n    mid = (mid + Math.imul(al1, bh7)) | 0;\n    mid = (mid + Math.imul(ah1, bl7)) | 0;\n    hi = (hi + Math.imul(ah1, bh7)) | 0;\n    lo = (lo + Math.imul(al0, bl8)) | 0;\n    mid = (mid + Math.imul(al0, bh8)) | 0;\n    mid = (mid + Math.imul(ah0, bl8)) | 0;\n    hi = (hi + Math.imul(ah0, bh8)) | 0;\n    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\n    w8 &= 0x3ffffff;\n    /* k = 9 */\n    lo = Math.imul(al9, bl0);\n    mid = Math.imul(al9, bh0);\n    mid = (mid + Math.imul(ah9, bl0)) | 0;\n    hi = Math.imul(ah9, bh0);\n    lo = (lo + Math.imul(al8, bl1)) | 0;\n    mid = (mid + Math.imul(al8, bh1)) | 0;\n    mid = (mid + Math.imul(ah8, bl1)) | 0;\n    hi = (hi + Math.imul(ah8, bh1)) | 0;\n    lo = (lo + Math.imul(al7, bl2)) | 0;\n    mid = (mid + Math.imul(al7, bh2)) | 0;\n    mid = (mid + Math.imul(ah7, bl2)) | 0;\n    hi = (hi + Math.imul(ah7, bh2)) | 0;\n    lo = (lo + Math.imul(al6, bl3)) | 0;\n    mid = (mid + Math.imul(al6, bh3)) | 0;\n    mid = (mid + Math.imul(ah6, bl3)) | 0;\n    hi = (hi + Math.imul(ah6, bh3)) | 0;\n    lo = (lo + Math.imul(al5, bl4)) | 0;\n    mid = (mid + Math.imul(al5, bh4)) | 0;\n    mid = (mid + Math.imul(ah5, bl4)) | 0;\n    hi = (hi + Math.imul(ah5, bh4)) | 0;\n    lo = (lo + Math.imul(al4, bl5)) | 0;\n    mid = (mid + Math.imul(al4, bh5)) | 0;\n    mid = (mid + Math.imul(ah4, bl5)) | 0;\n    hi = (hi + Math.imul(ah4, bh5)) | 0;\n    lo = (lo + Math.imul(al3, bl6)) | 0;\n    mid = (mid + Math.imul(al3, bh6)) | 0;\n    mid = (mid + Math.imul(ah3, bl6)) | 0;\n    hi = (hi + Math.imul(ah3, bh6)) | 0;\n    lo = (lo + Math.imul(al2, bl7)) | 0;\n    mid = (mid + Math.imul(al2, bh7)) | 0;\n    mid = (mid + Math.imul(ah2, bl7)) | 0;\n    hi = (hi + Math.imul(ah2, bh7)) | 0;\n    lo = (lo + Math.imul(al1, bl8)) | 0;\n    mid = (mid + Math.imul(al1, bh8)) | 0;\n    mid = (mid + Math.imul(ah1, bl8)) | 0;\n    hi = (hi + Math.imul(ah1, bh8)) | 0;\n    lo = (lo + Math.imul(al0, bl9)) | 0;\n    mid = (mid + Math.imul(al0, bh9)) | 0;\n    mid = (mid + Math.imul(ah0, bl9)) | 0;\n    hi = (hi + Math.imul(ah0, bh9)) | 0;\n    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\n    w9 &= 0x3ffffff;\n    /* k = 10 */\n    lo = Math.imul(al9, bl1);\n    mid = Math.imul(al9, bh1);\n    mid = (mid + Math.imul(ah9, bl1)) | 0;\n    hi = Math.imul(ah9, bh1);\n    lo = (lo + Math.imul(al8, bl2)) | 0;\n    mid = (mid + Math.imul(al8, bh2)) | 0;\n    mid = (mid + Math.imul(ah8, bl2)) | 0;\n    hi = (hi + Math.imul(ah8, bh2)) | 0;\n    lo = (lo + Math.imul(al7, bl3)) | 0;\n    mid = (mid + Math.imul(al7, bh3)) | 0;\n    mid = (mid + Math.imul(ah7, bl3)) | 0;\n    hi = (hi + Math.imul(ah7, bh3)) | 0;\n    lo = (lo + Math.imul(al6, bl4)) | 0;\n    mid = (mid + Math.imul(al6, bh4)) | 0;\n    mid = (mid + Math.imul(ah6, bl4)) | 0;\n    hi = (hi + Math.imul(ah6, bh4)) | 0;\n    lo = (lo + Math.imul(al5, bl5)) | 0;\n    mid = (mid + Math.imul(al5, bh5)) | 0;\n    mid = (mid + Math.imul(ah5, bl5)) | 0;\n    hi = (hi + Math.imul(ah5, bh5)) | 0;\n    lo = (lo + Math.imul(al4, bl6)) | 0;\n    mid = (mid + Math.imul(al4, bh6)) | 0;\n    mid = (mid + Math.imul(ah4, bl6)) | 0;\n    hi = (hi + Math.imul(ah4, bh6)) | 0;\n    lo = (lo + Math.imul(al3, bl7)) | 0;\n    mid = (mid + Math.imul(al3, bh7)) | 0;\n    mid = (mid + Math.imul(ah3, bl7)) | 0;\n    hi = (hi + Math.imul(ah3, bh7)) | 0;\n    lo = (lo + Math.imul(al2, bl8)) | 0;\n    mid = (mid + Math.imul(al2, bh8)) | 0;\n    mid = (mid + Math.imul(ah2, bl8)) | 0;\n    hi = (hi + Math.imul(ah2, bh8)) | 0;\n    lo = (lo + Math.imul(al1, bl9)) | 0;\n    mid = (mid + Math.imul(al1, bh9)) | 0;\n    mid = (mid + Math.imul(ah1, bl9)) | 0;\n    hi = (hi + Math.imul(ah1, bh9)) | 0;\n    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\n    w10 &= 0x3ffffff;\n    /* k = 11 */\n    lo = Math.imul(al9, bl2);\n    mid = Math.imul(al9, bh2);\n    mid = (mid + Math.imul(ah9, bl2)) | 0;\n    hi = Math.imul(ah9, bh2);\n    lo = (lo + Math.imul(al8, bl3)) | 0;\n    mid = (mid + Math.imul(al8, bh3)) | 0;\n    mid = (mid + Math.imul(ah8, bl3)) | 0;\n    hi = (hi + Math.imul(ah8, bh3)) | 0;\n    lo = (lo + Math.imul(al7, bl4)) | 0;\n    mid = (mid + Math.imul(al7, bh4)) | 0;\n    mid = (mid + Math.imul(ah7, bl4)) | 0;\n    hi = (hi + Math.imul(ah7, bh4)) | 0;\n    lo = (lo + Math.imul(al6, bl5)) | 0;\n    mid = (mid + Math.imul(al6, bh5)) | 0;\n    mid = (mid + Math.imul(ah6, bl5)) | 0;\n    hi = (hi + Math.imul(ah6, bh5)) | 0;\n    lo = (lo + Math.imul(al5, bl6)) | 0;\n    mid = (mid + Math.imul(al5, bh6)) | 0;\n    mid = (mid + Math.imul(ah5, bl6)) | 0;\n    hi = (hi + Math.imul(ah5, bh6)) | 0;\n    lo = (lo + Math.imul(al4, bl7)) | 0;\n    mid = (mid + Math.imul(al4, bh7)) | 0;\n    mid = (mid + Math.imul(ah4, bl7)) | 0;\n    hi = (hi + Math.imul(ah4, bh7)) | 0;\n    lo = (lo + Math.imul(al3, bl8)) | 0;\n    mid = (mid + Math.imul(al3, bh8)) | 0;\n    mid = (mid + Math.imul(ah3, bl8)) | 0;\n    hi = (hi + Math.imul(ah3, bh8)) | 0;\n    lo = (lo + Math.imul(al2, bl9)) | 0;\n    mid = (mid + Math.imul(al2, bh9)) | 0;\n    mid = (mid + Math.imul(ah2, bl9)) | 0;\n    hi = (hi + Math.imul(ah2, bh9)) | 0;\n    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\n    w11 &= 0x3ffffff;\n    /* k = 12 */\n    lo = Math.imul(al9, bl3);\n    mid = Math.imul(al9, bh3);\n    mid = (mid + Math.imul(ah9, bl3)) | 0;\n    hi = Math.imul(ah9, bh3);\n    lo = (lo + Math.imul(al8, bl4)) | 0;\n    mid = (mid + Math.imul(al8, bh4)) | 0;\n    mid = (mid + Math.imul(ah8, bl4)) | 0;\n    hi = (hi + Math.imul(ah8, bh4)) | 0;\n    lo = (lo + Math.imul(al7, bl5)) | 0;\n    mid = (mid + Math.imul(al7, bh5)) | 0;\n    mid = (mid + Math.imul(ah7, bl5)) | 0;\n    hi = (hi + Math.imul(ah7, bh5)) | 0;\n    lo = (lo + Math.imul(al6, bl6)) | 0;\n    mid = (mid + Math.imul(al6, bh6)) | 0;\n    mid = (mid + Math.imul(ah6, bl6)) | 0;\n    hi = (hi + Math.imul(ah6, bh6)) | 0;\n    lo = (lo + Math.imul(al5, bl7)) | 0;\n    mid = (mid + Math.imul(al5, bh7)) | 0;\n    mid = (mid + Math.imul(ah5, bl7)) | 0;\n    hi = (hi + Math.imul(ah5, bh7)) | 0;\n    lo = (lo + Math.imul(al4, bl8)) | 0;\n    mid = (mid + Math.imul(al4, bh8)) | 0;\n    mid = (mid + Math.imul(ah4, bl8)) | 0;\n    hi = (hi + Math.imul(ah4, bh8)) | 0;\n    lo = (lo + Math.imul(al3, bl9)) | 0;\n    mid = (mid + Math.imul(al3, bh9)) | 0;\n    mid = (mid + Math.imul(ah3, bl9)) | 0;\n    hi = (hi + Math.imul(ah3, bh9)) | 0;\n    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\n    w12 &= 0x3ffffff;\n    /* k = 13 */\n    lo = Math.imul(al9, bl4);\n    mid = Math.imul(al9, bh4);\n    mid = (mid + Math.imul(ah9, bl4)) | 0;\n    hi = Math.imul(ah9, bh4);\n    lo = (lo + Math.imul(al8, bl5)) | 0;\n    mid = (mid + Math.imul(al8, bh5)) | 0;\n    mid = (mid + Math.imul(ah8, bl5)) | 0;\n    hi = (hi + Math.imul(ah8, bh5)) | 0;\n    lo = (lo + Math.imul(al7, bl6)) | 0;\n    mid = (mid + Math.imul(al7, bh6)) | 0;\n    mid = (mid + Math.imul(ah7, bl6)) | 0;\n    hi = (hi + Math.imul(ah7, bh6)) | 0;\n    lo = (lo + Math.imul(al6, bl7)) | 0;\n    mid = (mid + Math.imul(al6, bh7)) | 0;\n    mid = (mid + Math.imul(ah6, bl7)) | 0;\n    hi = (hi + Math.imul(ah6, bh7)) | 0;\n    lo = (lo + Math.imul(al5, bl8)) | 0;\n    mid = (mid + Math.imul(al5, bh8)) | 0;\n    mid = (mid + Math.imul(ah5, bl8)) | 0;\n    hi = (hi + Math.imul(ah5, bh8)) | 0;\n    lo = (lo + Math.imul(al4, bl9)) | 0;\n    mid = (mid + Math.imul(al4, bh9)) | 0;\n    mid = (mid + Math.imul(ah4, bl9)) | 0;\n    hi = (hi + Math.imul(ah4, bh9)) | 0;\n    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\n    w13 &= 0x3ffffff;\n    /* k = 14 */\n    lo = Math.imul(al9, bl5);\n    mid = Math.imul(al9, bh5);\n    mid = (mid + Math.imul(ah9, bl5)) | 0;\n    hi = Math.imul(ah9, bh5);\n    lo = (lo + Math.imul(al8, bl6)) | 0;\n    mid = (mid + Math.imul(al8, bh6)) | 0;\n    mid = (mid + Math.imul(ah8, bl6)) | 0;\n    hi = (hi + Math.imul(ah8, bh6)) | 0;\n    lo = (lo + Math.imul(al7, bl7)) | 0;\n    mid = (mid + Math.imul(al7, bh7)) | 0;\n    mid = (mid + Math.imul(ah7, bl7)) | 0;\n    hi = (hi + Math.imul(ah7, bh7)) | 0;\n    lo = (lo + Math.imul(al6, bl8)) | 0;\n    mid = (mid + Math.imul(al6, bh8)) | 0;\n    mid = (mid + Math.imul(ah6, bl8)) | 0;\n    hi = (hi + Math.imul(ah6, bh8)) | 0;\n    lo = (lo + Math.imul(al5, bl9)) | 0;\n    mid = (mid + Math.imul(al5, bh9)) | 0;\n    mid = (mid + Math.imul(ah5, bl9)) | 0;\n    hi = (hi + Math.imul(ah5, bh9)) | 0;\n    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\n    w14 &= 0x3ffffff;\n    /* k = 15 */\n    lo = Math.imul(al9, bl6);\n    mid = Math.imul(al9, bh6);\n    mid = (mid + Math.imul(ah9, bl6)) | 0;\n    hi = Math.imul(ah9, bh6);\n    lo = (lo + Math.imul(al8, bl7)) | 0;\n    mid = (mid + Math.imul(al8, bh7)) | 0;\n    mid = (mid + Math.imul(ah8, bl7)) | 0;\n    hi = (hi + Math.imul(ah8, bh7)) | 0;\n    lo = (lo + Math.imul(al7, bl8)) | 0;\n    mid = (mid + Math.imul(al7, bh8)) | 0;\n    mid = (mid + Math.imul(ah7, bl8)) | 0;\n    hi = (hi + Math.imul(ah7, bh8)) | 0;\n    lo = (lo + Math.imul(al6, bl9)) | 0;\n    mid = (mid + Math.imul(al6, bh9)) | 0;\n    mid = (mid + Math.imul(ah6, bl9)) | 0;\n    hi = (hi + Math.imul(ah6, bh9)) | 0;\n    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\n    w15 &= 0x3ffffff;\n    /* k = 16 */\n    lo = Math.imul(al9, bl7);\n    mid = Math.imul(al9, bh7);\n    mid = (mid + Math.imul(ah9, bl7)) | 0;\n    hi = Math.imul(ah9, bh7);\n    lo = (lo + Math.imul(al8, bl8)) | 0;\n    mid = (mid + Math.imul(al8, bh8)) | 0;\n    mid = (mid + Math.imul(ah8, bl8)) | 0;\n    hi = (hi + Math.imul(ah8, bh8)) | 0;\n    lo = (lo + Math.imul(al7, bl9)) | 0;\n    mid = (mid + Math.imul(al7, bh9)) | 0;\n    mid = (mid + Math.imul(ah7, bl9)) | 0;\n    hi = (hi + Math.imul(ah7, bh9)) | 0;\n    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\n    w16 &= 0x3ffffff;\n    /* k = 17 */\n    lo = Math.imul(al9, bl8);\n    mid = Math.imul(al9, bh8);\n    mid = (mid + Math.imul(ah9, bl8)) | 0;\n    hi = Math.imul(ah9, bh8);\n    lo = (lo + Math.imul(al8, bl9)) | 0;\n    mid = (mid + Math.imul(al8, bh9)) | 0;\n    mid = (mid + Math.imul(ah8, bl9)) | 0;\n    hi = (hi + Math.imul(ah8, bh9)) | 0;\n    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\n    w17 &= 0x3ffffff;\n    /* k = 18 */\n    lo = Math.imul(al9, bl9);\n    mid = Math.imul(al9, bh9);\n    mid = (mid + Math.imul(ah9, bl9)) | 0;\n    hi = Math.imul(ah9, bh9);\n    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\n    w18 &= 0x3ffffff;\n    o[0] = w0;\n    o[1] = w1;\n    o[2] = w2;\n    o[3] = w3;\n    o[4] = w4;\n    o[5] = w5;\n    o[6] = w6;\n    o[7] = w7;\n    o[8] = w8;\n    o[9] = w9;\n    o[10] = w10;\n    o[11] = w11;\n    o[12] = w12;\n    o[13] = w13;\n    o[14] = w14;\n    o[15] = w15;\n    o[16] = w16;\n    o[17] = w17;\n    o[18] = w18;\n    if (c !== 0) {\n      o[19] = c;\n      out.length++;\n    }\n    return out;\n  };\n\n  // Polyfill comb\n  if (!Math.imul) {\n    comb10MulTo = smallMulTo;\n  }\n\n  function bigMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    out.length = self.length + num.length;\n\n    var carry = 0;\n    var hncarry = 0;\n    for (var k = 0; k < out.length - 1; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = hncarry;\n      hncarry = 0;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = k - j;\n        var a = self.words[i] | 0;\n        var b = num.words[j] | 0;\n        var r = a * b;\n\n        var lo = r & 0x3ffffff;\n        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n        lo = (lo + rword) | 0;\n        rword = lo & 0x3ffffff;\n        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n        hncarry += ncarry >>> 26;\n        ncarry &= 0x3ffffff;\n      }\n      out.words[k] = rword;\n      carry = ncarry;\n      ncarry = hncarry;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  }\n\n  function jumboMulTo (self, num, out) {\n    // Temporary disable, see https://github.com/indutny/bn.js/issues/211\n    // var fftm = new FFTM();\n    // return fftm.mulp(self, num, out);\n    return bigMulTo(self, num, out);\n  }\n\n  BN.prototype.mulTo = function mulTo (num, out) {\n    var res;\n    var len = this.length + num.length;\n    if (this.length === 10 && num.length === 10) {\n      res = comb10MulTo(this, num, out);\n    } else if (len < 63) {\n      res = smallMulTo(this, num, out);\n    } else if (len < 1024) {\n      res = bigMulTo(this, num, out);\n    } else {\n      res = jumboMulTo(this, num, out);\n    }\n\n    return res;\n  };\n\n  // Cooley-Tukey algorithm for FFT\n  // slightly revisited to rely on looping instead of recursion\n\n  function FFTM (x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  FFTM.prototype.makeRBT = function makeRBT (N) {\n    var t = new Array(N);\n    var l = BN.prototype._countBits(N) - 1;\n    for (var i = 0; i < N; i++) {\n      t[i] = this.revBin(i, l, N);\n    }\n\n    return t;\n  };\n\n  // Returns binary-reversed representation of `x`\n  FFTM.prototype.revBin = function revBin (x, l, N) {\n    if (x === 0 || x === N - 1) return x;\n\n    var rb = 0;\n    for (var i = 0; i < l; i++) {\n      rb |= (x & 1) << (l - i - 1);\n      x >>= 1;\n    }\n\n    return rb;\n  };\n\n  // Performs \"tweedling\" phase, therefore 'emulating'\n  // behaviour of the recursive algorithm\n  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n    for (var i = 0; i < N; i++) {\n      rtws[i] = rws[rbt[i]];\n      itws[i] = iws[rbt[i]];\n    }\n  };\n\n  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n    this.permute(rbt, rws, iws, rtws, itws, N);\n\n    for (var s = 1; s < N; s <<= 1) {\n      var l = s << 1;\n\n      var rtwdf = Math.cos(2 * Math.PI / l);\n      var itwdf = Math.sin(2 * Math.PI / l);\n\n      for (var p = 0; p < N; p += l) {\n        var rtwdf_ = rtwdf;\n        var itwdf_ = itwdf;\n\n        for (var j = 0; j < s; j++) {\n          var re = rtws[p + j];\n          var ie = itws[p + j];\n\n          var ro = rtws[p + j + s];\n          var io = itws[p + j + s];\n\n          var rx = rtwdf_ * ro - itwdf_ * io;\n\n          io = rtwdf_ * io + itwdf_ * ro;\n          ro = rx;\n\n          rtws[p + j] = re + ro;\n          itws[p + j] = ie + io;\n\n          rtws[p + j + s] = re - ro;\n          itws[p + j + s] = ie - io;\n\n          /* jshint maxdepth : false */\n          if (j !== l) {\n            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n            rtwdf_ = rx;\n          }\n        }\n      }\n    }\n  };\n\n  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n    var N = Math.max(m, n) | 1;\n    var odd = N & 1;\n    var i = 0;\n    for (N = N / 2 | 0; N; N = N >>> 1) {\n      i++;\n    }\n\n    return 1 << i + 1 + odd;\n  };\n\n  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n    if (N <= 1) return;\n\n    for (var i = 0; i < N / 2; i++) {\n      var t = rws[i];\n\n      rws[i] = rws[N - i - 1];\n      rws[N - i - 1] = t;\n\n      t = iws[i];\n\n      iws[i] = -iws[N - i - 1];\n      iws[N - i - 1] = -t;\n    }\n  };\n\n  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n    var carry = 0;\n    for (var i = 0; i < N / 2; i++) {\n      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n        Math.round(ws[2 * i] / N) +\n        carry;\n\n      ws[i] = w & 0x3ffffff;\n\n      if (w < 0x4000000) {\n        carry = 0;\n      } else {\n        carry = w / 0x4000000 | 0;\n      }\n    }\n\n    return ws;\n  };\n\n  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n    var carry = 0;\n    for (var i = 0; i < len; i++) {\n      carry = carry + (ws[i] | 0);\n\n      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n    }\n\n    // Pad with zeroes\n    for (i = 2 * len; i < N; ++i) {\n      rws[i] = 0;\n    }\n\n    assert(carry === 0);\n    assert((carry & ~0x1fff) === 0);\n  };\n\n  FFTM.prototype.stub = function stub (N) {\n    var ph = new Array(N);\n    for (var i = 0; i < N; i++) {\n      ph[i] = 0;\n    }\n\n    return ph;\n  };\n\n  FFTM.prototype.mulp = function mulp (x, y, out) {\n    var N = 2 * this.guessLen13b(x.length, y.length);\n\n    var rbt = this.makeRBT(N);\n\n    var _ = this.stub(N);\n\n    var rws = new Array(N);\n    var rwst = new Array(N);\n    var iwst = new Array(N);\n\n    var nrws = new Array(N);\n    var nrwst = new Array(N);\n    var niwst = new Array(N);\n\n    var rmws = out.words;\n    rmws.length = N;\n\n    this.convert13b(x.words, x.length, rws, N);\n    this.convert13b(y.words, y.length, nrws, N);\n\n    this.transform(rws, _, rwst, iwst, N, rbt);\n    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n    for (var i = 0; i < N; i++) {\n      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n      rwst[i] = rx;\n    }\n\n    this.conjugate(rwst, iwst, N);\n    this.transform(rwst, iwst, rmws, _, N, rbt);\n    this.conjugate(rmws, _, N);\n    this.normalize13b(rmws, N);\n\n    out.negative = x.negative ^ y.negative;\n    out.length = x.length + y.length;\n    return out._strip();\n  };\n\n  // Multiply `this` by `num`\n  BN.prototype.mul = function mul (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return this.mulTo(num, out);\n  };\n\n  // Multiply employing FFT\n  BN.prototype.mulf = function mulf (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return jumboMulTo(this, num, out);\n  };\n\n  // In-place Multiplication\n  BN.prototype.imul = function imul (num) {\n    return this.clone().mulTo(num, this);\n  };\n\n  BN.prototype.imuln = function imuln (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n\n    // Carry\n    var carry = 0;\n    for (var i = 0; i < this.length; i++) {\n      var w = (this.words[i] | 0) * num;\n      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n      carry >>= 26;\n      carry += (w / 0x4000000) | 0;\n      // NOTE: lo is 27bit maximum\n      carry += lo >>> 26;\n      this.words[i] = lo & 0x3ffffff;\n    }\n\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.muln = function muln (num) {\n    return this.clone().imuln(num);\n  };\n\n  // `this` * `this`\n  BN.prototype.sqr = function sqr () {\n    return this.mul(this);\n  };\n\n  // `this` * `this` in-place\n  BN.prototype.isqr = function isqr () {\n    return this.imul(this.clone());\n  };\n\n  // Math.pow(`this`, `num`)\n  BN.prototype.pow = function pow (num) {\n    var w = toBitArray(num);\n    if (w.length === 0) return new BN(1);\n\n    // Skip leading zeroes\n    var res = this;\n    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n      if (w[i] !== 0) break;\n    }\n\n    if (++i < w.length) {\n      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n        if (w[i] === 0) continue;\n\n        res = res.mul(q);\n      }\n    }\n\n    return res;\n  };\n\n  // Shift-left in-place\n  BN.prototype.iushln = function iushln (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n    var i;\n\n    if (r !== 0) {\n      var carry = 0;\n\n      for (i = 0; i < this.length; i++) {\n        var newCarry = this.words[i] & carryMask;\n        var c = ((this.words[i] | 0) - newCarry) << r;\n        this.words[i] = c | carry;\n        carry = newCarry >>> (26 - r);\n      }\n\n      if (carry) {\n        this.words[i] = carry;\n        this.length++;\n      }\n    }\n\n    if (s !== 0) {\n      for (i = this.length - 1; i >= 0; i--) {\n        this.words[i + s] = this.words[i];\n      }\n\n      for (i = 0; i < s; i++) {\n        this.words[i] = 0;\n      }\n\n      this.length += s;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishln = function ishln (bits) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushln(bits);\n  };\n\n  // Shift-right in-place\n  // NOTE: `hint` is a lowest bit before trailing zeroes\n  // NOTE: if `extended` is present - it will be filled with destroyed bits\n  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var h;\n    if (hint) {\n      h = (hint - (hint % 26)) / 26;\n    } else {\n      h = 0;\n    }\n\n    var r = bits % 26;\n    var s = Math.min((bits - r) / 26, this.length);\n    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n    var maskedWords = extended;\n\n    h -= s;\n    h = Math.max(0, h);\n\n    // Extended mode, copy masked part\n    if (maskedWords) {\n      for (var i = 0; i < s; i++) {\n        maskedWords.words[i] = this.words[i];\n      }\n      maskedWords.length = s;\n    }\n\n    if (s === 0) {\n      // No-op, we should not move anything at all\n    } else if (this.length > s) {\n      this.length -= s;\n      for (i = 0; i < this.length; i++) {\n        this.words[i] = this.words[i + s];\n      }\n    } else {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    var carry = 0;\n    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n      var word = this.words[i] | 0;\n      this.words[i] = (carry << (26 - r)) | (word >>> r);\n      carry = word & mask;\n    }\n\n    // Push carried bits as a mask\n    if (maskedWords && carry !== 0) {\n      maskedWords.words[maskedWords.length++] = carry;\n    }\n\n    if (this.length === 0) {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushrn(bits, hint, extended);\n  };\n\n  // Shift-left\n  BN.prototype.shln = function shln (bits) {\n    return this.clone().ishln(bits);\n  };\n\n  BN.prototype.ushln = function ushln (bits) {\n    return this.clone().iushln(bits);\n  };\n\n  // Shift-right\n  BN.prototype.shrn = function shrn (bits) {\n    return this.clone().ishrn(bits);\n  };\n\n  BN.prototype.ushrn = function ushrn (bits) {\n    return this.clone().iushrn(bits);\n  };\n\n  // Test if n bit is set\n  BN.prototype.testn = function testn (bit) {\n    assert(typeof bit === 'number' && bit >= 0);\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) return false;\n\n    // Check bit and return\n    var w = this.words[s];\n\n    return !!(w & q);\n  };\n\n  // Return only lowers bits of number (in-place)\n  BN.prototype.imaskn = function imaskn (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n\n    assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n    if (this.length <= s) {\n      return this;\n    }\n\n    if (r !== 0) {\n      s++;\n    }\n    this.length = Math.min(s, this.length);\n\n    if (r !== 0) {\n      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n      this.words[this.length - 1] &= mask;\n    }\n\n    return this._strip();\n  };\n\n  // Return only lowers bits of number\n  BN.prototype.maskn = function maskn (bits) {\n    return this.clone().imaskn(bits);\n  };\n\n  // Add plain number `num` to `this`\n  BN.prototype.iaddn = function iaddn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.isubn(-num);\n\n    // Possible sign change\n    if (this.negative !== 0) {\n      if (this.length === 1 && (this.words[0] | 0) <= num) {\n        this.words[0] = num - (this.words[0] | 0);\n        this.negative = 0;\n        return this;\n      }\n\n      this.negative = 0;\n      this.isubn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    // Add without checks\n    return this._iaddn(num);\n  };\n\n  BN.prototype._iaddn = function _iaddn (num) {\n    this.words[0] += num;\n\n    // Carry\n    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n      this.words[i] -= 0x4000000;\n      if (i === this.length - 1) {\n        this.words[i + 1] = 1;\n      } else {\n        this.words[i + 1]++;\n      }\n    }\n    this.length = Math.max(this.length, i + 1);\n\n    return this;\n  };\n\n  // Subtract plain number `num` from `this`\n  BN.prototype.isubn = function isubn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.iaddn(-num);\n\n    if (this.negative !== 0) {\n      this.negative = 0;\n      this.iaddn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    this.words[0] -= num;\n\n    if (this.length === 1 && this.words[0] < 0) {\n      this.words[0] = -this.words[0];\n      this.negative = 1;\n    } else {\n      // Carry\n      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n        this.words[i] += 0x4000000;\n        this.words[i + 1] -= 1;\n      }\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.addn = function addn (num) {\n    return this.clone().iaddn(num);\n  };\n\n  BN.prototype.subn = function subn (num) {\n    return this.clone().isubn(num);\n  };\n\n  BN.prototype.iabs = function iabs () {\n    this.negative = 0;\n\n    return this;\n  };\n\n  BN.prototype.abs = function abs () {\n    return this.clone().iabs();\n  };\n\n  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n    var len = num.length + shift;\n    var i;\n\n    this._expand(len);\n\n    var w;\n    var carry = 0;\n    for (i = 0; i < num.length; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      var right = (num.words[i] | 0) * mul;\n      w -= right & 0x3ffffff;\n      carry = (w >> 26) - ((right / 0x4000000) | 0);\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n    for (; i < this.length - shift; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      carry = w >> 26;\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    if (carry === 0) return this._strip();\n\n    // Subtraction overflow\n    assert(carry === -1);\n    carry = 0;\n    for (i = 0; i < this.length; i++) {\n      w = -(this.words[i] | 0) + carry;\n      carry = w >> 26;\n      this.words[i] = w & 0x3ffffff;\n    }\n    this.negative = 1;\n\n    return this._strip();\n  };\n\n  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n    var shift = this.length - num.length;\n\n    var a = this.clone();\n    var b = num;\n\n    // Normalize\n    var bhi = b.words[b.length - 1] | 0;\n    var bhiBits = this._countBits(bhi);\n    shift = 26 - bhiBits;\n    if (shift !== 0) {\n      b = b.ushln(shift);\n      a.iushln(shift);\n      bhi = b.words[b.length - 1] | 0;\n    }\n\n    // Initialize quotient\n    var m = a.length - b.length;\n    var q;\n\n    if (mode !== 'mod') {\n      q = new BN(null);\n      q.length = m + 1;\n      q.words = new Array(q.length);\n      for (var i = 0; i < q.length; i++) {\n        q.words[i] = 0;\n      }\n    }\n\n    var diff = a.clone()._ishlnsubmul(b, 1, m);\n    if (diff.negative === 0) {\n      a = diff;\n      if (q) {\n        q.words[m] = 1;\n      }\n    }\n\n    for (var j = m - 1; j >= 0; j--) {\n      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n        (a.words[b.length + j - 1] | 0);\n\n      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n      // (0x7ffffff)\n      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n      a._ishlnsubmul(b, qj, j);\n      while (a.negative !== 0) {\n        qj--;\n        a.negative = 0;\n        a._ishlnsubmul(b, 1, j);\n        if (!a.isZero()) {\n          a.negative ^= 1;\n        }\n      }\n      if (q) {\n        q.words[j] = qj;\n      }\n    }\n    if (q) {\n      q._strip();\n    }\n    a._strip();\n\n    // Denormalize\n    if (mode !== 'div' && shift !== 0) {\n      a.iushrn(shift);\n    }\n\n    return {\n      div: q || null,\n      mod: a\n    };\n  };\n\n  // NOTE: 1) `mode` can be set to `mod` to request mod only,\n  //       to `div` to request div only, or be absent to\n  //       request both div & mod\n  //       2) `positive` is true if unsigned mod is requested\n  BN.prototype.divmod = function divmod (num, mode, positive) {\n    assert(!num.isZero());\n\n    if (this.isZero()) {\n      return {\n        div: new BN(0),\n        mod: new BN(0)\n      };\n    }\n\n    var div, mod, res;\n    if (this.negative !== 0 && num.negative === 0) {\n      res = this.neg().divmod(num, mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.iadd(num);\n        }\n      }\n\n      return {\n        div: div,\n        mod: mod\n      };\n    }\n\n    if (this.negative === 0 && num.negative !== 0) {\n      res = this.divmod(num.neg(), mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      return {\n        div: div,\n        mod: res.mod\n      };\n    }\n\n    if ((this.negative & num.negative) !== 0) {\n      res = this.neg().divmod(num.neg(), mode);\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.isub(num);\n        }\n      }\n\n      return {\n        div: res.div,\n        mod: mod\n      };\n    }\n\n    // Both numbers are positive at this point\n\n    // Strip both numbers to approximate shift value\n    if (num.length > this.length || this.cmp(num) < 0) {\n      return {\n        div: new BN(0),\n        mod: this\n      };\n    }\n\n    // Very short reduction\n    if (num.length === 1) {\n      if (mode === 'div') {\n        return {\n          div: this.divn(num.words[0]),\n          mod: null\n        };\n      }\n\n      if (mode === 'mod') {\n        return {\n          div: null,\n          mod: new BN(this.modrn(num.words[0]))\n        };\n      }\n\n      return {\n        div: this.divn(num.words[0]),\n        mod: new BN(this.modrn(num.words[0]))\n      };\n    }\n\n    return this._wordDiv(num, mode);\n  };\n\n  // Find `this` / `num`\n  BN.prototype.div = function div (num) {\n    return this.divmod(num, 'div', false).div;\n  };\n\n  // Find `this` % `num`\n  BN.prototype.mod = function mod (num) {\n    return this.divmod(num, 'mod', false).mod;\n  };\n\n  BN.prototype.umod = function umod (num) {\n    return this.divmod(num, 'mod', true).mod;\n  };\n\n  // Find Round(`this` / `num`)\n  BN.prototype.divRound = function divRound (num) {\n    var dm = this.divmod(num);\n\n    // Fast case - exact division\n    if (dm.mod.isZero()) return dm.div;\n\n    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n    var half = num.ushrn(1);\n    var r2 = num.andln(1);\n    var cmp = mod.cmp(half);\n\n    // Round down\n    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;\n\n    // Round up\n    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n  };\n\n  BN.prototype.modrn = function modrn (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(num <= 0x3ffffff);\n    var p = (1 << 26) % num;\n\n    var acc = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      acc = (p * acc + (this.words[i] | 0)) % num;\n    }\n\n    return isNegNum ? -acc : acc;\n  };\n\n  // WARNING: DEPRECATED\n  BN.prototype.modn = function modn (num) {\n    return this.modrn(num);\n  };\n\n  // In-place division by number\n  BN.prototype.idivn = function idivn (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(num <= 0x3ffffff);\n\n    var carry = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var w = (this.words[i] | 0) + carry * 0x4000000;\n      this.words[i] = (w / num) | 0;\n      carry = w % num;\n    }\n\n    this._strip();\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.divn = function divn (num) {\n    return this.clone().idivn(num);\n  };\n\n  BN.prototype.egcd = function egcd (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var x = this;\n    var y = p.clone();\n\n    if (x.negative !== 0) {\n      x = x.umod(p);\n    } else {\n      x = x.clone();\n    }\n\n    // A * x + B * y = x\n    var A = new BN(1);\n    var B = new BN(0);\n\n    // C * x + D * y = y\n    var C = new BN(0);\n    var D = new BN(1);\n\n    var g = 0;\n\n    while (x.isEven() && y.isEven()) {\n      x.iushrn(1);\n      y.iushrn(1);\n      ++g;\n    }\n\n    var yp = y.clone();\n    var xp = x.clone();\n\n    while (!x.isZero()) {\n      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        x.iushrn(i);\n        while (i-- > 0) {\n          if (A.isOdd() || B.isOdd()) {\n            A.iadd(yp);\n            B.isub(xp);\n          }\n\n          A.iushrn(1);\n          B.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        y.iushrn(j);\n        while (j-- > 0) {\n          if (C.isOdd() || D.isOdd()) {\n            C.iadd(yp);\n            D.isub(xp);\n          }\n\n          C.iushrn(1);\n          D.iushrn(1);\n        }\n      }\n\n      if (x.cmp(y) >= 0) {\n        x.isub(y);\n        A.isub(C);\n        B.isub(D);\n      } else {\n        y.isub(x);\n        C.isub(A);\n        D.isub(B);\n      }\n    }\n\n    return {\n      a: C,\n      b: D,\n      gcd: y.iushln(g)\n    };\n  };\n\n  // This is reduced incarnation of the binary EEA\n  // above, designated to invert members of the\n  // _prime_ fields F(p) at a maximal speed\n  BN.prototype._invmp = function _invmp (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var a = this;\n    var b = p.clone();\n\n    if (a.negative !== 0) {\n      a = a.umod(p);\n    } else {\n      a = a.clone();\n    }\n\n    var x1 = new BN(1);\n    var x2 = new BN(0);\n\n    var delta = b.clone();\n\n    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        a.iushrn(i);\n        while (i-- > 0) {\n          if (x1.isOdd()) {\n            x1.iadd(delta);\n          }\n\n          x1.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        b.iushrn(j);\n        while (j-- > 0) {\n          if (x2.isOdd()) {\n            x2.iadd(delta);\n          }\n\n          x2.iushrn(1);\n        }\n      }\n\n      if (a.cmp(b) >= 0) {\n        a.isub(b);\n        x1.isub(x2);\n      } else {\n        b.isub(a);\n        x2.isub(x1);\n      }\n    }\n\n    var res;\n    if (a.cmpn(1) === 0) {\n      res = x1;\n    } else {\n      res = x2;\n    }\n\n    if (res.cmpn(0) < 0) {\n      res.iadd(p);\n    }\n\n    return res;\n  };\n\n  BN.prototype.gcd = function gcd (num) {\n    if (this.isZero()) return num.abs();\n    if (num.isZero()) return this.abs();\n\n    var a = this.clone();\n    var b = num.clone();\n    a.negative = 0;\n    b.negative = 0;\n\n    // Remove common factor of two\n    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n      a.iushrn(1);\n      b.iushrn(1);\n    }\n\n    do {\n      while (a.isEven()) {\n        a.iushrn(1);\n      }\n      while (b.isEven()) {\n        b.iushrn(1);\n      }\n\n      var r = a.cmp(b);\n      if (r < 0) {\n        // Swap `a` and `b` to make `a` always bigger than `b`\n        var t = a;\n        a = b;\n        b = t;\n      } else if (r === 0 || b.cmpn(1) === 0) {\n        break;\n      }\n\n      a.isub(b);\n    } while (true);\n\n    return b.iushln(shift);\n  };\n\n  // Invert number in the field F(num)\n  BN.prototype.invm = function invm (num) {\n    return this.egcd(num).a.umod(num);\n  };\n\n  BN.prototype.isEven = function isEven () {\n    return (this.words[0] & 1) === 0;\n  };\n\n  BN.prototype.isOdd = function isOdd () {\n    return (this.words[0] & 1) === 1;\n  };\n\n  // And first word and num\n  BN.prototype.andln = function andln (num) {\n    return this.words[0] & num;\n  };\n\n  // Increment at the bit position in-line\n  BN.prototype.bincn = function bincn (bit) {\n    assert(typeof bit === 'number');\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) {\n      this._expand(s + 1);\n      this.words[s] |= q;\n      return this;\n    }\n\n    // Add bit and propagate, if needed\n    var carry = q;\n    for (var i = s; carry !== 0 && i < this.length; i++) {\n      var w = this.words[i] | 0;\n      w += carry;\n      carry = w >>> 26;\n      w &= 0x3ffffff;\n      this.words[i] = w;\n    }\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n    return this;\n  };\n\n  BN.prototype.isZero = function isZero () {\n    return this.length === 1 && this.words[0] === 0;\n  };\n\n  BN.prototype.cmpn = function cmpn (num) {\n    var negative = num < 0;\n\n    if (this.negative !== 0 && !negative) return -1;\n    if (this.negative === 0 && negative) return 1;\n\n    this._strip();\n\n    var res;\n    if (this.length > 1) {\n      res = 1;\n    } else {\n      if (negative) {\n        num = -num;\n      }\n\n      assert(num <= 0x3ffffff, 'Number is too big');\n\n      var w = this.words[0] | 0;\n      res = w === num ? 0 : w < num ? -1 : 1;\n    }\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Compare two numbers and return:\n  // 1 - if `this` > `num`\n  // 0 - if `this` == `num`\n  // -1 - if `this` < `num`\n  BN.prototype.cmp = function cmp (num) {\n    if (this.negative !== 0 && num.negative === 0) return -1;\n    if (this.negative === 0 && num.negative !== 0) return 1;\n\n    var res = this.ucmp(num);\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Unsigned comparison\n  BN.prototype.ucmp = function ucmp (num) {\n    // At this point both numbers have the same sign\n    if (this.length > num.length) return 1;\n    if (this.length < num.length) return -1;\n\n    var res = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var a = this.words[i] | 0;\n      var b = num.words[i] | 0;\n\n      if (a === b) continue;\n      if (a < b) {\n        res = -1;\n      } else if (a > b) {\n        res = 1;\n      }\n      break;\n    }\n    return res;\n  };\n\n  BN.prototype.gtn = function gtn (num) {\n    return this.cmpn(num) === 1;\n  };\n\n  BN.prototype.gt = function gt (num) {\n    return this.cmp(num) === 1;\n  };\n\n  BN.prototype.gten = function gten (num) {\n    return this.cmpn(num) >= 0;\n  };\n\n  BN.prototype.gte = function gte (num) {\n    return this.cmp(num) >= 0;\n  };\n\n  BN.prototype.ltn = function ltn (num) {\n    return this.cmpn(num) === -1;\n  };\n\n  BN.prototype.lt = function lt (num) {\n    return this.cmp(num) === -1;\n  };\n\n  BN.prototype.lten = function lten (num) {\n    return this.cmpn(num) <= 0;\n  };\n\n  BN.prototype.lte = function lte (num) {\n    return this.cmp(num) <= 0;\n  };\n\n  BN.prototype.eqn = function eqn (num) {\n    return this.cmpn(num) === 0;\n  };\n\n  BN.prototype.eq = function eq (num) {\n    return this.cmp(num) === 0;\n  };\n\n  //\n  // A reduce context, could be using montgomery or something better, depending\n  // on the `m` itself.\n  //\n  BN.red = function red (num) {\n    return new Red(num);\n  };\n\n  BN.prototype.toRed = function toRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    assert(this.negative === 0, 'red works only with positives');\n    return ctx.convertTo(this)._forceRed(ctx);\n  };\n\n  BN.prototype.fromRed = function fromRed () {\n    assert(this.red, 'fromRed works only with numbers in reduction context');\n    return this.red.convertFrom(this);\n  };\n\n  BN.prototype._forceRed = function _forceRed (ctx) {\n    this.red = ctx;\n    return this;\n  };\n\n  BN.prototype.forceRed = function forceRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    return this._forceRed(ctx);\n  };\n\n  BN.prototype.redAdd = function redAdd (num) {\n    assert(this.red, 'redAdd works only with red numbers');\n    return this.red.add(this, num);\n  };\n\n  BN.prototype.redIAdd = function redIAdd (num) {\n    assert(this.red, 'redIAdd works only with red numbers');\n    return this.red.iadd(this, num);\n  };\n\n  BN.prototype.redSub = function redSub (num) {\n    assert(this.red, 'redSub works only with red numbers');\n    return this.red.sub(this, num);\n  };\n\n  BN.prototype.redISub = function redISub (num) {\n    assert(this.red, 'redISub works only with red numbers');\n    return this.red.isub(this, num);\n  };\n\n  BN.prototype.redShl = function redShl (num) {\n    assert(this.red, 'redShl works only with red numbers');\n    return this.red.shl(this, num);\n  };\n\n  BN.prototype.redMul = function redMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.mul(this, num);\n  };\n\n  BN.prototype.redIMul = function redIMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.imul(this, num);\n  };\n\n  BN.prototype.redSqr = function redSqr () {\n    assert(this.red, 'redSqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqr(this);\n  };\n\n  BN.prototype.redISqr = function redISqr () {\n    assert(this.red, 'redISqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.isqr(this);\n  };\n\n  // Square root over p\n  BN.prototype.redSqrt = function redSqrt () {\n    assert(this.red, 'redSqrt works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqrt(this);\n  };\n\n  BN.prototype.redInvm = function redInvm () {\n    assert(this.red, 'redInvm works only with red numbers');\n    this.red._verify1(this);\n    return this.red.invm(this);\n  };\n\n  // Return negative clone of `this` % `red modulo`\n  BN.prototype.redNeg = function redNeg () {\n    assert(this.red, 'redNeg works only with red numbers');\n    this.red._verify1(this);\n    return this.red.neg(this);\n  };\n\n  BN.prototype.redPow = function redPow (num) {\n    assert(this.red && !num.red, 'redPow(normalNum)');\n    this.red._verify1(this);\n    return this.red.pow(this, num);\n  };\n\n  // Prime numbers with efficient reduction\n  var primes = {\n    k256: null,\n    p224: null,\n    p192: null,\n    p25519: null\n  };\n\n  // Pseudo-Mersenne prime\n  function MPrime (name, p) {\n    // P = 2 ^ N - K\n    this.name = name;\n    this.p = new BN(p, 16);\n    this.n = this.p.bitLength();\n    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n    this.tmp = this._tmp();\n  }\n\n  MPrime.prototype._tmp = function _tmp () {\n    var tmp = new BN(null);\n    tmp.words = new Array(Math.ceil(this.n / 13));\n    return tmp;\n  };\n\n  MPrime.prototype.ireduce = function ireduce (num) {\n    // Assumes that `num` is less than `P^2`\n    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n    var r = num;\n    var rlen;\n\n    do {\n      this.split(r, this.tmp);\n      r = this.imulK(r);\n      r = r.iadd(this.tmp);\n      rlen = r.bitLength();\n    } while (rlen > this.n);\n\n    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n    if (cmp === 0) {\n      r.words[0] = 0;\n      r.length = 1;\n    } else if (cmp > 0) {\n      r.isub(this.p);\n    } else {\n      if (r.strip !== undefined) {\n        // r is a BN v4 instance\n        r.strip();\n      } else {\n        // r is a BN v5 instance\n        r._strip();\n      }\n    }\n\n    return r;\n  };\n\n  MPrime.prototype.split = function split (input, out) {\n    input.iushrn(this.n, 0, out);\n  };\n\n  MPrime.prototype.imulK = function imulK (num) {\n    return num.imul(this.k);\n  };\n\n  function K256 () {\n    MPrime.call(\n      this,\n      'k256',\n      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n  }\n  inherits(K256, MPrime);\n\n  K256.prototype.split = function split (input, output) {\n    // 256 = 9 * 26 + 22\n    var mask = 0x3fffff;\n\n    var outLen = Math.min(input.length, 9);\n    for (var i = 0; i < outLen; i++) {\n      output.words[i] = input.words[i];\n    }\n    output.length = outLen;\n\n    if (input.length <= 9) {\n      input.words[0] = 0;\n      input.length = 1;\n      return;\n    }\n\n    // Shift by 9 limbs\n    var prev = input.words[9];\n    output.words[output.length++] = prev & mask;\n\n    for (i = 10; i < input.length; i++) {\n      var next = input.words[i] | 0;\n      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n      prev = next;\n    }\n    prev >>>= 22;\n    input.words[i - 10] = prev;\n    if (prev === 0 && input.length > 10) {\n      input.length -= 10;\n    } else {\n      input.length -= 9;\n    }\n  };\n\n  K256.prototype.imulK = function imulK (num) {\n    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n    num.words[num.length] = 0;\n    num.words[num.length + 1] = 0;\n    num.length += 2;\n\n    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n    var lo = 0;\n    for (var i = 0; i < num.length; i++) {\n      var w = num.words[i] | 0;\n      lo += w * 0x3d1;\n      num.words[i] = lo & 0x3ffffff;\n      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n    }\n\n    // Fast length reduction\n    if (num.words[num.length - 1] === 0) {\n      num.length--;\n      if (num.words[num.length - 1] === 0) {\n        num.length--;\n      }\n    }\n    return num;\n  };\n\n  function P224 () {\n    MPrime.call(\n      this,\n      'p224',\n      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n  }\n  inherits(P224, MPrime);\n\n  function P192 () {\n    MPrime.call(\n      this,\n      'p192',\n      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n  }\n  inherits(P192, MPrime);\n\n  function P25519 () {\n    // 2 ^ 255 - 19\n    MPrime.call(\n      this,\n      '25519',\n      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n  }\n  inherits(P25519, MPrime);\n\n  P25519.prototype.imulK = function imulK (num) {\n    // K = 0x13\n    var carry = 0;\n    for (var i = 0; i < num.length; i++) {\n      var hi = (num.words[i] | 0) * 0x13 + carry;\n      var lo = hi & 0x3ffffff;\n      hi >>>= 26;\n\n      num.words[i] = lo;\n      carry = hi;\n    }\n    if (carry !== 0) {\n      num.words[num.length++] = carry;\n    }\n    return num;\n  };\n\n  // Exported mostly for testing purposes, use plain name instead\n  BN._prime = function prime (name) {\n    // Cached version of prime\n    if (primes[name]) return primes[name];\n\n    var prime;\n    if (name === 'k256') {\n      prime = new K256();\n    } else if (name === 'p224') {\n      prime = new P224();\n    } else if (name === 'p192') {\n      prime = new P192();\n    } else if (name === 'p25519') {\n      prime = new P25519();\n    } else {\n      throw new Error('Unknown prime ' + name);\n    }\n    primes[name] = prime;\n\n    return prime;\n  };\n\n  //\n  // Base reduction engine\n  //\n  function Red (m) {\n    if (typeof m === 'string') {\n      var prime = BN._prime(m);\n      this.m = prime.p;\n      this.prime = prime;\n    } else {\n      assert(m.gtn(1), 'modulus must be greater than 1');\n      this.m = m;\n      this.prime = null;\n    }\n  }\n\n  Red.prototype._verify1 = function _verify1 (a) {\n    assert(a.negative === 0, 'red works only with positives');\n    assert(a.red, 'red works only with red numbers');\n  };\n\n  Red.prototype._verify2 = function _verify2 (a, b) {\n    assert((a.negative | b.negative) === 0, 'red works only with positives');\n    assert(a.red && a.red === b.red,\n      'red works only with red numbers');\n  };\n\n  Red.prototype.imod = function imod (a) {\n    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n\n    move(a, a.umod(this.m)._forceRed(this));\n    return a;\n  };\n\n  Red.prototype.neg = function neg (a) {\n    if (a.isZero()) {\n      return a.clone();\n    }\n\n    return this.m.sub(a)._forceRed(this);\n  };\n\n  Red.prototype.add = function add (a, b) {\n    this._verify2(a, b);\n\n    var res = a.add(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.iadd = function iadd (a, b) {\n    this._verify2(a, b);\n\n    var res = a.iadd(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.sub = function sub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.sub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.isub = function isub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.isub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.shl = function shl (a, num) {\n    this._verify1(a);\n    return this.imod(a.ushln(num));\n  };\n\n  Red.prototype.imul = function imul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.imul(b));\n  };\n\n  Red.prototype.mul = function mul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.mul(b));\n  };\n\n  Red.prototype.isqr = function isqr (a) {\n    return this.imul(a, a.clone());\n  };\n\n  Red.prototype.sqr = function sqr (a) {\n    return this.mul(a, a);\n  };\n\n  Red.prototype.sqrt = function sqrt (a) {\n    if (a.isZero()) return a.clone();\n\n    var mod3 = this.m.andln(3);\n    assert(mod3 % 2 === 1);\n\n    // Fast case\n    if (mod3 === 3) {\n      var pow = this.m.add(new BN(1)).iushrn(2);\n      return this.pow(a, pow);\n    }\n\n    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n    //\n    // Find Q and S, that Q * 2 ^ S = (P - 1)\n    var q = this.m.subn(1);\n    var s = 0;\n    while (!q.isZero() && q.andln(1) === 0) {\n      s++;\n      q.iushrn(1);\n    }\n    assert(!q.isZero());\n\n    var one = new BN(1).toRed(this);\n    var nOne = one.redNeg();\n\n    // Find quadratic non-residue\n    // NOTE: Max is such because of generalized Riemann hypothesis.\n    var lpow = this.m.subn(1).iushrn(1);\n    var z = this.m.bitLength();\n    z = new BN(2 * z * z).toRed(this);\n\n    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n      z.redIAdd(nOne);\n    }\n\n    var c = this.pow(z, q);\n    var r = this.pow(a, q.addn(1).iushrn(1));\n    var t = this.pow(a, q);\n    var m = s;\n    while (t.cmp(one) !== 0) {\n      var tmp = t;\n      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n        tmp = tmp.redSqr();\n      }\n      assert(i < m);\n      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n      r = r.redMul(b);\n      c = b.redSqr();\n      t = t.redMul(c);\n      m = i;\n    }\n\n    return r;\n  };\n\n  Red.prototype.invm = function invm (a) {\n    var inv = a._invmp(this.m);\n    if (inv.negative !== 0) {\n      inv.negative = 0;\n      return this.imod(inv).redNeg();\n    } else {\n      return this.imod(inv);\n    }\n  };\n\n  Red.prototype.pow = function pow (a, num) {\n    if (num.isZero()) return new BN(1).toRed(this);\n    if (num.cmpn(1) === 0) return a.clone();\n\n    var windowSize = 4;\n    var wnd = new Array(1 << windowSize);\n    wnd[0] = new BN(1).toRed(this);\n    wnd[1] = a;\n    for (var i = 2; i < wnd.length; i++) {\n      wnd[i] = this.mul(wnd[i - 1], a);\n    }\n\n    var res = wnd[0];\n    var current = 0;\n    var currentLen = 0;\n    var start = num.bitLength() % 26;\n    if (start === 0) {\n      start = 26;\n    }\n\n    for (i = num.length - 1; i >= 0; i--) {\n      var word = num.words[i];\n      for (var j = start - 1; j >= 0; j--) {\n        var bit = (word >> j) & 1;\n        if (res !== wnd[0]) {\n          res = this.sqr(res);\n        }\n\n        if (bit === 0 && current === 0) {\n          currentLen = 0;\n          continue;\n        }\n\n        current <<= 1;\n        current |= bit;\n        currentLen++;\n        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n        res = this.mul(res, wnd[current]);\n        currentLen = 0;\n        current = 0;\n      }\n      start = 26;\n    }\n\n    return res;\n  };\n\n  Red.prototype.convertTo = function convertTo (num) {\n    var r = num.umod(this.m);\n\n    return r === num ? r.clone() : r;\n  };\n\n  Red.prototype.convertFrom = function convertFrom (num) {\n    var res = num.clone();\n    res.red = null;\n    return res;\n  };\n\n  //\n  // Montgomery method engine\n  //\n\n  BN.mont = function mont (num) {\n    return new Mont(num);\n  };\n\n  function Mont (m) {\n    Red.call(this, m);\n\n    this.shift = this.m.bitLength();\n    if (this.shift % 26 !== 0) {\n      this.shift += 26 - (this.shift % 26);\n    }\n\n    this.r = new BN(1).iushln(this.shift);\n    this.r2 = this.imod(this.r.sqr());\n    this.rinv = this.r._invmp(this.m);\n\n    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n    this.minv = this.minv.umod(this.r);\n    this.minv = this.r.sub(this.minv);\n  }\n  inherits(Mont, Red);\n\n  Mont.prototype.convertTo = function convertTo (num) {\n    return this.imod(num.ushln(this.shift));\n  };\n\n  Mont.prototype.convertFrom = function convertFrom (num) {\n    var r = this.imod(num.mul(this.rinv));\n    r.red = null;\n    return r;\n  };\n\n  Mont.prototype.imul = function imul (a, b) {\n    if (a.isZero() || b.isZero()) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    var t = a.imul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.mul = function mul (a, b) {\n    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n    var t = a.mul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.invm = function invm (a) {\n    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n    var res = this.imod(a._invmp(this.m).mul(this.r2));\n    return res._forceRed(this);\n  };\n})( false || module, this);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack://Fabric/./node_modules/browserify-sign/node_modules/bn.js/lib/bn.js?");
./assets/service.js:eval("/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = __webpack_require__(/*! util */ 6);\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = __webpack_require__(/*! ./internal/streams/buffer_list */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/buffer_list.js\");\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/state.js\"),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = __webpack_require__(/*! ../errors */ \"./node_modules/browserify-sign/node_modules/readable-stream/errors-browser.js\").codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Readable, Stream);\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_duplex.js\");\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n  this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_duplex.js\");\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n  var p = this._readableState.buffer.head;\n  var content = '';\n\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n\n  this._readableState.buffer.clear();\n\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n}; // Don't raise the hwm > 1GB\n\n\nvar MAX_HWM = 0x40000000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = __webpack_require__(/*! ./internal/streams/async_iterator */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/async_iterator.js\");\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = __webpack_require__(/*! ./internal/streams/from */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/from-browser.js\");\n    }\n\n    return from(Readable, iterable, opts);\n  };\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://Fabric/./node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_readable.js?");
./assets/service.js:eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\nmodule.exports = Transform;\n\nvar _require$codes = __webpack_require__(/*! ../errors */ \"./node_modules/browserify-sign/node_modules/readable-stream/errors-browser.js\").codes,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\n\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  }; // start out asking for a readable event once data is transformed.\n\n  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  } // When the writable side finishes, then flush out anything remaining.\n\n\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n}; // This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\n\n\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n}; // Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\n\n\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}\n\n//# sourceURL=webpack://Fabric/./node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_transform.js?");
./assets/service.js:eval("/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\nmodule.exports = Writable;\n/* <replacement> */\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n} // It seems a linked list but it is not\n// there will be only 2 of these for each stream\n\n\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\n\n\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n/*<replacement>*/\n\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \"./node_modules/util-deprecate/browser.js\")\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/state.js\"),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = __webpack_require__(/*! ../errors */ \"./node_modules/browserify-sign/node_modules/readable-stream/errors-browser.js\").codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_duplex.js\");\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\n\n  this.finalCalled = false; // drain event flag.\n\n  this.needDrain = false; // at the start of calling end()\n\n  this.ending = false; // when end() has been called, and returned\n\n  this.ended = false; // when 'finish' is emitted\n\n  this.finished = false; // has it been destroyed\n\n  this.destroyed = false; // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n\n  this.length = 0; // a flag to see when we're in the middle of a write.\n\n  this.writing = false; // when true all writes will be buffered until .uncork() call\n\n  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n\n  this.sync = true; // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n  this.writecb = null; // the amount that is being written when _write is called.\n\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n\n  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n\n  this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\n\n  this.autoDestroy = !!options.autoDestroy; // count buffered requests\n\n  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})(); // Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\n\n\nvar realHasInstance;\n\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_duplex.js\"); // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex); // legacy.\n\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n} // Otherwise people can pipe Writable streams, which is just wrong.\n\n\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\n\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n} // Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\n\n\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n\n  return true;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n}); // if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\n\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er); // this can emit finish, and it will always happen\n    // after error\n\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er); // this can emit finish, but finish must\n    // always follow error\n\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n} // Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\n\n\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n} // if there's something in the buffer waiting, then process it\n\n\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  } // ignore unnecessary end() calls.\n\n\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n\n  if (need) {\n    prefinish(stream, state);\n\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  } // reuse the free corkReq.\n\n\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\n\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://Fabric/./node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_writable.js?");
./assets/service.js:eval("\n\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\nfunction Cipher(options) {\n  this.options = options;\n\n  this.type = this.options.type;\n  this.blockSize = 8;\n  this._init();\n\n  this.buffer = new Array(this.blockSize);\n  this.bufferOff = 0;\n}\nmodule.exports = Cipher;\n\nCipher.prototype._init = function _init() {\n  // Might be overrided\n};\n\nCipher.prototype.update = function update(data) {\n  if (data.length === 0)\n    return [];\n\n  if (this.type === 'decrypt')\n    return this._updateDecrypt(data);\n  else\n    return this._updateEncrypt(data);\n};\n\nCipher.prototype._buffer = function _buffer(data, off) {\n  // Append data to buffer\n  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);\n  for (var i = 0; i < min; i++)\n    this.buffer[this.bufferOff + i] = data[off + i];\n  this.bufferOff += min;\n\n  // Shift next\n  return min;\n};\n\nCipher.prototype._flushBuffer = function _flushBuffer(out, off) {\n  this._update(this.buffer, 0, out, off);\n  this.bufferOff = 0;\n  return this.blockSize;\n};\n\nCipher.prototype._updateEncrypt = function _updateEncrypt(data) {\n  var inputOff = 0;\n  var outputOff = 0;\n\n  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;\n  var out = new Array(count * this.blockSize);\n\n  if (this.bufferOff !== 0) {\n    inputOff += this._buffer(data, inputOff);\n\n    if (this.bufferOff === this.buffer.length)\n      outputOff += this._flushBuffer(out, outputOff);\n  }\n\n  // Write blocks\n  var max = data.length - ((data.length - inputOff) % this.blockSize);\n  for (; inputOff < max; inputOff += this.blockSize) {\n    this._update(data, inputOff, out, outputOff);\n    outputOff += this.blockSize;\n  }\n\n  // Queue rest\n  for (; inputOff < data.length; inputOff++, this.bufferOff++)\n    this.buffer[this.bufferOff] = data[inputOff];\n\n  return out;\n};\n\nCipher.prototype._updateDecrypt = function _updateDecrypt(data) {\n  var inputOff = 0;\n  var outputOff = 0;\n\n  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;\n  var out = new Array(count * this.blockSize);\n\n  // TODO(indutny): optimize it, this is far from optimal\n  for (; count > 0; count--) {\n    inputOff += this._buffer(data, inputOff);\n    outputOff += this._flushBuffer(out, outputOff);\n  }\n\n  // Buffer rest of the input\n  inputOff += this._buffer(data, inputOff);\n\n  return out;\n};\n\nCipher.prototype.final = function final(buffer) {\n  var first;\n  if (buffer)\n    first = this.update(buffer);\n\n  var last;\n  if (this.type === 'encrypt')\n    last = this._finalEncrypt();\n  else\n    last = this._finalDecrypt();\n\n  if (first)\n    return first.concat(last);\n  else\n    return last;\n};\n\nCipher.prototype._pad = function _pad(buffer, off) {\n  if (off === 0)\n    return false;\n\n  while (off < buffer.length)\n    buffer[off++] = 0;\n\n  return true;\n};\n\nCipher.prototype._finalEncrypt = function _finalEncrypt() {\n  if (!this._pad(this.buffer, this.bufferOff))\n    return [];\n\n  var out = new Array(this.blockSize);\n  this._update(this.buffer, 0, out, 0);\n  return out;\n};\n\nCipher.prototype._unpad = function _unpad(buffer) {\n  return buffer;\n};\n\nCipher.prototype._finalDecrypt = function _finalDecrypt() {\n  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');\n  var out = new Array(this.blockSize);\n  this._flushBuffer(out, 0);\n\n  return this._unpad(out);\n};\n\n\n//# sourceURL=webpack://Fabric/./node_modules/des.js/lib/des/cipher.js?");
./assets/service.js:eval("/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = __webpack_require__(/*! util */ 0);\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = __webpack_require__(/*! ./internal/streams/buffer_list */ \"./node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/buffer_list.js\");\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"./node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/state.js\"),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = __webpack_require__(/*! ../errors */ \"./node_modules/hash-base/node_modules/readable-stream/errors-browser.js\").codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Readable, Stream);\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/hash-base/node_modules/readable-stream/lib/_stream_duplex.js\");\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n  this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/hash-base/node_modules/readable-stream/lib/_stream_duplex.js\");\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n  var p = this._readableState.buffer.head;\n  var content = '';\n\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n\n  this._readableState.buffer.clear();\n\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n}; // Don't raise the hwm > 1GB\n\n\nvar MAX_HWM = 0x40000000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = __webpack_require__(/*! ./internal/streams/async_iterator */ \"./node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/async_iterator.js\");\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = __webpack_require__(/*! ./internal/streams/from */ \"./node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/from-browser.js\");\n    }\n\n    return from(Readable, iterable, opts);\n  };\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://Fabric/./node_modules/hash-base/node_modules/readable-stream/lib/_stream_readable.js?");
./assets/service.js:eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\nmodule.exports = Transform;\n\nvar _require$codes = __webpack_require__(/*! ../errors */ \"./node_modules/hash-base/node_modules/readable-stream/errors-browser.js\").codes,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\n\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/hash-base/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  }; // start out asking for a readable event once data is transformed.\n\n  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  } // When the writable side finishes, then flush out anything remaining.\n\n\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n}; // This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\n\n\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n}; // Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\n\n\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}\n\n//# sourceURL=webpack://Fabric/./node_modules/hash-base/node_modules/readable-stream/lib/_stream_transform.js?");
./assets/service.js:eval("/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\nmodule.exports = Writable;\n/* <replacement> */\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n} // It seems a linked list but it is not\n// there will be only 2 of these for each stream\n\n\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\n\n\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n/*<replacement>*/\n\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \"./node_modules/util-deprecate/browser.js\")\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"./node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/state.js\"),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = __webpack_require__(/*! ../errors */ \"./node_modules/hash-base/node_modules/readable-stream/errors-browser.js\").codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/hash-base/node_modules/readable-stream/lib/_stream_duplex.js\");\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\n\n  this.finalCalled = false; // drain event flag.\n\n  this.needDrain = false; // at the start of calling end()\n\n  this.ending = false; // when end() has been called, and returned\n\n  this.ended = false; // when 'finish' is emitted\n\n  this.finished = false; // has it been destroyed\n\n  this.destroyed = false; // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n\n  this.length = 0; // a flag to see when we're in the middle of a write.\n\n  this.writing = false; // when true all writes will be buffered until .uncork() call\n\n  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n\n  this.sync = true; // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n  this.writecb = null; // the amount that is being written when _write is called.\n\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n\n  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n\n  this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\n\n  this.autoDestroy = !!options.autoDestroy; // count buffered requests\n\n  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})(); // Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\n\n\nvar realHasInstance;\n\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/hash-base/node_modules/readable-stream/lib/_stream_duplex.js\"); // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex); // legacy.\n\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n} // Otherwise people can pipe Writable streams, which is just wrong.\n\n\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\n\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n} // Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\n\n\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n\n  return true;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n}); // if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\n\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er); // this can emit finish, and it will always happen\n    // after error\n\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er); // this can emit finish, but finish must\n    // always follow error\n\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n} // Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\n\n\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n} // if there's something in the buffer waiting, then process it\n\n\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  } // ignore unnecessary end() calls.\n\n\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n\n  if (need) {\n    prefinish(stream, state);\n\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  } // reuse the free corkReq.\n\n\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\n\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://Fabric/./node_modules/hash-base/node_modules/readable-stream/lib/_stream_writable.js?");
./assets/service.js:eval("/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/*!\n    localForage -- Offline Storage, Improved\n    Version 1.9.0\n    https://localforage.github.io/localForage\n    (c) 2013-2017 Mozilla, Apache License 2.0\n*/\n(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw (f.code=\"MODULE_NOT_FOUND\", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],2:[function(_dereq_,module,exports){\n'use strict';\nvar immediate = _dereq_(1);\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n},{\"1\":1}],3:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nif (typeof global.Promise !== 'function') {\n  global.Promise = _dereq_(2);\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"2\":2}],4:[function(_dereq_,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction getIDB() {\n    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */\n    try {\n        if (typeof indexedDB !== 'undefined') {\n            return indexedDB;\n        }\n        if (typeof webkitIndexedDB !== 'undefined') {\n            return webkitIndexedDB;\n        }\n        if (typeof mozIndexedDB !== 'undefined') {\n            return mozIndexedDB;\n        }\n        if (typeof OIndexedDB !== 'undefined') {\n            return OIndexedDB;\n        }\n        if (typeof msIndexedDB !== 'undefined') {\n            return msIndexedDB;\n        }\n    } catch (e) {\n        return;\n    }\n}\n\nvar idb = getIDB();\n\nfunction isIndexedDBValid() {\n    try {\n        // Initialize IndexedDB; fall back to vendor-prefixed versions\n        // if needed.\n        if (!idb || !idb.open) {\n            return false;\n        }\n        // We mimic PouchDB here;\n        //\n        // We test for openDatabase because IE Mobile identifies itself\n        // as Safari. Oh the lulz...\n        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);\n\n        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;\n\n        // Safari <10.1 does not meet our requirements for IDB support\n        // (see: https://github.com/pouchdb/pouchdb/issues/5572).\n        // Safari 10.1 shipped with fetch, we can use that to detect it.\n        // Note: this creates issues with `window.fetch` polyfills and\n        // overrides; see:\n        // https://github.com/localForage/localForage/issues/856\n        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&\n        // some outdated implementations of IDB that appear on Samsung\n        // and HTC Android devices <4.4 are missing IDBKeyRange\n        // See: https://github.com/mozilla/localForage/issues/128\n        // See: https://github.com/mozilla/localForage/issues/272\n        typeof IDBKeyRange !== 'undefined';\n    } catch (e) {\n        return false;\n    }\n}\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\nfunction createBlob(parts, properties) {\n    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n    parts = parts || [];\n    properties = properties || {};\n    try {\n        return new Blob(parts, properties);\n    } catch (e) {\n        if (e.name !== 'TypeError') {\n            throw e;\n        }\n        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;\n        var builder = new Builder();\n        for (var i = 0; i < parts.length; i += 1) {\n            builder.append(parts[i]);\n        }\n        return builder.getBlob(properties.type);\n    }\n}\n\n// This is CommonJS because lie is an external dependency, so Rollup\n// can just ignore it.\nif (typeof Promise === 'undefined') {\n    // In the \"nopromises\" build this will just throw if you don't have\n    // a global promise object, but it would throw anyway later.\n    _dereq_(3);\n}\nvar Promise$1 = Promise;\n\nfunction executeCallback(promise, callback) {\n    if (callback) {\n        promise.then(function (result) {\n            callback(null, result);\n        }, function (error) {\n            callback(error);\n        });\n    }\n}\n\nfunction executeTwoCallbacks(promise, callback, errorCallback) {\n    if (typeof callback === 'function') {\n        promise.then(callback);\n    }\n\n    if (typeof errorCallback === 'function') {\n        promise[\"catch\"](errorCallback);\n    }\n}\n\nfunction normalizeKey(key) {\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    return key;\n}\n\nfunction getCallback() {\n    if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {\n        return arguments[arguments.length - 1];\n    }\n}\n\n// Some code originally from async_storage.js in\n// [Gaia](https://github.com/mozilla-b2g/gaia).\n\nvar DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';\nvar supportsBlobs = void 0;\nvar dbContexts = {};\nvar toString = Object.prototype.toString;\n\n// Transaction Modes\nvar READ_ONLY = 'readonly';\nvar READ_WRITE = 'readwrite';\n\n// Transform a binary string to an array buffer, because otherwise\n// weird stuff happens when you try to work with the binary string directly.\n// It is known.\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction _binStringToArrayBuffer(bin) {\n    var length = bin.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    for (var i = 0; i < length; i++) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return buf;\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\n// Code borrowed from PouchDB. See:\n// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n//\nfunction _checkBlobSupportWithoutCaching(idb) {\n    return new Promise$1(function (resolve) {\n        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);\n        var blob = createBlob(['']);\n        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\n        txn.onabort = function (e) {\n            // If the transaction aborts now its due to not being able to\n            // write to the database, likely due to the disk being full\n            e.preventDefault();\n            e.stopPropagation();\n            resolve(false);\n        };\n\n        txn.oncomplete = function () {\n            var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n            var matchedEdge = navigator.userAgent.match(/Edge\\//);\n            // MS Edge pretends to be Chrome 42:\n            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n        };\n    })[\"catch\"](function () {\n        return false; // error, so assume unsupported\n    });\n}\n\nfunction _checkBlobSupport(idb) {\n    if (typeof supportsBlobs === 'boolean') {\n        return Promise$1.resolve(supportsBlobs);\n    }\n    return _checkBlobSupportWithoutCaching(idb).then(function (value) {\n        supportsBlobs = value;\n        return supportsBlobs;\n    });\n}\n\nfunction _deferReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Create a deferred object representing the current database operation.\n    var deferredOperation = {};\n\n    deferredOperation.promise = new Promise$1(function (resolve, reject) {\n        deferredOperation.resolve = resolve;\n        deferredOperation.reject = reject;\n    });\n\n    // Enqueue the deferred operation.\n    dbContext.deferredOperations.push(deferredOperation);\n\n    // Chain its promise to the database readiness.\n    if (!dbContext.dbReady) {\n        dbContext.dbReady = deferredOperation.promise;\n    } else {\n        dbContext.dbReady = dbContext.dbReady.then(function () {\n            return deferredOperation.promise;\n        });\n    }\n}\n\nfunction _advanceReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Resolve its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.resolve();\n        return deferredOperation.promise;\n    }\n}\n\nfunction _rejectReadiness(dbInfo, err) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Reject its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.reject(err);\n        return deferredOperation.promise;\n    }\n}\n\nfunction _getConnection(dbInfo, upgradeNeeded) {\n    return new Promise$1(function (resolve, reject) {\n        dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();\n\n        if (dbInfo.db) {\n            if (upgradeNeeded) {\n                _deferReadiness(dbInfo);\n                dbInfo.db.close();\n            } else {\n                return resolve(dbInfo.db);\n            }\n        }\n\n        var dbArgs = [dbInfo.name];\n\n        if (upgradeNeeded) {\n            dbArgs.push(dbInfo.version);\n        }\n\n        var openreq = idb.open.apply(idb, dbArgs);\n\n        if (upgradeNeeded) {\n            openreq.onupgradeneeded = function (e) {\n                var db = openreq.result;\n                try {\n                    db.createObjectStore(dbInfo.storeName);\n                    if (e.oldVersion <= 1) {\n                        // Added when support for blob shims was added\n                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n                    }\n                } catch (ex) {\n                    if (ex.name === 'ConstraintError') {\n                        console.warn('The database \"' + dbInfo.name + '\"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n                    } else {\n                        throw ex;\n                    }\n                }\n            };\n        }\n\n        openreq.onerror = function (e) {\n            e.preventDefault();\n            reject(openreq.error);\n        };\n\n        openreq.onsuccess = function () {\n            resolve(openreq.result);\n            _advanceReadiness(dbInfo);\n        };\n    });\n}\n\nfunction _getOriginalConnection(dbInfo) {\n    return _getConnection(dbInfo, false);\n}\n\nfunction _getUpgradedConnection(dbInfo) {\n    return _getConnection(dbInfo, true);\n}\n\nfunction _isUpgradeNeeded(dbInfo, defaultVersion) {\n    if (!dbInfo.db) {\n        return true;\n    }\n\n    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n    var isDowngrade = dbInfo.version < dbInfo.db.version;\n    var isUpgrade = dbInfo.version > dbInfo.db.version;\n\n    if (isDowngrade) {\n        // If the version is not the default one\n        // then warn for impossible downgrade.\n        if (dbInfo.version !== defaultVersion) {\n            console.warn('The database \"' + dbInfo.name + '\"' + \" can't be downgraded from version \" + dbInfo.db.version + ' to version ' + dbInfo.version + '.');\n        }\n        // Align the versions to prevent errors.\n        dbInfo.version = dbInfo.db.version;\n    }\n\n    if (isUpgrade || isNewStore) {\n        // If the store is new then increment the version (if needed).\n        // This will trigger an \"upgradeneeded\" event which is required\n        // for creating a store.\n        if (isNewStore) {\n            var incVersion = dbInfo.db.version + 1;\n            if (incVersion > dbInfo.version) {\n                dbInfo.version = incVersion;\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n// encode a blob for indexeddb engines that don't support blobs\nfunction _encodeBlob(blob) {\n    return new Promise$1(function (resolve, reject) {\n        var reader = new FileReader();\n        reader.onerror = reject;\n        reader.onloadend = function (e) {\n            var base64 = btoa(e.target.result || '');\n            resolve({\n                __local_forage_encoded_blob: true,\n                data: base64,\n                type: blob.type\n            });\n        };\n        reader.readAsBinaryString(blob);\n    });\n}\n\n// decode an encoded blob\nfunction _decodeBlob(encodedBlob) {\n    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n    return createBlob([arrayBuff], { type: encodedBlob.type });\n}\n\n// is this one of our fancy encoded blobs?\nfunction _isEncodedBlob(value) {\n    return value && value.__local_forage_encoded_blob;\n}\n\n// Specialize the default `ready()` function by making it dependent\n// on the current database operations. Thus, the driver will be actually\n// ready when it's been initialized (default) *and* there are no pending\n// operations on the database (initiated by some other instances).\nfunction _fullyReady(callback) {\n    var self = this;\n\n    var promise = self._initReady().then(function () {\n        var dbContext = dbContexts[self._dbInfo.name];\n\n        if (dbContext && dbContext.dbReady) {\n            return dbContext.dbReady;\n        }\n    });\n\n    executeTwoCallbacks(promise, callback, callback);\n    return promise;\n}\n\n// Try to establish a new db connection to replace the\n// current one which is broken (i.e. experiencing\n// InvalidStateError while creating a transaction).\nfunction _tryReconnect(dbInfo) {\n    _deferReadiness(dbInfo);\n\n    var dbContext = dbContexts[dbInfo.name];\n    var forages = dbContext.forages;\n\n    for (var i = 0; i < forages.length; i++) {\n        var forage = forages[i];\n        if (forage._dbInfo.db) {\n            forage._dbInfo.db.close();\n            forage._dbInfo.db = null;\n        }\n    }\n    dbInfo.db = null;\n\n    return _getOriginalConnection(dbInfo).then(function (db) {\n        dbInfo.db = db;\n        if (_isUpgradeNeeded(dbInfo)) {\n            // Reopen the database for upgrading.\n            return _getUpgradedConnection(dbInfo);\n        }\n        return db;\n    }).then(function (db) {\n        // store the latest db reference\n        // in case the db was upgraded\n        dbInfo.db = dbContext.db = db;\n        for (var i = 0; i < forages.length; i++) {\n            forages[i]._dbInfo.db = db;\n        }\n    })[\"catch\"](function (err) {\n        _rejectReadiness(dbInfo, err);\n        throw err;\n    });\n}\n\n// FF doesn't like Promises (micro-tasks) and IDDB store operations,\n// so we have to do it with callbacks\nfunction createTransaction(dbInfo, mode, callback, retries) {\n    if (retries === undefined) {\n        retries = 1;\n    }\n\n    try {\n        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);\n        callback(null, tx);\n    } catch (err) {\n        if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {\n            return Promise$1.resolve().then(function () {\n                if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {\n                    // increase the db version, to create the new ObjectStore\n                    if (dbInfo.db) {\n                        dbInfo.version = dbInfo.db.version + 1;\n                    }\n                    // Reopen the database for upgrading.\n                    return _getUpgradedConnection(dbInfo);\n                }\n            }).then(function () {\n                return _tryReconnect(dbInfo).then(function () {\n                    createTransaction(dbInfo, mode, callback, retries - 1);\n                });\n            })[\"catch\"](callback);\n        }\n\n        callback(err);\n    }\n}\n\nfunction createDbContext() {\n    return {\n        // Running localForages sharing a database.\n        forages: [],\n        // Shared database.\n        db: null,\n        // Database readiness (promise).\n        dbReady: null,\n        // Deferred operations on the database.\n        deferredOperations: []\n    };\n}\n\n// Open the IndexedDB database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    // Get the current context of the database;\n    var dbContext = dbContexts[dbInfo.name];\n\n    // ...or create a new context.\n    if (!dbContext) {\n        dbContext = createDbContext();\n        // Register the new context in the global container.\n        dbContexts[dbInfo.name] = dbContext;\n    }\n\n    // Register itself as a running localForage in the current context.\n    dbContext.forages.push(self);\n\n    // Replace the default `ready()` function with the specialized one.\n    if (!self._initReady) {\n        self._initReady = self.ready;\n        self.ready = _fullyReady;\n    }\n\n    // Create an array of initialization states of the related localForages.\n    var initPromises = [];\n\n    function ignoreErrors() {\n        // Don't handle errors here,\n        // just makes sure related localForages aren't pending.\n        return Promise$1.resolve();\n    }\n\n    for (var j = 0; j < dbContext.forages.length; j++) {\n        var forage = dbContext.forages[j];\n        if (forage !== self) {\n            // Don't wait for itself...\n            initPromises.push(forage._initReady()[\"catch\"](ignoreErrors));\n        }\n    }\n\n    // Take a snapshot of the related localForages.\n    var forages = dbContext.forages.slice(0);\n\n    // Initialize the connection process only when\n    // all the related localForages aren't pending.\n    return Promise$1.all(initPromises).then(function () {\n        dbInfo.db = dbContext.db;\n        // Get the connection or open a new one without upgrade.\n        return _getOriginalConnection(dbInfo);\n    }).then(function (db) {\n        dbInfo.db = db;\n        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {\n            // Reopen the database for upgrading.\n            return _getUpgradedConnection(dbInfo);\n        }\n        return db;\n    }).then(function (db) {\n        dbInfo.db = dbContext.db = db;\n        self._dbInfo = dbInfo;\n        // Share the final connection amongst related localForages.\n        for (var k = 0; k < forages.length; k++) {\n            var forage = forages[k];\n            if (forage !== self) {\n                // Self is already up-to-date.\n                forage._dbInfo.db = dbInfo.db;\n                forage._dbInfo.version = dbInfo.version;\n            }\n        }\n    });\n}\n\nfunction getItem(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.get(key);\n\n                    req.onsuccess = function () {\n                        var value = req.result;\n                        if (value === undefined) {\n                            value = null;\n                        }\n                        if (_isEncodedBlob(value)) {\n                            value = _decodeBlob(value);\n                        }\n                        resolve(value);\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items stored in database.\nfunction iterate(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.openCursor();\n                    var iterationNumber = 1;\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n\n                        if (cursor) {\n                            var value = cursor.value;\n                            if (_isEncodedBlob(value)) {\n                                value = _decodeBlob(value);\n                            }\n                            var result = iterator(value, cursor.key, iterationNumber++);\n\n                            // when the iterator callback returns any\n                            // (non-`undefined`) value, then we stop\n                            // the iteration immediately\n                            if (result !== void 0) {\n                                resolve(result);\n                            } else {\n                                cursor[\"continue\"]();\n                            }\n                        } else {\n                            resolve();\n                        }\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n\n    return promise;\n}\n\nfunction setItem(key, value, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        var dbInfo;\n        self.ready().then(function () {\n            dbInfo = self._dbInfo;\n            if (toString.call(value) === '[object Blob]') {\n                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {\n                    if (blobSupport) {\n                        return value;\n                    }\n                    return _encodeBlob(value);\n                });\n            }\n            return value;\n        }).then(function (value) {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n\n                    // The reason we don't _save_ null is because IE 10 does\n                    // not support saving the `null` type in IndexedDB. How\n                    // ironic, given the bug below!\n                    // See: https://github.com/mozilla/localForage/issues/161\n                    if (value === null) {\n                        value = undefined;\n                    }\n\n                    var req = store.put(value, key);\n\n                    transaction.oncomplete = function () {\n                        // Cast to undefined so the value passed to\n                        // callback/promise is the same as what one would get out\n                        // of `getItem()` later. This leads to some weirdness\n                        // (setItem('foo', undefined) will return `null`), but\n                        // it's not my fault localStorage is our baseline and that\n                        // it's weird.\n                        if (value === undefined) {\n                            value = null;\n                        }\n\n                        resolve(value);\n                    };\n                    transaction.onabort = transaction.onerror = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction removeItem(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    // We use a Grunt task to make this safe for IE and some\n                    // versions of Android (including those used by Cordova).\n                    // Normally IE won't like `.delete()` and will insist on\n                    // using `['delete']()`, but we have a build step that\n                    // fixes this for us now.\n                    var req = store[\"delete\"](key);\n                    transaction.oncomplete = function () {\n                        resolve();\n                    };\n\n                    transaction.onerror = function () {\n                        reject(req.error);\n                    };\n\n                    // The request will be also be aborted if we've exceeded our storage\n                    // space.\n                    transaction.onabort = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction clear(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.clear();\n\n                    transaction.oncomplete = function () {\n                        resolve();\n                    };\n\n                    transaction.onabort = transaction.onerror = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction length(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.count();\n\n                    req.onsuccess = function () {\n                        resolve(req.result);\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction key(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        if (n < 0) {\n            resolve(null);\n\n            return;\n        }\n\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var advanced = false;\n                    var req = store.openKeyCursor();\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n                        if (!cursor) {\n                            // this means there weren't enough keys\n                            resolve(null);\n\n                            return;\n                        }\n\n                        if (n === 0) {\n                            // We have the first key, return it if that's what they\n                            // wanted.\n                            resolve(cursor.key);\n                        } else {\n                            if (!advanced) {\n                                // Otherwise, ask the cursor to skip ahead n\n                                // records.\n                                advanced = true;\n                                cursor.advance(n);\n                            } else {\n                                // When we get here, we've got the nth key.\n                                resolve(cursor.key);\n                            }\n                        }\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.openKeyCursor();\n                    var keys = [];\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n\n                        if (!cursor) {\n                            resolve(keys);\n                            return;\n                        }\n\n                        keys.push(cursor.key);\n                        cursor[\"continue\"]();\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction dropInstance(options, callback) {\n    callback = getCallback.apply(this, arguments);\n\n    var currentConfig = this.config();\n    options = typeof options !== 'function' && options || {};\n    if (!options.name) {\n        options.name = options.name || currentConfig.name;\n        options.storeName = options.storeName || currentConfig.storeName;\n    }\n\n    var self = this;\n    var promise;\n    if (!options.name) {\n        promise = Promise$1.reject('Invalid arguments');\n    } else {\n        var isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;\n\n        var dbPromise = isCurrentDb ? Promise$1.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(function (db) {\n            var dbContext = dbContexts[options.name];\n            var forages = dbContext.forages;\n            dbContext.db = db;\n            for (var i = 0; i < forages.length; i++) {\n                forages[i]._dbInfo.db = db;\n            }\n            return db;\n        });\n\n        if (!options.storeName) {\n            promise = dbPromise.then(function (db) {\n                _deferReadiness(options);\n\n                var dbContext = dbContexts[options.name];\n                var forages = dbContext.forages;\n\n                db.close();\n                for (var i = 0; i < forages.length; i++) {\n                    var forage = forages[i];\n                    forage._dbInfo.db = null;\n                }\n\n                var dropDBPromise = new Promise$1(function (resolve, reject) {\n                    var req = idb.deleteDatabase(options.name);\n\n                    req.onerror = req.onblocked = function (err) {\n                        var db = req.result;\n                        if (db) {\n                            db.close();\n                        }\n                        reject(err);\n                    };\n\n                    req.onsuccess = function () {\n                        var db = req.result;\n                        if (db) {\n                            db.close();\n                        }\n                        resolve(db);\n                    };\n                });\n\n                return dropDBPromise.then(function (db) {\n                    dbContext.db = db;\n                    for (var i = 0; i < forages.length; i++) {\n                        var _forage = forages[i];\n                        _advanceReadiness(_forage._dbInfo);\n                    }\n                })[\"catch\"](function (err) {\n                    (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function () {});\n                    throw err;\n                });\n            });\n        } else {\n            promise = dbPromise.then(function (db) {\n                if (!db.objectStoreNames.contains(options.storeName)) {\n                    return;\n                }\n\n                var newVersion = db.version + 1;\n\n                _deferReadiness(options);\n\n                var dbContext = dbContexts[options.name];\n                var forages = dbContext.forages;\n\n                db.close();\n                for (var i = 0; i < forages.length; i++) {\n                    var forage = forages[i];\n                    forage._dbInfo.db = null;\n                    forage._dbInfo.version = newVersion;\n                }\n\n                var dropObjectPromise = new Promise$1(function (resolve, reject) {\n                    var req = idb.open(options.name, newVersion);\n\n                    req.onerror = function (err) {\n                        var db = req.result;\n                        db.close();\n                        reject(err);\n                    };\n\n                    req.onupgradeneeded = function () {\n                        var db = req.result;\n                        db.deleteObjectStore(options.storeName);\n                    };\n\n                    req.onsuccess = function () {\n                        var db = req.result;\n                        db.close();\n                        resolve(db);\n                    };\n                });\n\n                return dropObjectPromise.then(function (db) {\n                    dbContext.db = db;\n                    for (var j = 0; j < forages.length; j++) {\n                        var _forage2 = forages[j];\n                        _forage2._dbInfo.db = db;\n                        _advanceReadiness(_forage2._dbInfo);\n                    }\n                })[\"catch\"](function (err) {\n                    (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function () {});\n                    throw err;\n                });\n            });\n        }\n    }\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar asyncStorage = {\n    _driver: 'asyncStorage',\n    _initStorage: _initStorage,\n    _support: isIndexedDBValid(),\n    iterate: iterate,\n    getItem: getItem,\n    setItem: setItem,\n    removeItem: removeItem,\n    clear: clear,\n    length: length,\n    key: key,\n    keys: keys,\n    dropInstance: dropInstance\n};\n\nfunction isWebSQLValid() {\n    return typeof openDatabase === 'function';\n}\n\n// Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n// it to Base64, so this is how we store it to prevent very strange errors with less\n// verbose ways of binary <-> string data storage.\nvar BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nvar BLOB_TYPE_PREFIX = '~~local_forage_type~';\nvar BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n\nvar SERIALIZED_MARKER = '__lfsc__:';\nvar SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n\n// OMG the serializations!\nvar TYPE_ARRAYBUFFER = 'arbf';\nvar TYPE_BLOB = 'blob';\nvar TYPE_INT8ARRAY = 'si08';\nvar TYPE_UINT8ARRAY = 'ui08';\nvar TYPE_UINT8CLAMPEDARRAY = 'uic8';\nvar TYPE_INT16ARRAY = 'si16';\nvar TYPE_INT32ARRAY = 'si32';\nvar TYPE_UINT16ARRAY = 'ur16';\nvar TYPE_UINT32ARRAY = 'ui32';\nvar TYPE_FLOAT32ARRAY = 'fl32';\nvar TYPE_FLOAT64ARRAY = 'fl64';\nvar TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n\nvar toString$1 = Object.prototype.toString;\n\nfunction stringToBuffer(serializedString) {\n    // Fill the string into a ArrayBuffer.\n    var bufferLength = serializedString.length * 0.75;\n    var len = serializedString.length;\n    var i;\n    var p = 0;\n    var encoded1, encoded2, encoded3, encoded4;\n\n    if (serializedString[serializedString.length - 1] === '=') {\n        bufferLength--;\n        if (serializedString[serializedString.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n\n    var buffer = new ArrayBuffer(bufferLength);\n    var bytes = new Uint8Array(buffer);\n\n    for (i = 0; i < len; i += 4) {\n        encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n\n        /*jslint bitwise: true */\n        bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n    }\n    return buffer;\n}\n\n// Converts a buffer to a string to store, serialized, in the backend\n// storage library.\nfunction bufferToString(buffer) {\n    // base64-arraybuffer\n    var bytes = new Uint8Array(buffer);\n    var base64String = '';\n    var i;\n\n    for (i = 0; i < bytes.length; i += 3) {\n        /*jslint bitwise: true */\n        base64String += BASE_CHARS[bytes[i] >> 2];\n        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n        base64String += BASE_CHARS[bytes[i + 2] & 63];\n    }\n\n    if (bytes.length % 3 === 2) {\n        base64String = base64String.substring(0, base64String.length - 1) + '=';\n    } else if (bytes.length % 3 === 1) {\n        base64String = base64String.substring(0, base64String.length - 2) + '==';\n    }\n\n    return base64String;\n}\n\n// Serialize a value, afterwards executing a callback (which usually\n// instructs the `setItem()` callback/promise to be executed). This is how\n// we store binary data with localStorage.\nfunction serialize(value, callback) {\n    var valueType = '';\n    if (value) {\n        valueType = toString$1.call(value);\n    }\n\n    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n    // checks fail when running the tests using casper.js...\n    //\n    // TODO: See why those tests fail and use a better solution.\n    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {\n        // Convert binary arrays to a string and prefix the string with\n        // a special marker.\n        var buffer;\n        var marker = SERIALIZED_MARKER;\n\n        if (value instanceof ArrayBuffer) {\n            buffer = value;\n            marker += TYPE_ARRAYBUFFER;\n        } else {\n            buffer = value.buffer;\n\n            if (valueType === '[object Int8Array]') {\n                marker += TYPE_INT8ARRAY;\n            } else if (valueType === '[object Uint8Array]') {\n                marker += TYPE_UINT8ARRAY;\n            } else if (valueType === '[object Uint8ClampedArray]') {\n                marker += TYPE_UINT8CLAMPEDARRAY;\n            } else if (valueType === '[object Int16Array]') {\n                marker += TYPE_INT16ARRAY;\n            } else if (valueType === '[object Uint16Array]') {\n                marker += TYPE_UINT16ARRAY;\n            } else if (valueType === '[object Int32Array]') {\n                marker += TYPE_INT32ARRAY;\n            } else if (valueType === '[object Uint32Array]') {\n                marker += TYPE_UINT32ARRAY;\n            } else if (valueType === '[object Float32Array]') {\n                marker += TYPE_FLOAT32ARRAY;\n            } else if (valueType === '[object Float64Array]') {\n                marker += TYPE_FLOAT64ARRAY;\n            } else {\n                callback(new Error('Failed to get type for BinaryArray'));\n            }\n        }\n\n        callback(marker + bufferToString(buffer));\n    } else if (valueType === '[object Blob]') {\n        // Conver the blob to a binaryArray and then to a string.\n        var fileReader = new FileReader();\n\n        fileReader.onload = function () {\n            // Backwards-compatible prefix for the blob type.\n            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);\n\n            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n        };\n\n        fileReader.readAsArrayBuffer(value);\n    } else {\n        try {\n            callback(JSON.stringify(value));\n        } catch (e) {\n            console.error(\"Couldn't convert value into a JSON string: \", value);\n\n            callback(null, e);\n        }\n    }\n}\n\n// Deserialize data we've inserted into a value column/field. We place\n// special markers into our strings to mark them as encoded; this isn't\n// as nice as a meta field, but it's the only sane thing we can do whilst\n// keeping localStorage support intact.\n//\n// Oftentimes this will just deserialize JSON content, but if we have a\n// special marker (SERIALIZED_MARKER, defined above), we will extract\n// some kind of arraybuffer/binary data/typed array out of the string.\nfunction deserialize(value) {\n    // If we haven't marked this string as being specially serialized (i.e.\n    // something other than serialized JSON), we can just return it and be\n    // done with it.\n    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n        return JSON.parse(value);\n    }\n\n    // The following code deals with deserializing some kind of Blob or\n    // TypedArray. First we separate out the type of data we're dealing\n    // with from the data itself.\n    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n\n    var blobType;\n    // Backwards-compatible blob type serialization strategy.\n    // DBs created with older versions of localForage will simply not have the blob type.\n    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n        blobType = matcher[1];\n        serializedString = serializedString.substring(matcher[0].length);\n    }\n    var buffer = stringToBuffer(serializedString);\n\n    // Return the right type based on the code/type set during\n    // serialization.\n    switch (type) {\n        case TYPE_ARRAYBUFFER:\n            return buffer;\n        case TYPE_BLOB:\n            return createBlob([buffer], { type: blobType });\n        case TYPE_INT8ARRAY:\n            return new Int8Array(buffer);\n        case TYPE_UINT8ARRAY:\n            return new Uint8Array(buffer);\n        case TYPE_UINT8CLAMPEDARRAY:\n            return new Uint8ClampedArray(buffer);\n        case TYPE_INT16ARRAY:\n            return new Int16Array(buffer);\n        case TYPE_UINT16ARRAY:\n            return new Uint16Array(buffer);\n        case TYPE_INT32ARRAY:\n            return new Int32Array(buffer);\n        case TYPE_UINT32ARRAY:\n            return new Uint32Array(buffer);\n        case TYPE_FLOAT32ARRAY:\n            return new Float32Array(buffer);\n        case TYPE_FLOAT64ARRAY:\n            return new Float64Array(buffer);\n        default:\n            throw new Error('Unkown type: ' + type);\n    }\n}\n\nvar localforageSerializer = {\n    serialize: serialize,\n    deserialize: deserialize,\n    stringToBuffer: stringToBuffer,\n    bufferToString: bufferToString\n};\n\n/*\n * Includes code from:\n *\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n\nfunction createDbTable(t, dbInfo, callback, errorCallback) {\n    t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' ' + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);\n}\n\n// Open the WebSQL database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage$1(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];\n        }\n    }\n\n    var dbInfoPromise = new Promise$1(function (resolve, reject) {\n        // Open the database; the openDatabase API will automatically\n        // create it for us if it doesn't exist.\n        try {\n            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n        } catch (e) {\n            return reject(e);\n        }\n\n        // Create our key/value table if it doesn't exist.\n        dbInfo.db.transaction(function (t) {\n            createDbTable(t, dbInfo, function () {\n                self._dbInfo = dbInfo;\n                resolve();\n            }, function (t, error) {\n                reject(error);\n            });\n        }, reject);\n    });\n\n    dbInfo.serializer = localforageSerializer;\n    return dbInfoPromise;\n}\n\nfunction tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {\n    t.executeSql(sqlStatement, args, callback, function (t, error) {\n        if (error.code === error.SYNTAX_ERR) {\n            t.executeSql('SELECT name FROM sqlite_master ' + \"WHERE type='table' AND name = ?\", [dbInfo.storeName], function (t, results) {\n                if (!results.rows.length) {\n                    // if the table is missing (was deleted)\n                    // re-create it table and retry\n                    createDbTable(t, dbInfo, function () {\n                        t.executeSql(sqlStatement, args, callback, errorCallback);\n                    }, errorCallback);\n                } else {\n                    errorCallback(t, error);\n                }\n            }, errorCallback);\n        } else {\n            errorCallback(t, error);\n        }\n    }, errorCallback);\n}\n\nfunction getItem$1(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).value : null;\n\n                    // Check to see if this is serialized content we need to\n                    // unpack.\n                    if (result) {\n                        result = dbInfo.serializer.deserialize(result);\n                    }\n\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction iterate$1(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var rows = results.rows;\n                    var length = rows.length;\n\n                    for (var i = 0; i < length; i++) {\n                        var item = rows.item(i);\n                        var result = item.value;\n\n                        // Check to see if this is serialized content\n                        // we need to unpack.\n                        if (result) {\n                            result = dbInfo.serializer.deserialize(result);\n                        }\n\n                        result = iterator(result, item.key, i + 1);\n\n                        // void(0) prevents problems with redefinition\n                        // of `undefined`.\n                        if (result !== void 0) {\n                            resolve(result);\n                            return;\n                        }\n                    }\n\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction _setItem(key, value, callback, retriesLeft) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            // The localStorage API doesn't return undefined values in an\n            // \"expected\" way, so undefined is always cast to null in all\n            // drivers. See: https://github.com/mozilla/localForage/pull/42\n            if (value === undefined) {\n                value = null;\n            }\n\n            // Save the original value to pass to the callback.\n            var originalValue = value;\n\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    dbInfo.db.transaction(function (t) {\n                        tryExecuteSql(t, dbInfo, 'INSERT OR REPLACE INTO ' + dbInfo.storeName + ' ' + '(key, value) VALUES (?, ?)', [key, value], function () {\n                            resolve(originalValue);\n                        }, function (t, error) {\n                            reject(error);\n                        });\n                    }, function (sqlError) {\n                        // The transaction failed; check\n                        // to see if it's a quota error.\n                        if (sqlError.code === sqlError.QUOTA_ERR) {\n                            // We reject the callback outright for now, but\n                            // it's worth trying to re-run the transaction.\n                            // Even if the user accepts the prompt to use\n                            // more storage on Safari, this error will\n                            // be called.\n                            //\n                            // Try to re-run the transaction.\n                            if (retriesLeft > 0) {\n                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));\n                                return;\n                            }\n                            reject(sqlError);\n                        }\n                    });\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction setItem$1(key, value, callback) {\n    return _setItem.apply(this, [key, value, callback, 1]);\n}\n\nfunction removeItem$1(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Deletes every item in the table.\n// TODO: Find out if this resets the AUTO_INCREMENT number.\nfunction clear$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName, [], function () {\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Does a simple `COUNT(key)` to get the number of items stored in\n// localForage.\nfunction length$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                // Ahhh, SQL makes this one soooooo easy.\n                tryExecuteSql(t, dbInfo, 'SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var result = results.rows.item(0).c;\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Return the key located at key index X; essentially gets the key from a\n// `WHERE id = ?`. This is the most efficient way I can think to implement\n// this rarely-used (in my experience) part of the API, but it can seem\n// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n// the ID of each key will change every time it's updated. Perhaps a stored\n// procedure for the `setItem()` SQL would solve this problem?\n// TODO: Don't change ID on `setItem()`.\nfunction key$1(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).key : null;\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var keys = [];\n\n                    for (var i = 0; i < results.rows.length; i++) {\n                        keys.push(results.rows.item(i).key);\n                    }\n\n                    resolve(keys);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// https://www.w3.org/TR/webdatabase/#databases\n// > There is no way to enumerate or delete the databases available for an origin from this API.\nfunction getAllStoreNames(db) {\n    return new Promise$1(function (resolve, reject) {\n        db.transaction(function (t) {\n            t.executeSql('SELECT name FROM sqlite_master ' + \"WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'\", [], function (t, results) {\n                var storeNames = [];\n\n                for (var i = 0; i < results.rows.length; i++) {\n                    storeNames.push(results.rows.item(i).name);\n                }\n\n                resolve({\n                    db: db,\n                    storeNames: storeNames\n                });\n            }, function (t, error) {\n                reject(error);\n            });\n        }, function (sqlError) {\n            reject(sqlError);\n        });\n    });\n}\n\nfunction dropInstance$1(options, callback) {\n    callback = getCallback.apply(this, arguments);\n\n    var currentConfig = this.config();\n    options = typeof options !== 'function' && options || {};\n    if (!options.name) {\n        options.name = options.name || currentConfig.name;\n        options.storeName = options.storeName || currentConfig.storeName;\n    }\n\n    var self = this;\n    var promise;\n    if (!options.name) {\n        promise = Promise$1.reject('Invalid arguments');\n    } else {\n        promise = new Promise$1(function (resolve) {\n            var db;\n            if (options.name === currentConfig.name) {\n                // use the db reference of the current instance\n                db = self._dbInfo.db;\n            } else {\n                db = openDatabase(options.name, '', '', 0);\n            }\n\n            if (!options.storeName) {\n                // drop all database tables\n                resolve(getAllStoreNames(db));\n            } else {\n                resolve({\n                    db: db,\n                    storeNames: [options.storeName]\n                });\n            }\n        }).then(function (operationInfo) {\n            return new Promise$1(function (resolve, reject) {\n                operationInfo.db.transaction(function (t) {\n                    function dropTable(storeName) {\n                        return new Promise$1(function (resolve, reject) {\n                            t.executeSql('DROP TABLE IF EXISTS ' + storeName, [], function () {\n                                resolve();\n                            }, function (t, error) {\n                                reject(error);\n                            });\n                        });\n                    }\n\n                    var operations = [];\n                    for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {\n                        operations.push(dropTable(operationInfo.storeNames[i]));\n                    }\n\n                    Promise$1.all(operations).then(function () {\n                        resolve();\n                    })[\"catch\"](function (e) {\n                        reject(e);\n                    });\n                }, function (sqlError) {\n                    reject(sqlError);\n                });\n            });\n        });\n    }\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar webSQLStorage = {\n    _driver: 'webSQLStorage',\n    _initStorage: _initStorage$1,\n    _support: isWebSQLValid(),\n    iterate: iterate$1,\n    getItem: getItem$1,\n    setItem: setItem$1,\n    removeItem: removeItem$1,\n    clear: clear$1,\n    length: length$1,\n    key: key$1,\n    keys: keys$1,\n    dropInstance: dropInstance$1\n};\n\nfunction isLocalStorageValid() {\n    try {\n        return typeof localStorage !== 'undefined' && 'setItem' in localStorage &&\n        // in IE8 typeof localStorage.setItem === 'object'\n        !!localStorage.setItem;\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction _getKeyPrefix(options, defaultConfig) {\n    var keyPrefix = options.name + '/';\n\n    if (options.storeName !== defaultConfig.storeName) {\n        keyPrefix += options.storeName + '/';\n    }\n    return keyPrefix;\n}\n\n// Check if localStorage throws when saving an item\nfunction checkIfLocalStorageThrows() {\n    var localStorageTestKey = '_localforage_support_test';\n\n    try {\n        localStorage.setItem(localStorageTestKey, true);\n        localStorage.removeItem(localStorageTestKey);\n\n        return false;\n    } catch (e) {\n        return true;\n    }\n}\n\n// Check if localStorage is usable and allows to save an item\n// This method checks if localStorage is usable in Safari Private Browsing\n// mode, or in any other case where the available quota for localStorage\n// is 0 and there wasn't any saved items yet.\nfunction _isLocalStorageUsable() {\n    return !checkIfLocalStorageThrows() || localStorage.length > 0;\n}\n\n// Config the localStorage backend, using options set in the config.\nfunction _initStorage$2(options) {\n    var self = this;\n    var dbInfo = {};\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);\n\n    if (!_isLocalStorageUsable()) {\n        return Promise$1.reject();\n    }\n\n    self._dbInfo = dbInfo;\n    dbInfo.serializer = localforageSerializer;\n\n    return Promise$1.resolve();\n}\n\n// Remove all keys from the datastore, effectively destroying all data in\n// the app's key/value store!\nfunction clear$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var keyPrefix = self._dbInfo.keyPrefix;\n\n        for (var i = localStorage.length - 1; i >= 0; i--) {\n            var key = localStorage.key(i);\n\n            if (key.indexOf(keyPrefix) === 0) {\n                localStorage.removeItem(key);\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Retrieve an item from the store. Unlike the original async_storage\n// library in Gaia, we don't modify return values at all. If a key's value\n// is `undefined`, we pass that value to the callback function.\nfunction getItem$2(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result = localStorage.getItem(dbInfo.keyPrefix + key);\n\n        // If a result was found, parse it from the serialized\n        // string into a JS object. If result isn't truthy, the key\n        // is likely undefined and we'll pass it straight to the\n        // callback.\n        if (result) {\n            result = dbInfo.serializer.deserialize(result);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items in the store.\nfunction iterate$2(iterator, callback) {\n    var self = this;\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var keyPrefix = dbInfo.keyPrefix;\n        var keyPrefixLength = keyPrefix.length;\n        var length = localStorage.length;\n\n        // We use a dedicated iterator instead of the `i` variable below\n        // so other keys we fetch in localStorage aren't counted in\n        // the `iterationNumber` argument passed to the `iterate()`\n        // callback.\n        //\n        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n        var iterationNumber = 1;\n\n        for (var i = 0; i < length; i++) {\n            var key = localStorage.key(i);\n            if (key.indexOf(keyPrefix) !== 0) {\n                continue;\n            }\n            var value = localStorage.getItem(key);\n\n            // If a result was found, parse it from the serialized\n            // string into a JS object. If result isn't truthy, the\n            // key is likely undefined and we'll pass it straight\n            // to the iterator.\n            if (value) {\n                value = dbInfo.serializer.deserialize(value);\n            }\n\n            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\n\n            if (value !== void 0) {\n                return value;\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Same as localStorage's key() method, except takes a callback.\nfunction key$2(n, callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result;\n        try {\n            result = localStorage.key(n);\n        } catch (error) {\n            result = null;\n        }\n\n        // Remove the prefix from the key, if a key is found.\n        if (result) {\n            result = result.substring(dbInfo.keyPrefix.length);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var length = localStorage.length;\n        var keys = [];\n\n        for (var i = 0; i < length; i++) {\n            var itemKey = localStorage.key(i);\n            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {\n                keys.push(itemKey.substring(dbInfo.keyPrefix.length));\n            }\n        }\n\n        return keys;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Supply the number of keys in the datastore to the callback function.\nfunction length$2(callback) {\n    var self = this;\n    var promise = self.keys().then(function (keys) {\n        return keys.length;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Remove an item from the store, nice and simple.\nfunction removeItem$2(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        localStorage.removeItem(dbInfo.keyPrefix + key);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Set a key's value and run an optional callback once the value is set.\n// Unlike Gaia's implementation, the callback function is passed the value,\n// in case you want to operate on that value only after you're sure it\n// saved, or something like that.\nfunction setItem$2(key, value, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        // Convert undefined values to null.\n        // https://github.com/mozilla/localForage/pull/42\n        if (value === undefined) {\n            value = null;\n        }\n\n        // Save the original value to pass to the callback.\n        var originalValue = value;\n\n        return new Promise$1(function (resolve, reject) {\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    try {\n                        localStorage.setItem(dbInfo.keyPrefix + key, value);\n                        resolve(originalValue);\n                    } catch (e) {\n                        // localStorage capacity exceeded.\n                        // TODO: Make this a specific error/event.\n                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n                            reject(e);\n                        }\n                        reject(e);\n                    }\n                }\n            });\n        });\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction dropInstance$2(options, callback) {\n    callback = getCallback.apply(this, arguments);\n\n    options = typeof options !== 'function' && options || {};\n    if (!options.name) {\n        var currentConfig = this.config();\n        options.name = options.name || currentConfig.name;\n        options.storeName = options.storeName || currentConfig.storeName;\n    }\n\n    var self = this;\n    var promise;\n    if (!options.name) {\n        promise = Promise$1.reject('Invalid arguments');\n    } else {\n        promise = new Promise$1(function (resolve) {\n            if (!options.storeName) {\n                resolve(options.name + '/');\n            } else {\n                resolve(_getKeyPrefix(options, self._defaultConfig));\n            }\n        }).then(function (keyPrefix) {\n            for (var i = localStorage.length - 1; i >= 0; i--) {\n                var key = localStorage.key(i);\n\n                if (key.indexOf(keyPrefix) === 0) {\n                    localStorage.removeItem(key);\n                }\n            }\n        });\n    }\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar localStorageWrapper = {\n    _driver: 'localStorageWrapper',\n    _initStorage: _initStorage$2,\n    _support: isLocalStorageValid(),\n    iterate: iterate$2,\n    getItem: getItem$2,\n    setItem: setItem$2,\n    removeItem: removeItem$2,\n    clear: clear$2,\n    length: length$2,\n    key: key$2,\n    keys: keys$2,\n    dropInstance: dropInstance$2\n};\n\nvar sameValue = function sameValue(x, y) {\n    return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);\n};\n\nvar includes = function includes(array, searchElement) {\n    var len = array.length;\n    var i = 0;\n    while (i < len) {\n        if (sameValue(array[i], searchElement)) {\n            return true;\n        }\n        i++;\n    }\n\n    return false;\n};\n\nvar isArray = Array.isArray || function (arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]';\n};\n\n// Drivers are stored here when `defineDriver()` is called.\n// They are shared across all instances of localForage.\nvar DefinedDrivers = {};\n\nvar DriverSupport = {};\n\nvar DefaultDrivers = {\n    INDEXEDDB: asyncStorage,\n    WEBSQL: webSQLStorage,\n    LOCALSTORAGE: localStorageWrapper\n};\n\nvar DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];\n\nvar OptionalDriverMethods = ['dropInstance'];\n\nvar LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(OptionalDriverMethods);\n\nvar DefaultConfig = {\n    description: '',\n    driver: DefaultDriverOrder.slice(),\n    name: 'localforage',\n    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n    // we can use without a prompt.\n    size: 4980736,\n    storeName: 'keyvaluepairs',\n    version: 1.0\n};\n\nfunction callWhenReady(localForageInstance, libraryMethod) {\n    localForageInstance[libraryMethod] = function () {\n        var _args = arguments;\n        return localForageInstance.ready().then(function () {\n            return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n        });\n    };\n}\n\nfunction extend() {\n    for (var i = 1; i < arguments.length; i++) {\n        var arg = arguments[i];\n\n        if (arg) {\n            for (var _key in arg) {\n                if (arg.hasOwnProperty(_key)) {\n                    if (isArray(arg[_key])) {\n                        arguments[0][_key] = arg[_key].slice();\n                    } else {\n                        arguments[0][_key] = arg[_key];\n                    }\n                }\n            }\n        }\n    }\n\n    return arguments[0];\n}\n\nvar LocalForage = function () {\n    function LocalForage(options) {\n        _classCallCheck(this, LocalForage);\n\n        for (var driverTypeKey in DefaultDrivers) {\n            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {\n                var driver = DefaultDrivers[driverTypeKey];\n                var driverName = driver._driver;\n                this[driverTypeKey] = driverName;\n\n                if (!DefinedDrivers[driverName]) {\n                    // we don't need to wait for the promise,\n                    // since the default drivers can be defined\n                    // in a blocking manner\n                    this.defineDriver(driver);\n                }\n            }\n        }\n\n        this._defaultConfig = extend({}, DefaultConfig);\n        this._config = extend({}, this._defaultConfig, options);\n        this._driverSet = null;\n        this._initDriver = null;\n        this._ready = false;\n        this._dbInfo = null;\n\n        this._wrapLibraryMethodsWithReady();\n        this.setDriver(this._config.driver)[\"catch\"](function () {});\n    }\n\n    // Set any config values for localForage; can be called anytime before\n    // the first API call (e.g. `getItem`, `setItem`).\n    // We loop through options so we don't overwrite existing config\n    // values.\n\n\n    LocalForage.prototype.config = function config(options) {\n        // If the options argument is an object, we use it to set values.\n        // Otherwise, we return either a specified config value or all\n        // config values.\n        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n            // If localforage is ready and fully initialized, we can't set\n            // any new configuration values. Instead, we return an error.\n            if (this._ready) {\n                return new Error(\"Can't call config() after localforage \" + 'has been used.');\n            }\n\n            for (var i in options) {\n                if (i === 'storeName') {\n                    options[i] = options[i].replace(/\\W/g, '_');\n                }\n\n                if (i === 'version' && typeof options[i] !== 'number') {\n                    return new Error('Database version must be a number.');\n                }\n\n                this._config[i] = options[i];\n            }\n\n            // after all config options are set and\n            // the driver option is used, try setting it\n            if ('driver' in options && options.driver) {\n                return this.setDriver(this._config.driver);\n            }\n\n            return true;\n        } else if (typeof options === 'string') {\n            return this._config[options];\n        } else {\n            return this._config;\n        }\n    };\n\n    // Used to define a custom driver, shared across all instances of\n    // localForage.\n\n\n    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {\n        var promise = new Promise$1(function (resolve, reject) {\n            try {\n                var driverName = driverObject._driver;\n                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');\n\n                // A driver name should be defined and not overlap with the\n                // library-defined, default drivers.\n                if (!driverObject._driver) {\n                    reject(complianceError);\n                    return;\n                }\n\n                var driverMethods = LibraryMethods.concat('_initStorage');\n                for (var i = 0, len = driverMethods.length; i < len; i++) {\n                    var driverMethodName = driverMethods[i];\n\n                    // when the property is there,\n                    // it should be a method even when optional\n                    var isRequired = !includes(OptionalDriverMethods, driverMethodName);\n                    if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {\n                        reject(complianceError);\n                        return;\n                    }\n                }\n\n                var configureMissingMethods = function configureMissingMethods() {\n                    var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {\n                        return function () {\n                            var error = new Error('Method ' + methodName + ' is not implemented by the current driver');\n                            var promise = Promise$1.reject(error);\n                            executeCallback(promise, arguments[arguments.length - 1]);\n                            return promise;\n                        };\n                    };\n\n                    for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {\n                        var optionalDriverMethod = OptionalDriverMethods[_i];\n                        if (!driverObject[optionalDriverMethod]) {\n                            driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);\n                        }\n                    }\n                };\n\n                configureMissingMethods();\n\n                var setDriverSupport = function setDriverSupport(support) {\n                    if (DefinedDrivers[driverName]) {\n                        console.info('Redefining LocalForage driver: ' + driverName);\n                    }\n                    DefinedDrivers[driverName] = driverObject;\n                    DriverSupport[driverName] = support;\n                    // don't use a then, so that we can define\n                    // drivers that have simple _support methods\n                    // in a blocking manner\n                    resolve();\n                };\n\n                if ('_support' in driverObject) {\n                    if (driverObject._support && typeof driverObject._support === 'function') {\n                        driverObject._support().then(setDriverSupport, reject);\n                    } else {\n                        setDriverSupport(!!driverObject._support);\n                    }\n                } else {\n                    setDriverSupport(true);\n                }\n            } catch (e) {\n                reject(e);\n            }\n        });\n\n        executeTwoCallbacks(promise, callback, errorCallback);\n        return promise;\n    };\n\n    LocalForage.prototype.driver = function driver() {\n        return this._driver || null;\n    };\n\n    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {\n        var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));\n\n        executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n        return getDriverPromise;\n    };\n\n    LocalForage.prototype.getSerializer = function getSerializer(callback) {\n        var serializerPromise = Promise$1.resolve(localforageSerializer);\n        executeTwoCallbacks(serializerPromise, callback);\n        return serializerPromise;\n    };\n\n    LocalForage.prototype.ready = function ready(callback) {\n        var self = this;\n\n        var promise = self._driverSet.then(function () {\n            if (self._ready === null) {\n                self._ready = self._initDriver();\n            }\n\n            return self._ready;\n        });\n\n        executeTwoCallbacks(promise, callback, callback);\n        return promise;\n    };\n\n    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {\n        var self = this;\n\n        if (!isArray(drivers)) {\n            drivers = [drivers];\n        }\n\n        var supportedDrivers = this._getSupportedDrivers(drivers);\n\n        function setDriverToConfig() {\n            self._config.driver = self.driver();\n        }\n\n        function extendSelfWithDriver(driver) {\n            self._extend(driver);\n            setDriverToConfig();\n\n            self._ready = self._initStorage(self._config);\n            return self._ready;\n        }\n\n        function initDriver(supportedDrivers) {\n            return function () {\n                var currentDriverIndex = 0;\n\n                function driverPromiseLoop() {\n                    while (currentDriverIndex < supportedDrivers.length) {\n                        var driverName = supportedDrivers[currentDriverIndex];\n                        currentDriverIndex++;\n\n                        self._dbInfo = null;\n                        self._ready = null;\n\n                        return self.getDriver(driverName).then(extendSelfWithDriver)[\"catch\"](driverPromiseLoop);\n                    }\n\n                    setDriverToConfig();\n                    var error = new Error('No available storage method found.');\n                    self._driverSet = Promise$1.reject(error);\n                    return self._driverSet;\n                }\n\n                return driverPromiseLoop();\n            };\n        }\n\n        // There might be a driver initialization in progress\n        // so wait for it to finish in order to avoid a possible\n        // race condition to set _dbInfo\n        var oldDriverSetDone = this._driverSet !== null ? this._driverSet[\"catch\"](function () {\n            return Promise$1.resolve();\n        }) : Promise$1.resolve();\n\n        this._driverSet = oldDriverSetDone.then(function () {\n            var driverName = supportedDrivers[0];\n            self._dbInfo = null;\n            self._ready = null;\n\n            return self.getDriver(driverName).then(function (driver) {\n                self._driver = driver._driver;\n                setDriverToConfig();\n                self._wrapLibraryMethodsWithReady();\n                self._initDriver = initDriver(supportedDrivers);\n            });\n        })[\"catch\"](function () {\n            setDriverToConfig();\n            var error = new Error('No available storage method found.');\n            self._driverSet = Promise$1.reject(error);\n            return self._driverSet;\n        });\n\n        executeTwoCallbacks(this._driverSet, callback, errorCallback);\n        return this._driverSet;\n    };\n\n    LocalForage.prototype.supports = function supports(driverName) {\n        return !!DriverSupport[driverName];\n    };\n\n    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {\n        extend(this, libraryMethodsAndProperties);\n    };\n\n    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {\n        var supportedDrivers = [];\n        for (var i = 0, len = drivers.length; i < len; i++) {\n            var driverName = drivers[i];\n            if (this.supports(driverName)) {\n                supportedDrivers.push(driverName);\n            }\n        }\n        return supportedDrivers;\n    };\n\n    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {\n        // Add a stub for each driver API method that delays the call to the\n        // corresponding driver method until localForage is ready. These stubs\n        // will be replaced by the driver methods as soon as the driver is\n        // loaded, so there is no performance impact.\n        for (var i = 0, len = LibraryMethods.length; i < len; i++) {\n            callWhenReady(this, LibraryMethods[i]);\n        }\n    };\n\n    LocalForage.prototype.createInstance = function createInstance(options) {\n        return new LocalForage(options);\n    };\n\n    return LocalForage;\n}();\n\n// The actual localForage object that we expose as a module or via a\n// global. It's extended by pulling in one of our other libraries.\n\n\nvar localforage_js = new LocalForage();\n\nmodule.exports = localforage_js;\n\n},{\"3\":3}]},{},[4])(4)\n});\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://Fabric/./node_modules/localforage/dist/localforage.js?");
./assets/service.js:eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nexports.__esModule = true;\nvar reverse = __webpack_require__(/*! buffer-reverse */ \"./node_modules/buffer-reverse/index.js\");\nvar CryptoJS = __webpack_require__(/*! crypto-js */ \"./node_modules/crypto-js/index.js\");\nvar treeify = __webpack_require__(/*! treeify */ \"./node_modules/treeify/treeify.js\");\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */\nvar MerkleTree = /** @class */ (function () {\n    /**\n     * @desc Constructs a Merkle Tree.\n     * All nodes and leaves are stored as Buffers.\n     * Lonely leaf nodes are promoted to the next level up without being hashed again.\n     * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.\n     * @param {Function} hashAlgorithm - Algorithm used for hashing leaves and nodes\n     * @param {Object} options - Additional options\n     * @example\n     *```js\n     *const MerkleTree = require('merkletreejs')\n     *const crypto = require('crypto')\n     *\n     *function sha256(data) {\n     *  // returns Buffer\n     *  return crypto.createHash('sha256').update(data).digest()\n     *}\n     *\n     *const leaves = ['a', 'b', 'c'].map(x => keccak(x))\n     *\n     *const tree = new MerkleTree(leaves, sha256)\n     *```\n     */\n    function MerkleTree(leaves, hashAlgorithm, options) {\n        if (options === void 0) { options = {}; }\n        this.isBitcoinTree = !!options.isBitcoinTree;\n        this.hashLeaves = !!options.hashLeaves;\n        this.sortLeaves = !!options.sortLeaves;\n        this.sortPairs = !!options.sortPairs;\n        this.sort = !!options.sort;\n        if (this.sort) {\n            this.sortLeaves = true;\n            this.sortPairs = true;\n        }\n        this.duplicateOdd = !!options.duplicateOdd;\n        this.hashAlgo = bufferifyFn(hashAlgorithm);\n        if (this.hashLeaves) {\n            leaves = leaves.map(this.hashAlgo);\n        }\n        this.leaves = leaves.map(bufferify);\n        if (this.sortLeaves) {\n            this.leaves = this.leaves.sort(Buffer.compare);\n        }\n        this.layers = [this.leaves];\n        this.createHashes(this.leaves);\n    }\n    // TODO: documentation\n    MerkleTree.prototype.createHashes = function (nodes) {\n        while (nodes.length > 1) {\n            var layerIndex = this.layers.length;\n            this.layers.push([]);\n            for (var i = 0; i < nodes.length; i += 2) {\n                if (i + 1 === nodes.length) {\n                    if (nodes.length % 2 === 1) {\n                        var data_1 = nodes[nodes.length - 1];\n                        var hash_1 = data_1;\n                        // is bitcoin tree\n                        if (this.isBitcoinTree) {\n                            // Bitcoin method of duplicating the odd ending nodes\n                            data_1 = Buffer.concat([reverse(data_1), reverse(data_1)]);\n                            hash_1 = this.hashAlgo(data_1);\n                            hash_1 = reverse(this.hashAlgo(hash_1));\n                            this.layers[layerIndex].push(hash_1);\n                            continue;\n                        }\n                        else {\n                            if (!this.duplicateOdd) {\n                                this.layers[layerIndex].push(nodes[i]);\n                                continue;\n                            }\n                        }\n                    }\n                }\n                var left = nodes[i];\n                var right = i + 1 == nodes.length ? left : nodes[i + 1];\n                var data = null;\n                var combined = null;\n                if (this.isBitcoinTree) {\n                    combined = [reverse(left), reverse(right)];\n                }\n                else {\n                    combined = [left, right];\n                }\n                if (this.sortPairs) {\n                    combined.sort(Buffer.compare);\n                }\n                data = Buffer.concat(combined);\n                var hash = this.hashAlgo(data);\n                // double hash if bitcoin tree\n                if (this.isBitcoinTree) {\n                    hash = reverse(this.hashAlgo(hash));\n                }\n                this.layers[layerIndex].push(hash);\n            }\n            nodes = this.layers[layerIndex];\n        }\n    };\n    /**\n     * getLeaves\n     * @desc Returns array of leaves of Merkle Tree.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const leaves = tree.getLeaves()\n     *```\n     */\n    MerkleTree.prototype.getLeaves = function () {\n        return this.leaves;\n    };\n    /**\n     * getLayers\n     * @desc Returns array of all layers of Merkle Tree, including leaves and root.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const layers = tree.getLayers()\n     *```\n     */\n    MerkleTree.prototype.getLayers = function () {\n        return this.layers;\n    };\n    /**\n     * getRoot\n     * @desc Returns the Merkle root hash as a Buffer.\n     * @return {Buffer}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *```\n     */\n    MerkleTree.prototype.getRoot = function () {\n        return this.layers[this.layers.length - 1][0] || Buffer.from([]);\n    };\n    // TODO: documentation\n    MerkleTree.prototype.getHexRoot = function () {\n        return bufferToHex(this.getRoot());\n    };\n    /**\n     * getProof\n     * @desc Returns the proof for a target leaf.\n     * @param {Buffer} leaf - Target leaf\n     * @param {Number} [index] - Target leaf index in leaves array.\n     * Use if there are leaves containing duplicate data in order to distinguish it.\n     * @return {Object[]} - Array of objects containing a position property of type string\n     * with values of 'left' or 'right' and a data property of type Buffer.\n     *@example\n     * ```js\n     *const proof = tree.getProof(leaves[2])\n     *```\n     *\n     * @example\n     *```js\n     *const leaves = ['a', 'b', 'a'].map(x => keccak(x))\n     *const tree = new MerkleTree(leaves, keccak)\n     *const proof = tree.getProof(leaves[2], 2)\n     *```\n     */\n    MerkleTree.prototype.getProof = function (leaf, index) {\n        leaf = bufferify(leaf);\n        var proof = [];\n        if (typeof index !== 'number') {\n            index = -1;\n            for (var i = 0; i < this.leaves.length; i++) {\n                if (Buffer.compare(leaf, this.leaves[i]) === 0) {\n                    index = i;\n                }\n            }\n        }\n        if (index <= -1) {\n            return [];\n        }\n        if (this.isBitcoinTree && index === (this.leaves.length - 1)) {\n            // Proof Generation for Bitcoin Trees\n            for (var i = 0; i < this.layers.length - 1; i++) {\n                var layer = this.layers[i];\n                var isRightNode = index % 2;\n                var pairIndex = (isRightNode ? index - 1 : index);\n                if (pairIndex < layer.length) {\n                    proof.push({\n                        data: layer[pairIndex]\n                    });\n                }\n                // set index to parent index\n                index = (index / 2) | 0;\n            }\n            return proof;\n        }\n        else {\n            // Proof Generation for Non-Bitcoin Trees\n            for (var i = 0; i < this.layers.length; i++) {\n                var layer = this.layers[i];\n                var isRightNode = index % 2;\n                var pairIndex = (isRightNode ? index - 1 : index + 1);\n                if (pairIndex < layer.length) {\n                    proof.push({\n                        position: isRightNode ? 'left' : 'right',\n                        data: layer[pairIndex]\n                    });\n                }\n                // set index to parent index\n                index = (index / 2) | 0;\n            }\n            return proof;\n        }\n    };\n    // TODO: documentation\n    MerkleTree.prototype.getHexProof = function (leaf, index) {\n        return this.getProof(leaf, index).map(function (x) { return bufferToHex(x.data); });\n    };\n    /**\n     * verify\n     * @desc Returns true if the proof path (array of hashes) can connect the target node\n     * to the Merkle root.\n     * @param {Object[]} proof - Array of proof objects that should connect\n     * target node to Merkle root.\n     * @param {Buffer} targetNode - Target node Buffer\n     * @param {Buffer} root - Merkle root Buffer\n     * @return {Boolean}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *const proof = tree.getProof(leaves[2])\n     *const verified = tree.verify(proof, leaves[2], root)\n     *```\n     */\n    MerkleTree.prototype.verify = function (proof, targetNode, root) {\n        var hash = bufferify(targetNode);\n        root = bufferify(root);\n        if (!Array.isArray(proof) ||\n            !proof.length ||\n            !targetNode ||\n            !root) {\n            return false;\n        }\n        for (var i = 0; i < proof.length; i++) {\n            var node = proof[i];\n            var data = null;\n            var isLeftNode = null;\n            // NOTE: case for when proof is hex values only\n            if (typeof node === 'string') {\n                data = bufferify(node);\n                isLeftNode = true;\n            }\n            else {\n                data = node.data;\n                isLeftNode = (node.position === 'left');\n            }\n            var buffers = [];\n            if (this.isBitcoinTree) {\n                buffers.push(reverse(hash));\n                buffers[isLeftNode ? 'unshift' : 'push'](reverse(data));\n                hash = this.hashAlgo(Buffer.concat(buffers));\n                hash = reverse(this.hashAlgo(hash));\n            }\n            else {\n                if (this.sortPairs) {\n                    if (Buffer.compare(hash, data) === -1) {\n                        buffers.push(hash, data);\n                        hash = this.hashAlgo(Buffer.concat(buffers));\n                    }\n                    else {\n                        buffers.push(data, hash);\n                        hash = this.hashAlgo(Buffer.concat(buffers));\n                    }\n                }\n                else {\n                    buffers.push(hash);\n                    buffers[isLeftNode ? 'unshift' : 'push'](data);\n                    hash = this.hashAlgo(Buffer.concat(buffers));\n                }\n            }\n        }\n        return Buffer.compare(hash, root) === 0;\n    };\n    // TODO: documentation\n    MerkleTree.prototype.getLayersAsObject = function () {\n        var _a;\n        var layers = this.getLayers().map(function (x) { return x.map(function (x) { return x.toString('hex'); }); });\n        var objs = [];\n        for (var i = 0; i < layers.length; i++) {\n            var arr = [];\n            for (var j = 0; j < layers[i].length; j++) {\n                var obj = (_a = {}, _a[layers[i][j]] = null, _a);\n                if (objs.length) {\n                    obj[layers[i][j]] = {};\n                    var a = objs.shift();\n                    var akey = Object.keys(a)[0];\n                    obj[layers[i][j]][akey] = a[akey];\n                    if (objs.length) {\n                        var b = objs.shift();\n                        var bkey = Object.keys(b)[0];\n                        obj[layers[i][j]][bkey] = b[bkey];\n                    }\n                }\n                arr.push(obj);\n            }\n            objs.push.apply(objs, arr);\n        }\n        return objs[0];\n    };\n    // TODO: documentation\n    MerkleTree.prototype.print = function () {\n        MerkleTree.print(this);\n    };\n    // TODO: documentation\n    MerkleTree.prototype.toTreeString = function () {\n        var obj = this.getLayersAsObject();\n        return treeify.asTree(obj, true);\n    };\n    // TODO: documentation\n    MerkleTree.prototype.toString = function () {\n        return this.toTreeString();\n    };\n    // TODO: documentation\n    MerkleTree.bufferify = function (x) {\n        return bufferify(x);\n    };\n    // TODO: documentation\n    MerkleTree.print = function (tree) {\n        console.log(tree.toString());\n    };\n    return MerkleTree;\n}());\nexports.MerkleTree = MerkleTree;\nfunction bufferToHex(value) {\n    return '0x' + value.toString('hex');\n}\nfunction bufferify(x) {\n    if (!Buffer.isBuffer(x)) {\n        // crypto-js support\n        if (typeof x === 'object' && x.words) {\n            return Buffer.from(x.toString(CryptoJS.enc.Hex), 'hex');\n        }\n        else if (isHexStr(x)) {\n            return Buffer.from(x.replace(/^0x/, ''), 'hex');\n        }\n        else if (typeof x === 'string') {\n            return Buffer.from(x);\n        }\n    }\n    return x;\n}\nfunction bufferifyFn(f) {\n    return function (x) {\n        var v = f(x);\n        if (Buffer.isBuffer(v)) {\n            return v;\n        }\n        if (isHexStr(v)) {\n            return Buffer.from(v, 'hex');\n        }\n        // crypto-js support\n        return Buffer.from(f(CryptoJS.enc.Hex.parse(x.toString('hex'))).toString(CryptoJS.enc.Hex), 'hex');\n    };\n}\nfunction isHexStr(v) {\n    return (typeof v === 'string' && /^(0x)?[0-9A-Fa-f]*$/.test(v));\n}\nexports[\"default\"] = MerkleTree;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://Fabric/./node_modules/merkletreejs/dist/index.js?");
./assets/service.js:eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://Fabric/./node_modules/node-libs-browser/node_modules/buffer/index.js?");
./assets/service.js:eval("/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \"./node_modules/util-deprecate/browser.js\")\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\"), __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://Fabric/./node_modules/readable-stream/lib/_stream_writable.js?");
./assets/service.js:eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar punycode = __webpack_require__(/*! punycode */ \"./node_modules/node-libs-browser/node_modules/punycode/punycode.js\");\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/url/util.js\");\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = __webpack_require__(/*! querystring */ \"./node_modules/querystring-es3/index.js\");\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\n\n//# sourceURL=webpack://Fabric/./node_modules/url/url.js?");
./assets/service.js:eval("\n\nconst crypto = __webpack_require__(/*! crypto */ \"./node_modules/crypto-browserify/index.js\");\n\n// Fabric Components\nconst State = __webpack_require__(/*! ./state */ \"./types/state.js\");\n\n/**\n * Simple tag-based recordkeeper.\n * @extends State\n * @property {Object} config Current configuration.\n */\nclass Scribe extends State {\n  /**\n   * The \"Scribe\" is a simple tag-based recordkeeper.\n   * @param       {Object} config General configuration object.\n   * @param       {Boolean} config.verbose Should the Scribe be noisy?\n   */\n  constructor (config = {}) {\n    super(config);\n\n    // assign the defaults;\n    this.settings = this.config = Object.assign({\n      verbose: true,\n      verbosity: 2, // 0 none, 1 error, 2 warning, 3 notice, 4 debug\n      path: './stores/scribe',\n      tags: []\n    }, config);\n\n    // internal state\n    this._state = new State(config);\n\n    // signal ready\n    this.status = 'ready';\n\n    return this;\n  }\n\n  /** Retrives the current timestamp, in milliseconds.\n   * @return {Number} {@link Number} representation of the millisecond {@link Integer} value.\n   */\n  now () {\n    // return new Date().toISOString();\n    return new Date().getTime();\n  }\n\n  sha256 (data) {\n    return crypto.createHash('sha256').update(data).digest('hex');\n  }\n\n  _sign () {\n    this.commit();\n  }\n\n  /**\n   * Blindly bind event handlers to the {@link Source}.\n   * @param  {Source} source Event stream.\n   * @return {Scribe}        Instance of the {@link Scribe}.\n   */\n  trust (source) {\n    let self = this;\n\n    source.on('message', async function handleTrustedMessage (msg) {\n      // console.trace('[FABRIC:SCRIBE]', 'Our Scribe received the following message from a trusted source:', msg);\n    });\n\n    source.on('transaction', async function handleTrustedTransaction (transaction) {\n      self.log('[SCRIBE]', '[EVENT:TRANSACTION]', 'apply this transaction to local state:', transaction);\n      self.log('[PROPOSAL]', 'apply this transaction to local state:', transaction);\n    });\n\n    return self;\n  }\n\n  /**\n   * Use an existing Scribe instance as a parent.\n   * @param  {Scribe} scribe Instance of Scribe to use as parent.\n   * @return {Scribe}        The configured instance of the Scribe.\n   */\n  inherits (scribe) {\n    return this.tags.push(scribe.config.namespace);\n  }\n\n  log (...inputs) {\n    let now = this.now();\n\n    inputs.unshift(`[${this.constructor.name.toUpperCase()}]`);\n    inputs.unshift(`[${now}]`);\n\n    if (this.settings.verbosity >= 3) {\n      console.log.apply(null, ['[SCRIBE]'].concat(inputs));\n    }\n\n    return this.emit('info', ['[SCRIBE]'].concat(inputs));\n  }\n\n  error (...inputs) {\n    let now = this.now();\n\n    inputs.unshift(`[${this.constructor.name.toUpperCase()}]`);\n    inputs.unshift(`[${now}]`);\n\n    if (this.config.verbose) {\n      console.error.apply(null, ['[SCRIBE]'].concat(inputs));\n    }\n\n    return this.emit('error', ['[SCRIBE]'].concat(inputs));\n  }\n\n  warn (...inputs) {\n    let now = this.now();\n\n    inputs.unshift(`[${this.constructor.name.toUpperCase()}]`);\n    inputs.unshift(`[${now}]`);\n\n    if (this.config.verbose) {\n      console.warn.apply(null, ['[SCRIBE]'].concat(inputs));\n    }\n\n    return this.emit('warning', ['[SCRIBE]'].concat(inputs));\n  }\n\n  debug (...inputs) {\n    let now = this.now();\n\n    inputs.unshift(`[${this.constructor.name.toUpperCase()}]`);\n    inputs.unshift(`[${now}]`);\n\n    if (this.config.verbose) {\n      console.debug.apply(null, ['[SCRIBE]'].concat(inputs));\n    }\n\n    return this.emit('debug', ['[SCRIBE]'].concat(inputs));\n  }\n\n  async open () {\n    this.status = 'opened';\n    return this;\n  }\n\n  async close () {\n    this.status = 'closed';\n    return this;\n  }\n\n  async start () {\n    this.status = 'starting';\n    this['@data'] = this.config;\n\n    await this.open();\n    await this.commit();\n\n    // TODO: enable\n    // this.trust(this.state);\n\n    this.status = 'started';\n\n    return this;\n  }\n\n  async stop () {\n    this.status = 'stopping';\n    await this.close();\n    this.status = 'stopped';\n    return this;\n  }\n}\n\nmodule.exports = Scribe;\n\n\n//# sourceURL=webpack://Fabric/./types/scribe.js?");
./assets/service.js:eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\n\nconst {\n  MAX_MEMORY_ALLOC,\n  MAX_FRAME_SIZE\n} = __webpack_require__(/*! ../constants */ \"./constants.js\");\n\nconst State = __webpack_require__(/*! ./state */ \"./types/state.js\");\nconst { MerkleTree } = __webpack_require__(/*! merkletreejs */ \"./node_modules/merkletreejs/dist/index.js\");\n\n/**\n * Manage stacks of data.\n */\nclass Stack extends State {\n  /**\n   * Create a {@link Stack} instance.\n   * @param  {Array}  [list=[]] Genesis state for the {@link Stack} instance.\n   * @return {Stack}            Instance of the {@link Stack}.\n   */\n  constructor (list = []) {\n    super(list);\n\n    this.limit = MAX_MEMORY_ALLOC;\n    this.frame = Buffer.alloc(MAX_FRAME_SIZE);\n    this.config = list || [];\n\n    // Patch for new Collection inheritance\n    this.settings = Object.assign({\n      verbosity: 2\n    }, list);\n\n    this['@type'] = this.config['@type'];\n    this['@entity'].frames = {};\n    this['@entity'].states = {};\n    this['@states'] = {};\n    this['@data'] = [];\n\n    if (list instanceof Array) {\n      for (let i in list) {\n        this.push(list[i]);\n      }\n    }\n\n    this['@entity']['@type'] = this['@type'];\n    this['@entity']['@data'] = this['@data'];\n    this['@id'] = this.id;\n\n    return this;\n  }\n\n  get size () {\n    return this['@data'].length;\n  }\n\n  /**\n   * Push data onto the stack.  Changes the {@link Stack#frame} and\n   * {@link Stack#id}.\n   * @param  {Mixed} data Treated as a {@link State}.\n   * @return {Number}      Resulting size of the stack.\n   */\n  push (data) {\n    let state = new State(data);\n\n    this['@entity'].states[this.id] = this['@data'];\n    this['@entity'].states[state.id] = state['@data'];\n    this['@entity'].frames[this.id] = this['@data'];\n    this['@entity'].frames[state.id] = state['@data'];\n\n    // write the frame\n    // NOTE: no garbage collection\n    this.frame = Buffer.from(state.id);\n\n    // push frame onto stack\n    this['@data'].push(this.frame);\n    this['@type'] = 'Stack';\n    this['@size'] = this['@data'].length * MAX_FRAME_SIZE;\n\n    this.commit();\n\n    return this['@data'].length;\n  }\n\n  dedupe () {\n    return new Stack([...new Set(this.asArray())]);\n  }\n\n  pop () {\n    let element = this['@data'].pop();\n    return element;\n  }\n\n  asArray () {\n    return Array.from(this['@data']);\n  }\n\n  asMerkleTree () {\n    return new MerkleTree(this.asArray(), this.sha256, {\n      isBitcoinTree: true\n    });\n  }\n\n  snapshot () {\n    return this.id || { '@id': `${this.sha256(this.state['@data'])}` };\n  }\n\n  commit () {\n    let stack = this;\n    let changes = super.commit();\n\n    if (changes.length) {\n      let data = Object.assign({}, {\n        parent: stack.tip,\n        changes: changes\n      });\n\n      stack.state['@data'] = data;\n      stack.history.push(stack.state.id);\n    }\n\n    // TODO: return Transaction\n    return changes;\n  }\n}\n\nmodule.exports = Stack;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://Fabric/./types/stack.js?");
./assets/service.js:eval("\n// TODO: note that generally, requirements are loosely ordered by\n// their relative importance to the file in question\nconst util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\nconst localforage = __webpack_require__(/*! localforage */ \"./node_modules/localforage/dist/localforage.js\");\n\nfunction Stash (vector) {\n  this.config = Object.assign({\n    path: './stores/store',\n    get: this.get,\n    set: this.set,\n    del: this.del,\n    transform: this.transform,\n    createReadStream: this.createReadStream\n  }, vector || {});\n\n  this.clock = 0;\n  this.stack = [];\n  this.known = {};\n\n  this.open();\n\n  this.init();\n}\n\nutil.inherits(Stash, __webpack_require__(/*! ./vector */ \"./types/vector.js\"));\n\nStash.prototype.open = function load () {\n  this.db = localforage.createInstance({\n    name: 'fabric'\n  });\n};\n\nStash.prototype.get = async function GET (key) {\n  var self = this;\n  var value = await self.db.getItem(key);\n  if (!value) return null;\n  // if (typeof value !== 'string') return JSON.parse(value);\n  return value;\n};\n\nStash.prototype.set = async function PUT (key, value) {\n  var self = this;\n  if (typeof value !== 'string') {\n    value = self._serialize(value);\n  }\n\n  await self.db.setItem(key, value);\n\n  return await self.db.getItem(key);\n};\n\nStash.prototype.del = async function DEL (key) {\n  return await this.db.setItem(key, null);\n};\n\nStash.prototype.transform = function TRANSFORM (transaction, done) {\n  // this.db.del(batch, done);\n  return new Error('not yet implemented');\n};\n\nStash.prototype.createReadStream = function createReadStream () {\n  return this.db.createReadStream();\n};\n\nStash.prototype.close = async function close () {\n  return await this.db.close();\n};\n\nmodule.exports = Stash;\n\n\n//# sourceURL=webpack://Fabric/./types/stash.js?");
./assets/service.js:eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\n\nconst {\n  MAX_MESSAGE_SIZE\n} = __webpack_require__(/*! ../constants */ \"./constants.js\");\n\nconst crypto = __webpack_require__(/*! crypto */ \"./node_modules/crypto-browserify/index.js\");\nconst monitor = __webpack_require__(/*! fast-json-patch */ \"./node_modules/fast-json-patch/lib/duplex.js\");\nconst pointer = __webpack_require__(/*! json-pointer */ \"./node_modules/json-pointer/index.js\");\nconst EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\n/**\n * The {@link State} is the core of most {@link User}-facing interactions.  To\n * interact with the {@link User}, simply propose a change in the state by\n * committing to the outcome.  This workflow keeps app design quite simple!\n * @augments EventEmitter\n * @property {Number} size Size of state in bytes.\n * @property {Buffer} @buffer Byte-for-byte memory representation of state.\n * @property {String} @type Named type.\n * @property {Mixed} @data Local instance of the state.\n * @property {String} @id Unique identifier for this data.\n */\nclass State extends EventEmitter {\n  /**\n   * Creates a snapshot of some information.\n   * @param  {Mixed} data Input data.\n   * @return {State}      Resulting state.\n   */\n  constructor (data = {}) {\n    super(data);\n\n    this['@version'] = 0x01;\n    this['@input'] = data || null;\n    this['@data'] = data || {};\n    this['@meta'] = {};\n    this['@encoding'] = 'json';\n\n    // Literal Entity Structure\n    this['@entity'] = {\n      '@type': 'State',\n      '@data': data\n    };\n\n    // TODO: test and document memory alignment\n    // this['@buffer'] = Buffer.alloc(Constants.MAX_MESSAGE_SIZE);\n    this['@allocation'] = Buffer.alloc(MAX_MESSAGE_SIZE);\n    this['@buffer'] = Buffer.from(this.serialize(this['@entity']['@data']));\n\n    // if not destined to be an object...\n    if (typeof this['@data'] === 'string') {\n      this['@entity']['@type'] = 'String';\n      this['@entity']['@data'] = this['@data'].split('').map(x => x.charCodeAt(0));\n    } else if (this['@data'] instanceof Array) {\n      this['@entity']['@type'] = 'Array';\n    } else if (this['@data'] instanceof Buffer) {\n      this['@entity']['@type'] = 'Buffer';\n    } else if (\n      this['@data'] &&\n      this['@data']['@type'] &&\n      this['@data']['@data']\n    ) {\n      switch (this['@data']['@type']) {\n        default:\n          this['@entity']['@type'] = this['@data']['@type'];\n          this['@entity']['@data'] = this['@data']['@data'];\n          break;\n      }\n    } else {\n      this['@entity']['@type'] = 'Object';\n      this['@entity']['@data'] = data;\n    }\n\n    Object.defineProperty(this, `size`, {\n      enumerable: true,\n      get: function count () {\n        return this['@buffer'].length;\n      }\n    });\n\n    Object.defineProperty(this, 'domain', {\n      enumerable: false\n    });\n\n    Object.defineProperty(this, '_events', {\n      enumerable: false\n    });\n\n    Object.defineProperty(this, '_eventsCount', {\n      enumerable: false\n    });\n\n    Object.defineProperty(this, '_maxListeners', {\n      enumerable: false\n    });\n\n    // start at zero\n    this.clock = 0;\n\n    // set various #meta\n    this['@type'] = this['@entity']['@type'];\n    // this['@id'] = null;\n    // this['@id'] = this.id;\n\n    // set internal data\n    this.services = ['json'];\n    // TODO: re-enable\n    // this.name = this['@entity'].name || this.id;\n    this.link = `/entities/${this.fingerprint()}`;\n\n    if (this['@entity']['@data']) {\n      try {\n        this.observer = monitor.observe(this['@entity']['@data']);\n      } catch (E) {\n        console.error('Could not create observer:', E, this['@entity']['@data']);\n      }\n    }\n\n    this.value = {};\n\n    // TODO: document hidden properties\n    // Remove various undesired clutter from output\n    Object.defineProperty(this, '@allocation', { enumerable: false });\n    Object.defineProperty(this, '@buffer', { enumerable: false });\n    Object.defineProperty(this, '@encoding', { enumerable: false });\n    Object.defineProperty(this, 'services', { enumerable: false });\n\n    return this;\n  }\n\n  static get pointer () {\n    return pointer;\n  }\n\n  /**\n   * Identity function.\n   * @type {Boolean}\n   */\n  get id () {\n    return this.fingerprint();\n  }\n\n  get state () {\n    return this.value;\n    // TODO: re-enable the below, map security considerations\n    // return Object.assign({}, this.value);\n  }\n\n  set state (value) {\n    this.value = value;\n  }\n\n  /**\n   * Marshall an input into an instance of a {@link State}.  States have\n   * absolute authority over their own domain, so choose your States wisely.\n   * @param  {String} input Arbitrary input.\n   * @return {State}       Resulting instance of the {@link State}.\n   */\n  static fromJSON (input) {\n    if (typeof input !== 'string') return null;\n\n    let result = null;\n\n    try {\n      result = JSON.parse(input);\n    } catch (E) {\n      console.error('Failure in fromJSON:', E);\n    }\n\n    return result;\n  }\n\n  static fromHex (input) {\n    if (typeof input !== 'string') return null;\n    return this.fromJSON(Buffer.from(input, 'hex').toString('utf8'));\n  }\n\n  static fromString (input) {\n    if (typeof input !== 'string') return null;\n    return this.fromJSON(input);\n  }\n\n  async _getState () {\n    let self = this;\n    let results = await Promise.all([\n      async function () {\n        return self.value;\n      }\n    ]).then(([\n      state\n    ]) => {\n      return {\n        state\n      };\n    }).catch(e => console.error(e));\n\n    return results;\n  }\n\n  sha256 (value) {\n    return crypto.createHash('sha256').update(value).digest('hex');\n  }\n\n  async _applyChanges (ops) {\n    try {\n      monitor.applyPatch(this['@data'], ops);\n\n      await this.commit();\n    } catch (E) {\n      this.error('Error applying changes:', E);\n    }\n\n    return this;\n  }\n\n  fingerprint () {\n    let map = {};\n    map['@method'] = 'sha256';\n    map['@input'] = this.serialize(this['@entity']['@data']);\n    map['@buffer'] = crypto.createHash('sha256').update(map['@input'], 'utf8');\n    map['@output'] = map['@buffer'].digest('hex');\n    return map['@output'];\n  }\n\n  isRoot () {\n    return this['@parent'] === this.id;\n  }\n\n  toBuffer () {\n    if (this['@data'] instanceof Buffer) return this['@data'];\n    if (this['@data']) return this.serialize();\n\n    return Buffer.from(this['@data']['@data']);\n  }\n\n  toHTML () {\n    let state = this;\n    let solution = state['@output'].toString('utf8');\n    let confirmed = String(solution);\n    let raw = `X-Claim-ID: ${this.id}\nX-Claim-Integrity: sha256\nX-Claim-Type: Response\nX-Claim-Result: ${state.id}\nBody:\n# STOP!\nHere is your opportunity to read the documentation: https://dev.fabric.pub\n\nDocument ID: ${this.id}\nDocument Type (local JSON): ${this.constructor.name}\nDocument Path: ${this.path}\nDocument Name: ${this.name}\nDocument Integrity: sha256:${this.id}\nDocument Data (local JSON): ${confirmed}\nDocument Source:\n\\`\\`\\`\n${confirmed}\n\\`\\`\\`\n\n## Source Code\n### Free as in _freedom_.\nLabs: https://github.com/FabricLabs\n\nTo edit this message, visit this URL: https://github.com/FabricLabs/fabric/edit/master/types/state.js\n\n## Onboarding\nWhen you're ready to continue, visit the following URL: https://dev.fabric.pub/WELCOME.html\n`;\n\n    return raw;\n  }\n\n  /**\n   * Unmarshall an existing state to an instance of a {@link Blob}.\n   * @return {String} Serialized {@link Blob}.\n   */\n  toString () {\n    return this.serialize();\n  }\n\n  overlay (data) {\n    let state = new State(data);\n    this['@parent'] = this['@id'];\n    this['@data'] = Object.assign({}, this['@data'], state['@data']);\n    this['@did'] = `did:fabric:${this.id}`;\n    this['@id'] = this.id;\n    return this;\n  }\n\n  pack (data) {\n    if (!data) data = this['@data'];\n    return JSON.stringify(data);\n  }\n\n  /**\n   * Convert to {@link Buffer}.\n   * @param  {Mixed} [input] Input to serialize.\n   * @return {Buffer}       {@link Store}-able blob.\n   */\n  serialize (input, encoding = 'json') {\n    if (!input) input = this['@data'];\n\n    let result = null;\n    let state = {};\n\n    if (typeof input === 'string') {\n      result = Buffer.from(`${JSON.stringify(input)}`, 'utf8');\n    } else if (input instanceof Array) {\n      result = Buffer.from(`${JSON.stringify(input)}`, 'utf8');\n    } else if (input instanceof Buffer) {\n      result = input;\n    } else if (input['@type'] && input['@data']) {\n      return this.serialize(input['@data']);\n    } else {\n      switch (input.constructor.name) {\n        default:\n          result = input.toString('utf8');\n          break;\n        case 'Function':\n          result = Buffer.from(input.toString('utf8'));\n          break;\n        case 'Boolean':\n          result = Buffer.from(JSON.stringify(input));\n          break;\n        case 'Buffer':\n          result = Buffer.from(JSON.stringify(input.toString('utf8')));\n          break;\n        case 'Object':\n          result = Buffer.from(JSON.stringify(input));\n      }\n\n      // strip special fields\n      // TODO: order?\n      for (let name in input) {\n        if (name.charAt(0) === '@') {\n          continue;\n        } else {\n          state[name] = input[name];\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Take a hex-encoded input and convert to a {@link State} object.\n   * @param  {String} input [description]\n   * @return {State}       [description]\n   */\n  deserialize (input) {\n    let output = null;\n\n    if (typeof input === 'string') {\n      // Let's create a state object...\n      try {\n        let state = new State(input);\n        // Assign our output to the state data\n        output = state['@data'];\n      } catch (E) {\n        this.error('Could not parse string as Buffer:', E);\n      }\n\n      return output;\n    } else {\n      this.log('WARNING:', `input not a string`, input);\n    }\n\n    if (!output) return null;\n\n    switch (output['@type']) {\n      case 'String':\n        output = output['@buffer'].toString(output['@encoding']);\n        break;\n    }\n\n    return output;\n  }\n\n  flatten () {\n    let map = {};\n\n    for (let k in this['@data']) {\n      map[k] = this.serialize(this['@data'][k]);\n    }\n\n    return map;\n  }\n\n  /**\n   * Creates a new child {@link State}, with `@parent` set to\n   * the current {@link State} by immutable identifier.\n   * @returns {State}\n   */\n  fork () {\n    let data = Object.assign({\n      '@parent': this.id\n    }, this['@data']);\n    return new State(data);\n  }\n\n  /**\n   * Retrieve a key from the {@link State}.\n   * @param {Path} path Key to retrieve.\n   * @returns {Mixed}\n   */\n  get (path) {\n    // return pointer.get(this.state, path);\n    let result = null;\n    try {\n      result = pointer.get(this['@entity']['@data'], path);\n    } catch (exception) {\n      console.error('[FABRIC:STATE]', 'Could not retrieve path:', path, pointer.get(this['@entity']['@data'], '/'), exception);\n    }\n    return result;\n  }\n\n  /**\n   * Set a key in the {@link State} to a particular value.\n   * @param {Path} path Key to retrieve.\n   * @returns {Mixed}\n   */\n  set (path, value) {\n    // console.log('setting:', path, value);\n    pointer.set(this.value, path, value);\n    pointer.set(this['@entity']['@data'], path, value);\n    let result = pointer.set(this.value, path, value);\n    this.commit();\n    return result;\n  }\n\n  /**\n   * Increment the vector clock, broadcast all changes as a transaction.\n   */\n  commit () {\n    ++this.clock;\n\n    this['@parent'] = this.id;\n    this['@preimage'] = this.toString();\n    this['@constructor'] = this.constructor;\n\n    if (this.observer) {\n      this['@changes'] = monitor.generate(this.observer);\n    }\n\n    this['@id'] = this.id;\n\n    if (this['@changes'] && this['@changes'].length) {\n      this.emit('changes', this['@changes']);\n      this.emit('state', this['@state']);\n      this.emit('message', {\n        '@type': 'Transaction',\n        '@data': {\n          'changes': this['@changes'],\n          'state': this['@changes']\n        }\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Compose a JSON string for network consumption.\n   * @return {String} JSON-encoded {@link String}.\n   */\n  render () {\n    this['@id'] = this.id;\n    this['@encoding'] = 'json';\n    this['@output'] = this.serialize(this['@entity']['@data'], 'json');\n    this['@commit'] = this.commit();\n\n    switch (this['@type']) {\n      default:\n        return this['@output'].toString('utf8');\n    }\n  }\n}\n\nmodule.exports = State;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://Fabric/./types/state.js?");
./assets/service.js:eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\n\nconst Scribe = __webpack_require__(/*! ./scribe */ \"./types/scribe.js\");\nconst Stack = __webpack_require__(/*! ./stack */ \"./types/stack.js\");\n\nclass Vector extends Scribe {\n  /**\n   * An \"Initialization\" Vector.\n   * @param       {Object} - Input state (will map to `@data`.)\n   * @constructor\n   */\n  constructor (origin) {\n    super(origin);\n\n    this.config = Object.assign({}, origin);\n\n    this.known = {};\n    this.registry = {};\n\n    this.stack = new Stack();\n    this.script = [];\n\n    this.status = 'initialized';\n\n    return this;\n  }\n\n  static fromObjectString (input) {\n    let result = [];\n    let object = JSON.parse(input);\n\n    for (let i in object) {\n      let element = object[i];\n\n      if (element instanceof Array) {\n        element = Buffer.from(element);\n      } else {\n        element = Buffer.from(element.data);\n      }\n\n      result.push(element);\n    }\n\n    return result;\n  }\n\n  /**\n   * _serialize is a placeholder, should be discussed.\n   * @param {String} input - What to serialize.  Defaults to `this.state`.\n   * @return {String} - resulting string [JSON-encoded version of the local `@data` value.]\n   */\n  _serialize (input) {\n    return this.toString(input);\n  }\n\n  _deserialize (input) {\n    return this.fromString(input);\n  }\n\n  // TODO: standardize on a serialization format\n  fromString (input) {\n    return JSON.parse(input);\n  }\n\n  toObject () {\n    let object = {};\n    for (let property in this['@data']) {\n      if (property.charAt(0) !== '@') {\n        object[property] = this['@data'][property];\n      }\n    }\n    return object;\n  }\n\n  /**\n   * Render the output to a {@link String}.\n   * @param  {Mixed} input Arbitrary input.\n   * @return {String}\n   */\n  toString (input) {\n    if (!input) input = this.state;\n    // TODO: standardize on a serialization format\n    return JSON.stringify(input);\n  }\n\n  validate (input) {\n    return true;\n  }\n\n  async step () {\n    return super.compute((this.clock | 0));\n  }\n}\n\nmodule.exports = Vector;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://Fabric/./types/vector.js?");
./assets/examples/oracle.html:              <p>TODO: use bottom panel for inline execution (<em>a la</em> “Run this Code &raquo;”)</p>
./assets/examples/service.html:              <p>TODO: revert to OPTIONS (this was a temporary fix for an NGINX bug)</p>
./assets/examples/game.html:              <p>TODO: use fabric call
./assets/examples/blockchain.html:              <p>TODO: disconnect peers</p>
./assets/examples/cli_jade.html:              <p>TODO: use deep assign</p>
./assets/examples/cli_jade.html:              <p>TODO: move to lib/chat.js</p>
./assets/examples/cli_jade.html:              <p>TODO: visual indicator of “sending…” status</p>
./assets/samples.js:      alias: 'Nickname?', // TODO: CLI to prompt for Commit
./assets/fabric.min.js:eval("/*\n  Fabric Core Constants.\n  ---\n  Author: Fabric Labs\n  Copyright: All Rights Reserved.\n */\n\n\nconst PEER_PORT = 9999;\nconst MAX_PEERS = 32;\n\nconst PRECISION = 100;\n\nconst MAGIC_BYTES = 0xC0D3F33D;\nconst VERSION_NUMBER = 0x01;\nconst BITCOIN_GENESIS = 0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f;\n\nconst HEADER_SIZE = 48; // 32 + 16 bytes\nconst LARGE_COLLECTION_SIZE = 10; // TODO: test with 1,000,000\nconst MAX_MESSAGE_SIZE = 4096 - HEADER_SIZE;\n\nconst MAX_STACK_HEIGHT = 32; // max height of stack (number of elements)\nconst MAX_FRAME_SIZE = 32; // max size of a stack frame in bytes\nconst MAX_MEMORY_ALLOC = MAX_STACK_HEIGHT * MAX_FRAME_SIZE;\nconst MAX_CHANNEL_VALUE = 100000000;\n\n// FABRIC ONLY\nconst OP_CYCLE = '00';\nconst OP_DONE = 'ff';\n\n// Bitcoin\nconst OP_0 = '00';\nconst OP_36 = '24';\nconst OP_CHECKSIG = 'ac';\nconst OP_DUP = '76';\nconst OP_EQUAL = '87';\nconst OP_SHA256 = 'a8';\nconst OP_HASH160 = 'a9';\nconst OP_PUSHDATA1 = '4c';\nconst OP_RETURN = '6a';\nconst OP_EQUALVERIFY = '88';\nconst OP_SEPARATOR = 'ab';\n\nconst P2P_GENERIC = 0x80; // 128 in decimal\nconst P2P_IDENT_REQUEST = 0x01; // 1, or the identity\nconst P2P_IDENT_RESPONSE = 0x11;\nconst P2P_ROOT = 0x00000000;\nconst P2P_PING = 0x00000012; // same ID as Lightning (18)\nconst P2P_PONG = 0x00000013; // same ID as Lightning (19)\nconst P2P_INSTRUCTION = 0x00000020; // TODO: select w/ no overlap\nconst P2P_START_CHAIN = 0x00000021;\nconst P2P_STATE_REQUEST = 0x00000029; // TODO: select w/ no overlap\nconst P2P_STATE_ROOT = 0x00000030; // TODO: select w/ no overlap\nconst P2P_BASE_MESSAGE = 0x00000031; // TODO: select w/ no overlap\nconst P2P_STATE_COMMITTMENT = 0x00000032; // TODO: select w/ no overlap\nconst P2P_STATE_CHANGE = 0x00000033; // TODO: select w/ no overlap\nconst P2P_TRANSACTION = 0x00000039; // TODO: select w/ no overlap\nconst P2P_CALL = 0x00000042;\nconst P2P_CHAIN_SYNC_REQUEST = 0x55;\n\nconst PEER_CANDIDATE = 0x09;\n// TODO: should be 0x02 for Bitcoin P2P\nconst BLOCK_CANDIDATE = 0x03;\n\nconst SESSION_START = 0x02;\nconst CHAT_MESSAGE = 0x67;\n\n// Lightning\nconst LIGHTNING_TEST_HEADER = 'D0520C6E';\nconst LIGHTNING_PROTOCOL_H_INIT = 'Noise_XK_secp256k1_ChaChaPoly_SHA256';\nconst LIGHTNING_PROTOCOL_PROLOGUE = 'lightning';\n\n// Lightning BMM\nconst LIGHTNING_BMM_HEADER = 'D0520C6E';\nconst LIGHTNING_SIDECHAIN_NUM = 0xFF; // 1-byte - sidechain number\n\nconst LIGHTNING_SIDEBLOCK_HASH = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000; // 32-bytes\nconst LIGHTNING_PARENT_SIDEBLOCK_HASH = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001; // 32-bytes\n\nconst ZERO_LENGTH_PLAINTEXT = '';\n\nmodule.exports = {\n  PEER_PORT,\n  MAX_PEERS,\n  PRECISION,\n  BITCOIN_GENESIS,\n  HEADER_SIZE,\n  LARGE_COLLECTION_SIZE,\n  BLOCK_CANDIDATE,\n  CHAT_MESSAGE,\n  ZERO_LENGTH_PLAINTEXT,\n  LIGHTNING_TEST_HEADER,\n  LIGHTNING_PROTOCOL_H_INIT,\n  LIGHTNING_PROTOCOL_PROLOGUE,\n  LIGHTNING_BMM_HEADER,\n  LIGHTNING_SIDECHAIN_NUM,\n  LIGHTNING_SIDEBLOCK_HASH,\n  LIGHTNING_PARENT_SIDEBLOCK_HASH,\n  MAGIC_BYTES,\n  MAX_FRAME_SIZE,\n  MAX_MEMORY_ALLOC,\n  MAX_MESSAGE_SIZE,\n  MAX_STACK_HEIGHT,\n  MAX_CHANNEL_VALUE,\n  OP_CYCLE,\n  OP_DONE,\n  OP_0,\n  OP_36,\n  OP_CHECKSIG,\n  OP_DUP,\n  OP_EQUAL,\n  OP_SHA256,\n  OP_HASH160,\n  OP_PUSHDATA1,\n  OP_RETURN,\n  OP_EQUALVERIFY,\n  OP_SEPARATOR,\n  P2P_GENERIC,\n  P2P_IDENT_REQUEST,\n  P2P_IDENT_RESPONSE,\n  P2P_CHAIN_SYNC_REQUEST,\n  P2P_ROOT,\n  P2P_PING,\n  P2P_PONG,\n  P2P_START_CHAIN,\n  P2P_INSTRUCTION,\n  P2P_BASE_MESSAGE,\n  P2P_STATE_ROOT,\n  P2P_STATE_COMMITTMENT,\n  P2P_STATE_CHANGE,\n  P2P_STATE_REQUEST,\n  P2P_TRANSACTION,\n  P2P_CALL,\n  PEER_CANDIDATE,\n  SESSION_START,\n  VERSION_NUMBER\n};\n\n\n//# sourceURL=webpack://Fabric/./constants.js?");
./assets/fabric.min.js:eval("var require;var require;(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _Long = require('./Long');\n\nvar _Long2 = _interopRequireDefault(_Long);\n\nvar _MaxU = require('./MaxU32');\n\nvar _MaxU2 = _interopRequireDefault(_MaxU);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// See https://en.wikipedia.org/wiki/Linear_congruential_generator#Period_length\n// for why we picked these numbers. We copied the 'Numerical Recipes' numbers from here\n// https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use\n// Creates a period length of [0, 2^32 - 1 ]\nvar c = 1013904223;\nvar m = 4294967296; // = Math.pow(2,32);\nvar a = 1664525;\n\n// This is the inverse of 'a' above for modolo multiplicative needed for calculating\n// the inverse of the standard linear congruent generator state update function.\n// For a good primer/starting point, see: http://stackoverflow.com/a/16630535.\n// The contribution of this library is making this approach work in Javascript\n// which has bit operators, multiplication, and modolo operation semantics\n// different than the 2s-complement integer math of languages like C/C++\nvar aInverse = -18851643;\n\nvar Generator = function () {\n\n    // Creates a new Generator\n    // takes a seed or defaults to Math.random()\n    function Generator(seed) {\n        _classCallCheck(this, Generator);\n\n        seed = seed || Math.floor(Math.random() * _MaxU2.default);\n        this.state = seed;\n    }\n\n    /**\n     * @returns A number between the [0, 1);\n     */\n\n\n    _createClass(Generator, [{\n        key: 'percent',\n        value: function percent() {\n            return this._state / _MaxU2.default;\n        }\n\n        /**\n         * @min (optional) Lowest value \n         * @max (optional) Highest value\n         * @returns A float between the min/max\n         * \n         * Note: \n         *  - If 0 args are passed, range is [0.0, 1.0]\n         *  - If 1 arg is passed, range is [0.0, max]\n         *  - If 2 args are passed, range is [min, max]\n         */\n\n    }, {\n        key: 'number',\n        value: function number(min, max) {\n            if (arguments.length === 0) {\n                min = 0.0;\n                max = 1.0;\n            } else if (arguments.length === 1) {\n                min = 0.0;\n                max = min;\n            } else if (arguments.length === 2) {\n                // Do nothing, min and max are set\n            } else {\n                throw new Error(\"Generator.number() only takes up to 2 parameters\");\n            }\n            return this._state / _MaxU2.default * (max - min) + min;\n        }\n\n        /**\n         * /**\n         * @min (optional) Lowest value \n         * @max (optional) Highest value\n         * @returns An integer between the min/max\n         * \n         * Note: \n         *  - If 0 args are passed, range is [0, Math.pow(2, 32)]\n         *  - If 1 arg is passed, range is [0, max]\n         *  - If 2 args are passed, range is [min, max]\n         */\n\n    }, {\n        key: 'integer',\n        value: function integer(min, max) {\n            if (arguments.length === 0) {\n                min = 0;\n                max = _MaxU2.default;\n            } else if (arguments.length === 1) {\n                min = 0;\n                max = min;\n            } else if (arguments.length === 2) {\n                // Do nothing, min and max are set\n            } else {\n                throw new Error(\"Generator.integer() only takes up to 2 parameters\");\n            }\n\n            return Math.floor(this._state / _MaxU2.default * (max - min) + min);\n        }\n\n        /**\n         * @returns A u32 between the min/max;\n         */\n        /*u32(min, max){\n            if(arguments.length === 0){\n                return this._state;\n            }\n            // TODO: Put in constraints that guarantee if it's an integer,\n            // that min/max are integers, and that the result and min/max\n            // are in the allowed range of values for u32s\n            return Math.floor( this.number(min, max) );\n        }*/\n\n        /**\n         * Generate random bits. Up to 32, this is intended for 32 bit bit\n         * operation use cases\n         */\n\n    }, {\n        key: 'bits',\n        value: function bits(bitCount) {\n            if (bitCount <= 0 || bitCount > 32) {\n                throw new Error('Generator.bits()\\'s bitCount parameter must be in the range [1 - 32]. Provided bitCount=' + bitCount);\n            }\n            // Use the higher bits as the lower bits have a low period. I haven't looked into the exact\n            // math of why, but in my tests in masking off the lower bits and graphing them it tended\n            // to loop very quickly.\n            // TODO: Test the above concern and in general do some analysis of the quality of generated\n            // numbers using different places of the number.\n            return this._state >>> 32 - bitCount;\n        }\n\n        // Move the generators internal state\n        // forward one step\n\n    }, {\n        key: 'next',\n        get: function get() {\n            this._state = lcg(this._state);\n            return this;\n        }\n\n        // Move the generators internal state\n        // forward one step\n\n    }, {\n        key: 'prev',\n        get: function get() {\n            this._state = rlcg(this._state);\n            return this;\n        }\n\n        // Set the state of the generator. Must be a valid u32 integer\n\n    }, {\n        key: 'state',\n        set: function set(state) {\n            if (state < 0 || state >= _MaxU2.default) {\n                throw new Error('Generator.state must be a number between 0 and (2^32 - 1). Provided state was ' + state + '.');\n            }\n            this._state = state;\n        }\n\n        // Get the current internal state\n        ,\n        get: function get() {\n            return this._state;\n        }\n    }]);\n\n    return Generator;\n}();\n\nexports.default = Generator;\n\n\nfunction lcg(state) {\n    state = (a * state + c) % m;\n    return state;\n}\n\nfunction rlcg(state) {\n    var result = _Long2.default.fromInt(aInverse).multiply(_Long2.default.fromNumber(state - 1013904223)); //\n    var pow2to32 = new _Long2.default(0, 1);\n\n    // Modulo doesn't work as we want (negatives stay negatives, we want wrapping around )\n    if (result.isNegative()) {\n        result = pow2to32.add(result.modulo(pow2to32));\n    } else {\n        result = result.modulo(pow2to32);\n    }\n\n    result = result.toNumber();\n    state = result;\n    return state;\n}\n\n},{\"./Long\":2,\"./MaxU32\":3}],2:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// Copyright 2009 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Defines a Long class for representing a 64-bit two's-complement\n * integer value, which faithfully simulates the behavior of a Java \"long\". This\n * implementation is derived from LongLib in GWT.\n *\n */\n\n/**\n * Constructs a 64-bit two's-complement integer, given its low and high 32-bit\n * values as *signed* integers.  See the from* functions below for more\n * convenient ways of constructing Longs.\n *\n * The internal representation of a long is the two given signed, 32-bit values.\n * We use 32-bit pieces because these are the size of integers on which\n * Javascript performs bit-operations.  For operations like addition and\n * multiplication, we split each number into 16-bit pieces, which can easily be\n * multiplied within Javascript's floating-point representation without overflow\n * or change in sign.\n *\n * In the algorithms below, we frequently reduce the negative case to the\n * positive case by negating the input(s) and then post-processing the result.\n * Note that we must ALWAYS check specially whether those values are MIN_VALUE\n * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n * a positive number, it overflows back into a negative).  Not handling this\n * case would often result in infinite recursion.\n *\n * @param {number} low  The low (signed) 32 bits of the long.\n * @param {number} high  The high (signed) 32 bits of the long.\n * @struct\n * @constructor\n * @final\n */\nvar Long = function Long(low, high) {\n  /**\n   * @type {number}\n   * @private\n   */\n  this.low_ = low | 0; // force into 32 signed bits.\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.high_ = high | 0; // force into 32 signed bits.\n};\n\n/**\n * Returns a Long representing the given (32-bit) integer value.\n * @param {number} value The 32-bit integer in question.\n * @return {!Long} The corresponding Long value.\n */\nLong.fromInt = function (value) {\n  return new Long(value | 0, value < 0 ? -1 : 0);\n};\n\n/**\n * Returns a Long representing the given value.\n * NaN will be returned as zero. Infinity is converted to max value and\n * -Infinity to min value.\n * @param {number} value The number in question.\n * @return {!Long} The corresponding Long value.\n */\nLong.fromNumber = function (value) {\n  if (isNaN(value)) {\n    return Long.getZero();\n  } else if (value <= -Long.TWO_PWR_63_DBL_) {\n    return Long.getMinValue();\n  } else if (value + 1 >= Long.TWO_PWR_63_DBL_) {\n    return Long.getMaxValue();\n  } else if (value < 0) {\n    return Long.fromNumber(-value).negate();\n  } else {\n    return new Long(value % Long.TWO_PWR_32_DBL_ | 0, value / Long.TWO_PWR_32_DBL_ | 0);\n  }\n};\n\n/**\n * Returns a Long representing the 64-bit integer that comes by concatenating\n * the given high and low bits.  Each is assumed to use 32 bits.\n * @param {number} lowBits The low 32-bits.\n * @param {number} highBits The high 32-bits.\n * @return {!Long} The corresponding Long value.\n */\nLong.fromBits = function (lowBits, highBits) {\n  return new Long(lowBits, highBits);\n};\n\n/**\n * Returns a Long representation of the given string, written using the given\n * radix.\n * @param {string} str The textual representation of the Long.\n * @param {number=} opt_radix The radix in which the text is written.\n * @return {!Long} The corresponding Long value.\n */\nLong.fromString = function (str, opt_radix) {\n  if (str.length == 0) {\n    throw Error('number format error: empty string');\n  }\n\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (str.charAt(0) == '-') {\n    return Long.fromString(str.substring(1), radix).negate();\n  } else if (str.indexOf('-') >= 0) {\n    throw Error('number format error: interior \"-\" character: ' + str);\n  }\n\n  // Do several (8) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Long.fromNumber(Math.pow(radix, 8));\n\n  var result = Long.getZero();\n  for (var i = 0; i < str.length; i += 8) {\n    var size = Math.min(8, str.length - i);\n    var value = parseInt(str.substring(i, i + size), radix);\n    if (size < 8) {\n      var power = Long.fromNumber(Math.pow(radix, size));\n      result = result.multiply(power).add(Long.fromNumber(value));\n    } else {\n      result = result.multiply(radixToPower);\n      result = result.add(Long.fromNumber(value));\n    }\n  }\n  return result;\n};\n\n// NOTE: the compiler should inline these constant values below and then remove\n// these variables, so there should be no runtime penalty for these.\n\n\n/**\n * Number used repeated below in calculations.  This must appear before the\n * first call to any from* function below.\n * @type {number}\n * @private\n */\nLong.TWO_PWR_16_DBL_ = 1 << 16;\n\n/**\n * @type {number}\n * @private\n */\nLong.TWO_PWR_32_DBL_ = Long.TWO_PWR_16_DBL_ * Long.TWO_PWR_16_DBL_;\n\n/**\n * @type {number}\n * @private\n */\nLong.TWO_PWR_64_DBL_ = Long.TWO_PWR_32_DBL_ * Long.TWO_PWR_32_DBL_;\n\n/**\n * @type {number}\n * @private\n */\nLong.TWO_PWR_63_DBL_ = Long.TWO_PWR_64_DBL_ / 2;\n\n/**\n * @return {!Long}\n * @public\n */\nLong.getZero = function () {\n  return Long.fromInt(0);\n};\n\n/**\n * @return {!Long}\n * @public\n */\nLong.getOne = function () {\n  return Long.fromInt(1);\n};\n\n/**\n * @return {!Long}\n * @public\n */\nLong.getNegOne = function () {\n  return Long.fromInt(-1);\n};\n\n/**\n * @return {!Long}\n * @public\n */\nLong.getMaxValue = function () {\n  return Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);\n};\n\n/**\n * @return {!Long}\n * @public\n */\nLong.getMinValue = function () {\n  return Long.fromBits(0, 0x80000000 | 0);\n};\n\n/**\n * @return {!Long}\n * @public\n */\nLong.getTwoPwr24 = function () {\n  return Long.fromInt(1 << 24);\n};\n\n/** @return {number} The value, assuming it is a 32-bit integer. */\nLong.prototype.toInt = function () {\n  return this.low_;\n};\n\n/** @return {number} The closest floating-point representation to this value. */\nLong.prototype.toNumber = function () {\n  return this.high_ * Long.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();\n};\n\n/**\n * @param {number=} opt_radix The radix in which the text should be written.\n * @return {string} The textual representation of this value.\n * @override\n */\nLong.prototype.toString = function (opt_radix) {\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (this.isZero()) {\n    return '0';\n  }\n\n  if (this.isNegative()) {\n    if (this.equals(Long.getMinValue())) {\n      // We need to change the Long value before it can be negated, so we remove\n      // the bottom-most digit in this base and then recurse to do the rest.\n      var radixLong = Long.fromNumber(radix);\n      var div = this.div(radixLong);\n      var rem = div.multiply(radixLong).subtract(this);\n      return div.toString(radix) + rem.toInt().toString(radix);\n    } else {\n      return '-' + this.negate().toString(radix);\n    }\n  }\n\n  // Do several (6) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Long.fromNumber(Math.pow(radix, 6));\n\n  var rem = this;\n  var result = '';\n  while (true) {\n    var remDiv = rem.div(radixToPower);\n    // The right shifting fixes negative values in the case when\n    // intval >= 2^31; for more details see\n    // https://github.com/google/closure-library/pull/498\n    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt() >>> 0;\n    var digits = intval.toString(radix);\n\n    rem = remDiv;\n    if (rem.isZero()) {\n      return digits + result;\n    } else {\n      while (digits.length < 6) {\n        digits = '0' + digits;\n      }\n      result = '' + digits + result;\n    }\n  }\n};\n\n/** @return {number} The high 32-bits as a signed value. */\nLong.prototype.getHighBits = function () {\n  return this.high_;\n};\n\n/** @return {number} The low 32-bits as a signed value. */\nLong.prototype.getLowBits = function () {\n  return this.low_;\n};\n\n/** @return {number} The low 32-bits as an unsigned value. */\nLong.prototype.getLowBitsUnsigned = function () {\n  return this.low_ >= 0 ? this.low_ : Long.TWO_PWR_32_DBL_ + this.low_;\n};\n\n/**\n * @return {number} Returns the number of bits needed to represent the absolute\n *     value of this Long.\n */\nLong.prototype.getNumBitsAbs = function () {\n  if (this.isNegative()) {\n    if (this.equals(Long.getMinValue())) {\n      return 64;\n    } else {\n      return this.negate().getNumBitsAbs();\n    }\n  } else {\n    var val = this.high_ != 0 ? this.high_ : this.low_;\n    for (var bit = 31; bit > 0; bit--) {\n      if ((val & 1 << bit) != 0) {\n        break;\n      }\n    }\n    return this.high_ != 0 ? bit + 33 : bit + 1;\n  }\n};\n\n/** @return {boolean} Whether this value is zero. */\nLong.prototype.isZero = function () {\n  return this.high_ == 0 && this.low_ == 0;\n};\n\n/** @return {boolean} Whether this value is negative. */\nLong.prototype.isNegative = function () {\n  return this.high_ < 0;\n};\n\n/** @return {boolean} Whether this value is odd. */\nLong.prototype.isOdd = function () {\n  return (this.low_ & 1) == 1;\n};\n\n/**\n * @param {Long} other Long to compare against.\n * @return {boolean} Whether this Long equals the other.\n */\nLong.prototype.equals = function (other) {\n  return this.high_ == other.high_ && this.low_ == other.low_;\n};\n\n/**\n * @param {Long} other Long to compare against.\n * @return {boolean} Whether this Long does not equal the other.\n */\nLong.prototype.notEquals = function (other) {\n  return this.high_ != other.high_ || this.low_ != other.low_;\n};\n\n/**\n * @param {Long} other Long to compare against.\n * @return {boolean} Whether this Long is less than the other.\n */\nLong.prototype.lessThan = function (other) {\n  return this.compare(other) < 0;\n};\n\n/**\n * @param {Long} other Long to compare against.\n * @return {boolean} Whether this Long is less than or equal to the other.\n */\nLong.prototype.lessThanOrEqual = function (other) {\n  return this.compare(other) <= 0;\n};\n\n/**\n * @param {Long} other Long to compare against.\n * @return {boolean} Whether this Long is greater than the other.\n */\nLong.prototype.greaterThan = function (other) {\n  return this.compare(other) > 0;\n};\n\n/**\n * @param {Long} other Long to compare against.\n * @return {boolean} Whether this Long is greater than or equal to the other.\n */\nLong.prototype.greaterThanOrEqual = function (other) {\n  return this.compare(other) >= 0;\n};\n\n/**\n * Compares this Long with the given one.\n * @param {Long} other Long to compare against.\n * @return {number} 0 if they are the same, 1 if the this is greater, and -1\n *     if the given one is greater.\n */\nLong.prototype.compare = function (other) {\n  if (this.equals(other)) {\n    return 0;\n  }\n\n  var thisNeg = this.isNegative();\n  var otherNeg = other.isNegative();\n  if (thisNeg && !otherNeg) {\n    return -1;\n  }\n  if (!thisNeg && otherNeg) {\n    return 1;\n  }\n\n  // at this point, the signs are the same, so subtraction will not overflow\n  if (this.subtract(other).isNegative()) {\n    return -1;\n  } else {\n    return 1;\n  }\n};\n\n/** @return {!Long} The negation of this value. */\nLong.prototype.negate = function () {\n  if (this.equals(Long.getMinValue())) {\n    return Long.getMinValue();\n  } else {\n    return this.not().add(Long.getOne());\n  }\n};\n\n/**\n * Returns the sum of this and the given Long.\n * @param {Long} other Long to add to this one.\n * @return {!Long} The sum of this and the given Long.\n */\nLong.prototype.add = function (other) {\n  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n  var a48 = this.high_ >>> 16;\n  var a32 = this.high_ & 0xFFFF;\n  var a16 = this.low_ >>> 16;\n  var a00 = this.low_ & 0xFFFF;\n\n  var b48 = other.high_ >>> 16;\n  var b32 = other.high_ & 0xFFFF;\n  var b16 = other.low_ >>> 16;\n  var b00 = other.low_ & 0xFFFF;\n\n  var c48 = 0,\n      c32 = 0,\n      c16 = 0,\n      c00 = 0;\n  c00 += a00 + b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 + b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 + b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 + b48;\n  c48 &= 0xFFFF;\n  return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32);\n};\n\n/**\n * Returns the difference of this and the given Long.\n * @param {Long} other Long to subtract from this.\n * @return {!Long} The difference of this and the given Long.\n */\nLong.prototype.subtract = function (other) {\n  return this.add(other.negate());\n};\n\n/**\n * Returns the product of this and the given long.\n * @param {Long} other Long to multiply with this.\n * @return {!Long} The product of this and the other.\n */\nLong.prototype.multiply = function (other) {\n  if (this.isZero()) {\n    return Long.getZero();\n  } else if (other.isZero()) {\n    return Long.getZero();\n  }\n\n  if (this.equals(Long.getMinValue())) {\n    return other.isOdd() ? Long.getMinValue() : Long.getZero();\n  } else if (other.equals(Long.getMinValue())) {\n    return this.isOdd() ? Long.getMinValue() : Long.getZero();\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().multiply(other.negate());\n    } else {\n      return this.negate().multiply(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.multiply(other.negate()).negate();\n  }\n\n  // If both longs are small, use float multiplication\n  if (this.lessThan(Long.getTwoPwr24()) && other.lessThan(Long.getTwoPwr24())) {\n    return Long.fromNumber(this.toNumber() * other.toNumber());\n  }\n\n  // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n  // We can skip products that would overflow.\n\n  var a48 = this.high_ >>> 16;\n  var a32 = this.high_ & 0xFFFF;\n  var a16 = this.low_ >>> 16;\n  var a00 = this.low_ & 0xFFFF;\n\n  var b48 = other.high_ >>> 16;\n  var b32 = other.high_ & 0xFFFF;\n  var b16 = other.low_ >>> 16;\n  var b00 = other.low_ & 0xFFFF;\n\n  var c48 = 0,\n      c32 = 0,\n      c16 = 0,\n      c00 = 0;\n  c00 += a00 * b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 * b00;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c16 += a00 * b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 * b00;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a16 * b16;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a00 * b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n  c48 &= 0xFFFF;\n  return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32);\n};\n\n/**\n * Returns this Long divided by the given one.\n * @param {Long} other Long by which to divide.\n * @return {!Long} This Long divided by the given one.\n */\nLong.prototype.div = function (other) {\n  if (other.isZero()) {\n    throw Error('division by zero');\n  } else if (this.isZero()) {\n    return Long.getZero();\n  }\n\n  if (this.equals(Long.getMinValue())) {\n    if (other.equals(Long.getOne()) || other.equals(Long.getNegOne())) {\n      return Long.getMinValue(); // recall -MIN_VALUE == MIN_VALUE\n    } else if (other.equals(Long.getMinValue())) {\n      return Long.getOne();\n    } else {\n      // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n      var halfThis = this.shiftRight(1);\n      var approx = halfThis.div(other).shiftLeft(1);\n      if (approx.equals(Long.getZero())) {\n        return other.isNegative() ? Long.getOne() : Long.getNegOne();\n      } else {\n        var rem = this.subtract(other.multiply(approx));\n        var result = approx.add(rem.div(other));\n        return result;\n      }\n    }\n  } else if (other.equals(Long.getMinValue())) {\n    return Long.getZero();\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().div(other.negate());\n    } else {\n      return this.negate().div(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.div(other.negate()).negate();\n  }\n\n  // Repeat the following until the remainder is less than other:  find a\n  // floating-point that approximates remainder / other *from below*, add this\n  // into the result, and subtract it from the remainder.  It is critical that\n  // the approximate value is less than or equal to the real value so that the\n  // remainder never becomes negative.\n  var res = Long.getZero();\n  var rem = this;\n  while (rem.greaterThanOrEqual(other)) {\n    // Approximate the result of division. This may be a little greater or\n    // smaller than the actual value.\n    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));\n\n    // We will tweak the approximate result by changing it in the 48-th digit or\n    // the smallest non-fractional digit, whichever is larger.\n    var log2 = Math.ceil(Math.log(approx) / Math.LN2);\n    var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);\n\n    // Decrease the approximation until it is smaller than the remainder.  Note\n    // that if it is too large, the product overflows and is negative.\n    var approxRes = Long.fromNumber(approx);\n    var approxRem = approxRes.multiply(other);\n    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {\n      approx -= delta;\n      approxRes = Long.fromNumber(approx);\n      approxRem = approxRes.multiply(other);\n    }\n\n    // We know the answer can't be zero... and actually, zero would cause\n    // infinite recursion since we would make no progress.\n    if (approxRes.isZero()) {\n      approxRes = Long.getOne();\n    }\n\n    res = res.add(approxRes);\n    rem = rem.subtract(approxRem);\n  }\n  return res;\n};\n\n/**\n * Returns this Long modulo the given one.\n * @param {Long} other Long by which to mod.\n * @return {!Long} This Long modulo the given one.\n */\nLong.prototype.modulo = function (other) {\n  return this.subtract(this.div(other).multiply(other));\n};\n\n/** @return {!Long} The bitwise-NOT of this value. */\nLong.prototype.not = function () {\n  return Long.fromBits(~this.low_, ~this.high_);\n};\n\n/**\n * Returns the bitwise-AND of this Long and the given one.\n * @param {Long} other The Long with which to AND.\n * @return {!Long} The bitwise-AND of this and the other.\n */\nLong.prototype.and = function (other) {\n  return Long.fromBits(this.low_ & other.low_, this.high_ & other.high_);\n};\n\n/**\n * Returns the bitwise-OR of this Long and the given one.\n * @param {Long} other The Long with which to OR.\n * @return {!Long} The bitwise-OR of this and the other.\n */\nLong.prototype.or = function (other) {\n  return Long.fromBits(this.low_ | other.low_, this.high_ | other.high_);\n};\n\n/**\n * Returns the bitwise-XOR of this Long and the given one.\n * @param {Long} other The Long with which to XOR.\n * @return {!Long} The bitwise-XOR of this and the other.\n */\nLong.prototype.xor = function (other) {\n  return Long.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);\n};\n\n/**\n * Returns this Long with bits shifted to the left by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Long} This shifted to the left by the given amount.\n */\nLong.prototype.shiftLeft = function (numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var low = this.low_;\n    if (numBits < 32) {\n      var high = this.high_;\n      return Long.fromBits(low << numBits, high << numBits | low >>> 32 - numBits);\n    } else {\n      return Long.fromBits(0, low << numBits - 32);\n    }\n  }\n};\n\n/**\n * Returns this Long with bits shifted to the right by the given amount.\n * The new leading bits match the current sign bit.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Long} This shifted to the right by the given amount.\n */\nLong.prototype.shiftRight = function (numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var high = this.high_;\n    if (numBits < 32) {\n      var low = this.low_;\n      return Long.fromBits(low >>> numBits | high << 32 - numBits, high >> numBits);\n    } else {\n      return Long.fromBits(high >> numBits - 32, high >= 0 ? 0 : -1);\n    }\n  }\n};\n\n/**\n * Returns this Long with bits shifted to the right by the given amount, with\n * zeros placed into the new leading bits.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Long} This shifted to the right by the given amount, with\n *     zeros placed into the new leading bits.\n */\nLong.prototype.shiftRightUnsigned = function (numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var high = this.high_;\n    if (numBits < 32) {\n      var low = this.low_;\n      return Long.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits);\n    } else if (numBits == 32) {\n      return Long.fromBits(high, 0);\n    } else {\n      return Long.fromBits(high >>> numBits - 32, 0);\n    }\n  }\n};\n\n/**\n * @enum {number} Ids of commonly requested Long instances.\n * @private\n */\nLong.ValueCacheId_ = {\n  MAX_VALUE: 1,\n  MIN_VALUE: 2,\n  ZERO: 3,\n  ONE: 4,\n  NEG_ONE: 5,\n  TWO_PWR_24: 6\n};\n\nexports.default = Long;\n\n},{}],3:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar MAX_U32 = Math.pow(2, 32);\n\nexports.default = MAX_U32;\n\n},{}],4:[function(require,module,exports){\n\"use strict\";\n\n/*\n   **Francois**:\n   Based on an implementation that's based on further implementations, most significant\n   change is removing the use of Buffers and ArrayBuffers. Original implementation was forked\n   here (hopefully the original repo still exists, to play it safe I've forked it)\n   https://github.com/francoislaberge/node-skip32\n\n   ** Original Comments in skip32.js's implementation **\n   Skip32PureJS.js - public domain javascript implementation of:\n\n   SKIP32 -- 32 bit block cipher based on SKIPJACK.\n   Written by Greg Rose, QUALCOMM Australia, 1999/04/27.\n\n   In common: F-table, G-permutation, key schedule.\n   Different: 24 round feistel structure.\n   Based on:  Unoptimized test implementation of SKIPJACK algorithm\n              Panu Rissanen <bande@lut.fi>\n\n   SKIPJACK and KEA Algorithm Specifications\n   Version 2.0\n   29 May 1998\n\n   Not copyright, no rights reserved.\n*/\nfunction Skip32() {\n  // Francois: I have modified the code to have a hardcoded key. values\n  // were taken from the example code in the node-skip32 project:\n  // https://github.com/0x4139/node-skip32#example\n  this.key = [0x9b, 0x21, 0x96, 0xe, 0x1a, 0xcf, 0x24, 0x5f, 0x14, 0x93];\n};\n\nSkip32.prototype.init = function () {};\n\n// Francois: I have modified the code to remove the use of Buffers and ArrayBuffers\n// so that the code is more portable to other browsers and environments\nvar ftable = [0xa3, 0xd7, 0x09, 0x83, 0xf8, 0x48, 0xf6, 0xf4, 0xb3, 0x21, 0x15, 0x78, 0x99, 0xb1, 0xaf, 0xf9, 0xe7, 0x2d, 0x4d, 0x8a, 0xce, 0x4c, 0xca, 0x2e, 0x52, 0x95, 0xd9, 0x1e, 0x4e, 0x38, 0x44, 0x28, 0x0a, 0xdf, 0x02, 0xa0, 0x17, 0xf1, 0x60, 0x68, 0x12, 0xb7, 0x7a, 0xc3, 0xe9, 0xfa, 0x3d, 0x53, 0x96, 0x84, 0x6b, 0xba, 0xf2, 0x63, 0x9a, 0x19, 0x7c, 0xae, 0xe5, 0xf5, 0xf7, 0x16, 0x6a, 0xa2, 0x39, 0xb6, 0x7b, 0x0f, 0xc1, 0x93, 0x81, 0x1b, 0xee, 0xb4, 0x1a, 0xea, 0xd0, 0x91, 0x2f, 0xb8, 0x55, 0xb9, 0xda, 0x85, 0x3f, 0x41, 0xbf, 0xe0, 0x5a, 0x58, 0x80, 0x5f, 0x66, 0x0b, 0xd8, 0x90, 0x35, 0xd5, 0xc0, 0xa7, 0x33, 0x06, 0x65, 0x69, 0x45, 0x00, 0x94, 0x56, 0x6d, 0x98, 0x9b, 0x76, 0x97, 0xfc, 0xb2, 0xc2, 0xb0, 0xfe, 0xdb, 0x20, 0xe1, 0xeb, 0xd6, 0xe4, 0xdd, 0x47, 0x4a, 0x1d, 0x42, 0xed, 0x9e, 0x6e, 0x49, 0x3c, 0xcd, 0x43, 0x27, 0xd2, 0x07, 0xd4, 0xde, 0xc7, 0x67, 0x18, 0x89, 0xcb, 0x30, 0x1f, 0x8d, 0xc6, 0x8f, 0xaa, 0xc8, 0x74, 0xdc, 0xc9, 0x5d, 0x5c, 0x31, 0xa4, 0x70, 0x88, 0x61, 0x2c, 0x9f, 0x0d, 0x2b, 0x87, 0x50, 0x82, 0x54, 0x64, 0x26, 0x7d, 0x03, 0x40, 0x34, 0x4b, 0x1c, 0x73, 0xd1, 0xc4, 0xfd, 0x3b, 0xcc, 0xfb, 0x7f, 0xab, 0xe6, 0x3e, 0x5b, 0xa5, 0xad, 0x04, 0x23, 0x9c, 0x14, 0x51, 0x22, 0xf0, 0x29, 0x79, 0x71, 0x7e, 0xff, 0x8c, 0x0e, 0xe2, 0x0c, 0xef, 0xbc, 0x72, 0x75, 0x6f, 0x37, 0xa1, 0xec, 0xd3, 0x8e, 0x62, 0x8b, 0x86, 0x10, 0xe8, 0x08, 0x77, 0x11, 0xbe, 0x92, 0x4f, 0x24, 0xc5, 0x32, 0x36, 0x9d, 0xcf, 0xf3, 0xa6, 0xbb, 0xac, 0x5e, 0x6c, 0xa9, 0x13, 0x57, 0x25, 0xb5, 0xe3, 0xbd, 0xa8, 0x3a, 0x01, 0x05, 0x59, 0x2a, 0x46];\n\nSkip32.prototype.round16 = function (k, n) {\n  var g1, g2, g3, g4, g5, g6;\n  g1 = n >> 8 & 0xff;\n  g2 = n >> 0 & 0xff;\n  g3 = ftable[g2 ^ this.key[(4 * k + 0) % 10]] ^ g1;\n  g4 = ftable[g3 ^ this.key[(4 * k + 1) % 10]] ^ g2;\n  g5 = ftable[g4 ^ this.key[(4 * k + 2) % 10]] ^ g3;\n  g6 = ftable[g5 ^ this.key[(4 * k + 3) % 10]] ^ g4;\n  return (g5 << 8) + g6;\n};\n\nSkip32.prototype.core = function (n, k, d) {\n  var i, k, wl, wr;\n  wl = ((n >> 24 & 0xff) << 8) + ((n >> 16 & 0xff) << 0);\n  wr = ((n >> 8 & 0xff) << 8) + ((n >> 0 & 0xff) << 0);\n  for (i = 0; i < 24 / 2; i++) {\n    wr ^= this.round16(k, wl) ^ k;\n    k += d;\n    wl ^= this.round16(k, wr) ^ k;\n    k += d;\n  }\n  return (wr << 16 | wl) >>> 0;\n};\n\nSkip32.prototype.encrypt = function (n) {\n  return this.core(n, 0, 1);\n};\n\nSkip32.prototype.decrypt = function (n) {\n  return this.core(n, 23, -1);\n};\n\nmodule.exports.Skip32 = Skip32;\n\n},{}],5:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _Generator = require('./Generator');\n\nvar _Generator2 = _interopRequireDefault(_Generator);\n\nvar _scrambler = require('./scrambler');\n\nvar _MaxU = require('./MaxU32');\n\nvar _MaxU2 = _interopRequireDefault(_MaxU);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar arbitrary = {\n    MAX_U32: _MaxU2.default,\n    Generator: _Generator2.default,\n    scramble: _scrambler.scramble,\n    descramble: _scrambler.descramble\n};\n\nexports.default = arbitrary;\n\n},{\"./Generator\":1,\"./MaxU32\":3,\"./scrambler\":6}],6:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.scramble = scramble;\nexports.descramble = descramble;\nvar Skip32 = require('./Skip32PureJS').Skip32;\nvar cypher = new Skip32();\n\n/*\n * Takes a unsigned 32 bit integer and returns an unsigned 32 bit integer\n * with it's bits scrambled.\n *\n * Ideal for taking a series of incrementing numbers and creating a pseudo random version.\n * Is reversible via calling descramble() on a scrambled number.\n */\nfunction scramble(number) {\n  return cypher.encrypt(number);\n}\n\n/*\n * Takes a scrambled unsigned 32 bit integer and returns the unscrambled unsigned 32 bit\n * integer version.\n *\n * Ideal for taking a series of incrementing numbers and creating a pseudo random version.\n * Use this to figure out the original number crated from calls to scramble()\n */\nfunction descramble(scrambledNumber) {\n  return cypher.decrypt(scrambledNumber);\n}\n\n},{\"./Skip32PureJS\":4}]},{},[5])(5)\n});\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://Fabric/./node_modules/arbitrary/docs/dist/index.js?");
./assets/fabric.min.js:eval("\n\nconst Reporter = __webpack_require__(/*! ../base/reporter */ \"./node_modules/asn1.js/lib/asn1/base/reporter.js\").Reporter;\nconst EncoderBuffer = __webpack_require__(/*! ../base/buffer */ \"./node_modules/asn1.js/lib/asn1/base/buffer.js\").EncoderBuffer;\nconst DecoderBuffer = __webpack_require__(/*! ../base/buffer */ \"./node_modules/asn1.js/lib/asn1/base/buffer.js\").DecoderBuffer;\nconst assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\n// Supported tags\nconst tags = [\n  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',\n  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',\n  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',\n  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'\n];\n\n// Public methods list\nconst methods = [\n  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',\n  'any', 'contains'\n].concat(tags);\n\n// Overrided methods list\nconst overrided = [\n  '_peekTag', '_decodeTag', '_use',\n  '_decodeStr', '_decodeObjid', '_decodeTime',\n  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',\n\n  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',\n  '_encodeNull', '_encodeInt', '_encodeBool'\n];\n\nfunction Node(enc, parent, name) {\n  const state = {};\n  this._baseState = state;\n\n  state.name = name;\n  state.enc = enc;\n\n  state.parent = parent || null;\n  state.children = null;\n\n  // State\n  state.tag = null;\n  state.args = null;\n  state.reverseArgs = null;\n  state.choice = null;\n  state.optional = false;\n  state.any = false;\n  state.obj = false;\n  state.use = null;\n  state.useDecoder = null;\n  state.key = null;\n  state['default'] = null;\n  state.explicit = null;\n  state.implicit = null;\n  state.contains = null;\n\n  // Should create new instance on each method\n  if (!state.parent) {\n    state.children = [];\n    this._wrap();\n  }\n}\nmodule.exports = Node;\n\nconst stateProps = [\n  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',\n  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',\n  'implicit', 'contains'\n];\n\nNode.prototype.clone = function clone() {\n  const state = this._baseState;\n  const cstate = {};\n  stateProps.forEach(function(prop) {\n    cstate[prop] = state[prop];\n  });\n  const res = new this.constructor(cstate.parent);\n  res._baseState = cstate;\n  return res;\n};\n\nNode.prototype._wrap = function wrap() {\n  const state = this._baseState;\n  methods.forEach(function(method) {\n    this[method] = function _wrappedMethod() {\n      const clone = new this.constructor(this);\n      state.children.push(clone);\n      return clone[method].apply(clone, arguments);\n    };\n  }, this);\n};\n\nNode.prototype._init = function init(body) {\n  const state = this._baseState;\n\n  assert(state.parent === null);\n  body.call(this);\n\n  // Filter children\n  state.children = state.children.filter(function(child) {\n    return child._baseState.parent === this;\n  }, this);\n  assert.equal(state.children.length, 1, 'Root node can have only one child');\n};\n\nNode.prototype._useArgs = function useArgs(args) {\n  const state = this._baseState;\n\n  // Filter children and args\n  const children = args.filter(function(arg) {\n    return arg instanceof this.constructor;\n  }, this);\n  args = args.filter(function(arg) {\n    return !(arg instanceof this.constructor);\n  }, this);\n\n  if (children.length !== 0) {\n    assert(state.children === null);\n    state.children = children;\n\n    // Replace parent to maintain backward link\n    children.forEach(function(child) {\n      child._baseState.parent = this;\n    }, this);\n  }\n  if (args.length !== 0) {\n    assert(state.args === null);\n    state.args = args;\n    state.reverseArgs = args.map(function(arg) {\n      if (typeof arg !== 'object' || arg.constructor !== Object)\n        return arg;\n\n      const res = {};\n      Object.keys(arg).forEach(function(key) {\n        if (key == (key | 0))\n          key |= 0;\n        const value = arg[key];\n        res[value] = key;\n      });\n      return res;\n    });\n  }\n};\n\n//\n// Overrided methods\n//\n\noverrided.forEach(function(method) {\n  Node.prototype[method] = function _overrided() {\n    const state = this._baseState;\n    throw new Error(method + ' not implemented for encoding: ' + state.enc);\n  };\n});\n\n//\n// Public methods\n//\n\ntags.forEach(function(tag) {\n  Node.prototype[tag] = function _tagMethod() {\n    const state = this._baseState;\n    const args = Array.prototype.slice.call(arguments);\n\n    assert(state.tag === null);\n    state.tag = tag;\n\n    this._useArgs(args);\n\n    return this;\n  };\n});\n\nNode.prototype.use = function use(item) {\n  assert(item);\n  const state = this._baseState;\n\n  assert(state.use === null);\n  state.use = item;\n\n  return this;\n};\n\nNode.prototype.optional = function optional() {\n  const state = this._baseState;\n\n  state.optional = true;\n\n  return this;\n};\n\nNode.prototype.def = function def(val) {\n  const state = this._baseState;\n\n  assert(state['default'] === null);\n  state['default'] = val;\n  state.optional = true;\n\n  return this;\n};\n\nNode.prototype.explicit = function explicit(num) {\n  const state = this._baseState;\n\n  assert(state.explicit === null && state.implicit === null);\n  state.explicit = num;\n\n  return this;\n};\n\nNode.prototype.implicit = function implicit(num) {\n  const state = this._baseState;\n\n  assert(state.explicit === null && state.implicit === null);\n  state.implicit = num;\n\n  return this;\n};\n\nNode.prototype.obj = function obj() {\n  const state = this._baseState;\n  const args = Array.prototype.slice.call(arguments);\n\n  state.obj = true;\n\n  if (args.length !== 0)\n    this._useArgs(args);\n\n  return this;\n};\n\nNode.prototype.key = function key(newKey) {\n  const state = this._baseState;\n\n  assert(state.key === null);\n  state.key = newKey;\n\n  return this;\n};\n\nNode.prototype.any = function any() {\n  const state = this._baseState;\n\n  state.any = true;\n\n  return this;\n};\n\nNode.prototype.choice = function choice(obj) {\n  const state = this._baseState;\n\n  assert(state.choice === null);\n  state.choice = obj;\n  this._useArgs(Object.keys(obj).map(function(key) {\n    return obj[key];\n  }));\n\n  return this;\n};\n\nNode.prototype.contains = function contains(item) {\n  const state = this._baseState;\n\n  assert(state.use === null);\n  state.contains = item;\n\n  return this;\n};\n\n//\n// Decoding\n//\n\nNode.prototype._decode = function decode(input, options) {\n  const state = this._baseState;\n\n  // Decode root node\n  if (state.parent === null)\n    return input.wrapResult(state.children[0]._decode(input, options));\n\n  let result = state['default'];\n  let present = true;\n\n  let prevKey = null;\n  if (state.key !== null)\n    prevKey = input.enterKey(state.key);\n\n  // Check if tag is there\n  if (state.optional) {\n    let tag = null;\n    if (state.explicit !== null)\n      tag = state.explicit;\n    else if (state.implicit !== null)\n      tag = state.implicit;\n    else if (state.tag !== null)\n      tag = state.tag;\n\n    if (tag === null && !state.any) {\n      // Trial and Error\n      const save = input.save();\n      try {\n        if (state.choice === null)\n          this._decodeGeneric(state.tag, input, options);\n        else\n          this._decodeChoice(input, options);\n        present = true;\n      } catch (e) {\n        present = false;\n      }\n      input.restore(save);\n    } else {\n      present = this._peekTag(input, tag, state.any);\n\n      if (input.isError(present))\n        return present;\n    }\n  }\n\n  // Push object on stack\n  let prevObj;\n  if (state.obj && present)\n    prevObj = input.enterObject();\n\n  if (present) {\n    // Unwrap explicit values\n    if (state.explicit !== null) {\n      const explicit = this._decodeTag(input, state.explicit);\n      if (input.isError(explicit))\n        return explicit;\n      input = explicit;\n    }\n\n    const start = input.offset;\n\n    // Unwrap implicit and normal values\n    if (state.use === null && state.choice === null) {\n      let save;\n      if (state.any)\n        save = input.save();\n      const body = this._decodeTag(\n        input,\n        state.implicit !== null ? state.implicit : state.tag,\n        state.any\n      );\n      if (input.isError(body))\n        return body;\n\n      if (state.any)\n        result = input.raw(save);\n      else\n        input = body;\n    }\n\n    if (options && options.track && state.tag !== null)\n      options.track(input.path(), start, input.length, 'tagged');\n\n    if (options && options.track && state.tag !== null)\n      options.track(input.path(), input.offset, input.length, 'content');\n\n    // Select proper method for tag\n    if (state.any) {\n      // no-op\n    } else if (state.choice === null) {\n      result = this._decodeGeneric(state.tag, input, options);\n    } else {\n      result = this._decodeChoice(input, options);\n    }\n\n    if (input.isError(result))\n      return result;\n\n    // Decode children\n    if (!state.any && state.choice === null && state.children !== null) {\n      state.children.forEach(function decodeChildren(child) {\n        // NOTE: We are ignoring errors here, to let parser continue with other\n        // parts of encoded data\n        child._decode(input, options);\n      });\n    }\n\n    // Decode contained/encoded by schema, only in bit or octet strings\n    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {\n      const data = new DecoderBuffer(result);\n      result = this._getUse(state.contains, input._reporterState.obj)\n        ._decode(data, options);\n    }\n  }\n\n  // Pop object\n  if (state.obj && present)\n    result = input.leaveObject(prevObj);\n\n  // Set key\n  if (state.key !== null && (result !== null || present === true))\n    input.leaveKey(prevKey, state.key, result);\n  else if (prevKey !== null)\n    input.exitKey(prevKey);\n\n  return result;\n};\n\nNode.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {\n  const state = this._baseState;\n\n  if (tag === 'seq' || tag === 'set')\n    return null;\n  if (tag === 'seqof' || tag === 'setof')\n    return this._decodeList(input, tag, state.args[0], options);\n  else if (/str$/.test(tag))\n    return this._decodeStr(input, tag, options);\n  else if (tag === 'objid' && state.args)\n    return this._decodeObjid(input, state.args[0], state.args[1], options);\n  else if (tag === 'objid')\n    return this._decodeObjid(input, null, null, options);\n  else if (tag === 'gentime' || tag === 'utctime')\n    return this._decodeTime(input, tag, options);\n  else if (tag === 'null_')\n    return this._decodeNull(input, options);\n  else if (tag === 'bool')\n    return this._decodeBool(input, options);\n  else if (tag === 'objDesc')\n    return this._decodeStr(input, tag, options);\n  else if (tag === 'int' || tag === 'enum')\n    return this._decodeInt(input, state.args && state.args[0], options);\n\n  if (state.use !== null) {\n    return this._getUse(state.use, input._reporterState.obj)\n      ._decode(input, options);\n  } else {\n    return input.error('unknown tag: ' + tag);\n  }\n};\n\nNode.prototype._getUse = function _getUse(entity, obj) {\n\n  const state = this._baseState;\n  // Create altered use decoder if implicit is set\n  state.useDecoder = this._use(entity, obj);\n  assert(state.useDecoder._baseState.parent === null);\n  state.useDecoder = state.useDecoder._baseState.children[0];\n  if (state.implicit !== state.useDecoder._baseState.implicit) {\n    state.useDecoder = state.useDecoder.clone();\n    state.useDecoder._baseState.implicit = state.implicit;\n  }\n  return state.useDecoder;\n};\n\nNode.prototype._decodeChoice = function decodeChoice(input, options) {\n  const state = this._baseState;\n  let result = null;\n  let match = false;\n\n  Object.keys(state.choice).some(function(key) {\n    const save = input.save();\n    const node = state.choice[key];\n    try {\n      const value = node._decode(input, options);\n      if (input.isError(value))\n        return false;\n\n      result = { type: key, value: value };\n      match = true;\n    } catch (e) {\n      input.restore(save);\n      return false;\n    }\n    return true;\n  }, this);\n\n  if (!match)\n    return input.error('Choice not matched');\n\n  return result;\n};\n\n//\n// Encoding\n//\n\nNode.prototype._createEncoderBuffer = function createEncoderBuffer(data) {\n  return new EncoderBuffer(data, this.reporter);\n};\n\nNode.prototype._encode = function encode(data, reporter, parent) {\n  const state = this._baseState;\n  if (state['default'] !== null && state['default'] === data)\n    return;\n\n  const result = this._encodeValue(data, reporter, parent);\n  if (result === undefined)\n    return;\n\n  if (this._skipDefault(result, reporter, parent))\n    return;\n\n  return result;\n};\n\nNode.prototype._encodeValue = function encode(data, reporter, parent) {\n  const state = this._baseState;\n\n  // Decode root node\n  if (state.parent === null)\n    return state.children[0]._encode(data, reporter || new Reporter());\n\n  let result = null;\n\n  // Set reporter to share it with a child class\n  this.reporter = reporter;\n\n  // Check if data is there\n  if (state.optional && data === undefined) {\n    if (state['default'] !== null)\n      data = state['default'];\n    else\n      return;\n  }\n\n  // Encode children first\n  let content = null;\n  let primitive = false;\n  if (state.any) {\n    // Anything that was given is translated to buffer\n    result = this._createEncoderBuffer(data);\n  } else if (state.choice) {\n    result = this._encodeChoice(data, reporter);\n  } else if (state.contains) {\n    content = this._getUse(state.contains, parent)._encode(data, reporter);\n    primitive = true;\n  } else if (state.children) {\n    content = state.children.map(function(child) {\n      if (child._baseState.tag === 'null_')\n        return child._encode(null, reporter, data);\n\n      if (child._baseState.key === null)\n        return reporter.error('Child should have a key');\n      const prevKey = reporter.enterKey(child._baseState.key);\n\n      if (typeof data !== 'object')\n        return reporter.error('Child expected, but input is not object');\n\n      const res = child._encode(data[child._baseState.key], reporter, data);\n      reporter.leaveKey(prevKey);\n\n      return res;\n    }, this).filter(function(child) {\n      return child;\n    });\n    content = this._createEncoderBuffer(content);\n  } else {\n    if (state.tag === 'seqof' || state.tag === 'setof') {\n      // TODO(indutny): this should be thrown on DSL level\n      if (!(state.args && state.args.length === 1))\n        return reporter.error('Too many args for : ' + state.tag);\n\n      if (!Array.isArray(data))\n        return reporter.error('seqof/setof, but data is not Array');\n\n      const child = this.clone();\n      child._baseState.implicit = null;\n      content = this._createEncoderBuffer(data.map(function(item) {\n        const state = this._baseState;\n\n        return this._getUse(state.args[0], data)._encode(item, reporter);\n      }, child));\n    } else if (state.use !== null) {\n      result = this._getUse(state.use, parent)._encode(data, reporter);\n    } else {\n      content = this._encodePrimitive(state.tag, data);\n      primitive = true;\n    }\n  }\n\n  // Encode data itself\n  if (!state.any && state.choice === null) {\n    const tag = state.implicit !== null ? state.implicit : state.tag;\n    const cls = state.implicit === null ? 'universal' : 'context';\n\n    if (tag === null) {\n      if (state.use === null)\n        reporter.error('Tag could be omitted only for .use()');\n    } else {\n      if (state.use === null)\n        result = this._encodeComposite(tag, primitive, cls, content);\n    }\n  }\n\n  // Wrap in explicit\n  if (state.explicit !== null)\n    result = this._encodeComposite(state.explicit, false, 'context', result);\n\n  return result;\n};\n\nNode.prototype._encodeChoice = function encodeChoice(data, reporter) {\n  const state = this._baseState;\n\n  const node = state.choice[data.type];\n  if (!node) {\n    assert(\n      false,\n      data.type + ' not found in ' +\n            JSON.stringify(Object.keys(state.choice)));\n  }\n  return node._encode(data.value, reporter);\n};\n\nNode.prototype._encodePrimitive = function encodePrimitive(tag, data) {\n  const state = this._baseState;\n\n  if (/str$/.test(tag))\n    return this._encodeStr(data, tag);\n  else if (tag === 'objid' && state.args)\n    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);\n  else if (tag === 'objid')\n    return this._encodeObjid(data, null, null);\n  else if (tag === 'gentime' || tag === 'utctime')\n    return this._encodeTime(data, tag);\n  else if (tag === 'null_')\n    return this._encodeNull();\n  else if (tag === 'int' || tag === 'enum')\n    return this._encodeInt(data, state.args && state.reverseArgs[0]);\n  else if (tag === 'bool')\n    return this._encodeBool(data);\n  else if (tag === 'objDesc')\n    return this._encodeStr(data, tag);\n  else\n    throw new Error('Unsupported tag: ' + tag);\n};\n\nNode.prototype._isNumstr = function isNumstr(str) {\n  return /^[0-9 ]*$/.test(str);\n};\n\nNode.prototype._isPrintstr = function isPrintstr(str) {\n  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);\n};\n\n\n//# sourceURL=webpack://Fabric/./node_modules/asn1.js/lib/asn1/base/node.js?");
./assets/fabric.min.js:eval("/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {\n  'use strict';\n\n  // Utils\n  function assert (val, msg) {\n    if (!val) throw new Error(msg || 'Assertion failed');\n  }\n\n  // Could use `inherits` module, but don't want to move from single file\n  // architecture yet.\n  function inherits (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  }\n\n  // BN\n\n  function BN (number, base, endian) {\n    if (BN.isBN(number)) {\n      return number;\n    }\n\n    this.negative = 0;\n    this.words = null;\n    this.length = 0;\n\n    // Reduction context\n    this.red = null;\n\n    if (number !== null) {\n      if (base === 'le' || base === 'be') {\n        endian = base;\n        base = 10;\n      }\n\n      this._init(number || 0, base || 10, endian || 'be');\n    }\n  }\n  if (typeof module === 'object') {\n    module.exports = BN;\n  } else {\n    exports.BN = BN;\n  }\n\n  BN.BN = BN;\n  BN.wordSize = 26;\n\n  var Buffer;\n  try {\n    Buffer = __webpack_require__(/*! buffer */ 4).Buffer;\n  } catch (e) {\n  }\n\n  BN.isBN = function isBN (num) {\n    if (num instanceof BN) {\n      return true;\n    }\n\n    return num !== null && typeof num === 'object' &&\n      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n  };\n\n  BN.max = function max (left, right) {\n    if (left.cmp(right) > 0) return left;\n    return right;\n  };\n\n  BN.min = function min (left, right) {\n    if (left.cmp(right) < 0) return left;\n    return right;\n  };\n\n  BN.prototype._init = function init (number, base, endian) {\n    if (typeof number === 'number') {\n      return this._initNumber(number, base, endian);\n    }\n\n    if (typeof number === 'object') {\n      return this._initArray(number, base, endian);\n    }\n\n    if (base === 'hex') {\n      base = 16;\n    }\n    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n    number = number.toString().replace(/\\s+/g, '');\n    var start = 0;\n    if (number[0] === '-') {\n      start++;\n    }\n\n    if (base === 16) {\n      this._parseHex(number, start);\n    } else {\n      this._parseBase(number, base, start);\n    }\n\n    if (number[0] === '-') {\n      this.negative = 1;\n    }\n\n    this.strip();\n\n    if (endian !== 'le') return;\n\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n    if (number < 0) {\n      this.negative = 1;\n      number = -number;\n    }\n    if (number < 0x4000000) {\n      this.words = [ number & 0x3ffffff ];\n      this.length = 1;\n    } else if (number < 0x10000000000000) {\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff\n      ];\n      this.length = 2;\n    } else {\n      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff,\n        1\n      ];\n      this.length = 3;\n    }\n\n    if (endian !== 'le') return;\n\n    // Reverse the bytes\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initArray = function _initArray (number, base, endian) {\n    // Perhaps a Uint8Array\n    assert(typeof number.length === 'number');\n    if (number.length <= 0) {\n      this.words = [ 0 ];\n      this.length = 1;\n      return this;\n    }\n\n    this.length = Math.ceil(number.length / 3);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    var off = 0;\n    if (endian === 'be') {\n      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    } else if (endian === 'le') {\n      for (i = 0, j = 0; i < number.length; i += 3) {\n        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    }\n    return this.strip();\n  };\n\n  function parseHex (str, start, end) {\n    var r = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r <<= 4;\n\n      // 'a' - 'f'\n      if (c >= 49 && c <= 54) {\n        r |= c - 49 + 0xa;\n\n      // 'A' - 'F'\n      } else if (c >= 17 && c <= 22) {\n        r |= c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        r |= c & 0xf;\n      }\n    }\n    return r;\n  }\n\n  BN.prototype._parseHex = function _parseHex (number, start) {\n    // Create possibly bigger array to ensure that it fits the number\n    this.length = Math.ceil((number.length - start) / 6);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    // Scan 24-bit chunks and add them to the number\n    var off = 0;\n    for (i = number.length - 6, j = 0; i >= start; i -= 6) {\n      w = parseHex(number, i, i + 6);\n      this.words[j] |= (w << off) & 0x3ffffff;\n      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb\n      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n      off += 24;\n      if (off >= 26) {\n        off -= 26;\n        j++;\n      }\n    }\n    if (i + 6 !== start) {\n      w = parseHex(number, start, i + 6);\n      this.words[j] |= (w << off) & 0x3ffffff;\n      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n    }\n    this.strip();\n  };\n\n  function parseBase (str, start, end, mul) {\n    var r = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r *= mul;\n\n      // 'a'\n      if (c >= 49) {\n        r += c - 49 + 0xa;\n\n      // 'A'\n      } else if (c >= 17) {\n        r += c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        r += c;\n      }\n    }\n    return r;\n  }\n\n  BN.prototype._parseBase = function _parseBase (number, base, start) {\n    // Initialize as zero\n    this.words = [ 0 ];\n    this.length = 1;\n\n    // Find length of limb in base\n    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n      limbLen++;\n    }\n    limbLen--;\n    limbPow = (limbPow / base) | 0;\n\n    var total = number.length - start;\n    var mod = total % limbLen;\n    var end = Math.min(total, total - mod) + start;\n\n    var word = 0;\n    for (var i = start; i < end; i += limbLen) {\n      word = parseBase(number, i, i + limbLen, base);\n\n      this.imuln(limbPow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    if (mod !== 0) {\n      var pow = 1;\n      word = parseBase(number, i, number.length, base);\n\n      for (i = 0; i < mod; i++) {\n        pow *= base;\n      }\n\n      this.imuln(pow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n  };\n\n  BN.prototype.copy = function copy (dest) {\n    dest.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      dest.words[i] = this.words[i];\n    }\n    dest.length = this.length;\n    dest.negative = this.negative;\n    dest.red = this.red;\n  };\n\n  BN.prototype.clone = function clone () {\n    var r = new BN(null);\n    this.copy(r);\n    return r;\n  };\n\n  BN.prototype._expand = function _expand (size) {\n    while (this.length < size) {\n      this.words[this.length++] = 0;\n    }\n    return this;\n  };\n\n  // Remove leading `0` from `this`\n  BN.prototype.strip = function strip () {\n    while (this.length > 1 && this.words[this.length - 1] === 0) {\n      this.length--;\n    }\n    return this._normSign();\n  };\n\n  BN.prototype._normSign = function _normSign () {\n    // -0 = 0\n    if (this.length === 1 && this.words[0] === 0) {\n      this.negative = 0;\n    }\n    return this;\n  };\n\n  BN.prototype.inspect = function inspect () {\n    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n  };\n\n  /*\n\n  var zeros = [];\n  var groupSizes = [];\n  var groupBases = [];\n\n  var s = '';\n  var i = -1;\n  while (++i < BN.wordSize) {\n    zeros[i] = s;\n    s += '0';\n  }\n  groupSizes[0] = 0;\n  groupSizes[1] = 0;\n  groupBases[0] = 0;\n  groupBases[1] = 0;\n  var base = 2 - 1;\n  while (++base < 36 + 1) {\n    var groupSize = 0;\n    var groupBase = 1;\n    while (groupBase < (1 << BN.wordSize) / base) {\n      groupBase *= base;\n      groupSize += 1;\n    }\n    groupSizes[base] = groupSize;\n    groupBases[base] = groupBase;\n  }\n\n  */\n\n  var zeros = [\n    '',\n    '0',\n    '00',\n    '000',\n    '0000',\n    '00000',\n    '000000',\n    '0000000',\n    '00000000',\n    '000000000',\n    '0000000000',\n    '00000000000',\n    '000000000000',\n    '0000000000000',\n    '00000000000000',\n    '000000000000000',\n    '0000000000000000',\n    '00000000000000000',\n    '000000000000000000',\n    '0000000000000000000',\n    '00000000000000000000',\n    '000000000000000000000',\n    '0000000000000000000000',\n    '00000000000000000000000',\n    '000000000000000000000000',\n    '0000000000000000000000000'\n  ];\n\n  var groupSizes = [\n    0, 0,\n    25, 16, 12, 11, 10, 9, 8,\n    8, 7, 7, 7, 7, 6, 6,\n    6, 6, 6, 6, 6, 5, 5,\n    5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5\n  ];\n\n  var groupBases = [\n    0, 0,\n    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n  ];\n\n  BN.prototype.toString = function toString (base, padding) {\n    base = base || 10;\n    padding = padding | 0 || 1;\n\n    var out;\n    if (base === 16 || base === 'hex') {\n      out = '';\n      var off = 0;\n      var carry = 0;\n      for (var i = 0; i < this.length; i++) {\n        var w = this.words[i];\n        var word = (((w << off) | carry) & 0xffffff).toString(16);\n        carry = (w >>> (24 - off)) & 0xffffff;\n        if (carry !== 0 || i !== this.length - 1) {\n          out = zeros[6 - word.length] + word + out;\n        } else {\n          out = word + out;\n        }\n        off += 2;\n        if (off >= 26) {\n          off -= 26;\n          i--;\n        }\n      }\n      if (carry !== 0) {\n        out = carry.toString(16) + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    if (base === (base | 0) && base >= 2 && base <= 36) {\n      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n      var groupSize = groupSizes[base];\n      // var groupBase = Math.pow(base, groupSize);\n      var groupBase = groupBases[base];\n      out = '';\n      var c = this.clone();\n      c.negative = 0;\n      while (!c.isZero()) {\n        var r = c.modn(groupBase).toString(base);\n        c = c.idivn(groupBase);\n\n        if (!c.isZero()) {\n          out = zeros[groupSize - r.length] + r + out;\n        } else {\n          out = r + out;\n        }\n      }\n      if (this.isZero()) {\n        out = '0' + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    assert(false, 'Base should be between 2 and 36');\n  };\n\n  BN.prototype.toNumber = function toNumber () {\n    var ret = this.words[0];\n    if (this.length === 2) {\n      ret += this.words[1] * 0x4000000;\n    } else if (this.length === 3 && this.words[2] === 0x01) {\n      // NOTE: at this stage it is known that the top bit is set\n      ret += 0x10000000000000 + (this.words[1] * 0x4000000);\n    } else if (this.length > 2) {\n      assert(false, 'Number can only safely store up to 53 bits');\n    }\n    return (this.negative !== 0) ? -ret : ret;\n  };\n\n  BN.prototype.toJSON = function toJSON () {\n    return this.toString(16);\n  };\n\n  BN.prototype.toBuffer = function toBuffer (endian, length) {\n    assert(typeof Buffer !== 'undefined');\n    return this.toArrayLike(Buffer, endian, length);\n  };\n\n  BN.prototype.toArray = function toArray (endian, length) {\n    return this.toArrayLike(Array, endian, length);\n  };\n\n  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {\n    var byteLength = this.byteLength();\n    var reqLength = length || Math.max(1, byteLength);\n    assert(byteLength <= reqLength, 'byte array longer than desired length');\n    assert(reqLength > 0, 'Requested array length <= 0');\n\n    this.strip();\n    var littleEndian = endian === 'le';\n    var res = new ArrayType(reqLength);\n\n    var b, i;\n    var q = this.clone();\n    if (!littleEndian) {\n      // Assume big-endian\n      for (i = 0; i < reqLength - byteLength; i++) {\n        res[i] = 0;\n      }\n\n      for (i = 0; !q.isZero(); i++) {\n        b = q.andln(0xff);\n        q.iushrn(8);\n\n        res[reqLength - i - 1] = b;\n      }\n    } else {\n      for (i = 0; !q.isZero(); i++) {\n        b = q.andln(0xff);\n        q.iushrn(8);\n\n        res[i] = b;\n      }\n\n      for (; i < reqLength; i++) {\n        res[i] = 0;\n      }\n    }\n\n    return res;\n  };\n\n  if (Math.clz32) {\n    BN.prototype._countBits = function _countBits (w) {\n      return 32 - Math.clz32(w);\n    };\n  } else {\n    BN.prototype._countBits = function _countBits (w) {\n      var t = w;\n      var r = 0;\n      if (t >= 0x1000) {\n        r += 13;\n        t >>>= 13;\n      }\n      if (t >= 0x40) {\n        r += 7;\n        t >>>= 7;\n      }\n      if (t >= 0x8) {\n        r += 4;\n        t >>>= 4;\n      }\n      if (t >= 0x02) {\n        r += 2;\n        t >>>= 2;\n      }\n      return r + t;\n    };\n  }\n\n  BN.prototype._zeroBits = function _zeroBits (w) {\n    // Short-cut\n    if (w === 0) return 26;\n\n    var t = w;\n    var r = 0;\n    if ((t & 0x1fff) === 0) {\n      r += 13;\n      t >>>= 13;\n    }\n    if ((t & 0x7f) === 0) {\n      r += 7;\n      t >>>= 7;\n    }\n    if ((t & 0xf) === 0) {\n      r += 4;\n      t >>>= 4;\n    }\n    if ((t & 0x3) === 0) {\n      r += 2;\n      t >>>= 2;\n    }\n    if ((t & 0x1) === 0) {\n      r++;\n    }\n    return r;\n  };\n\n  // Return number of used bits in a BN\n  BN.prototype.bitLength = function bitLength () {\n    var w = this.words[this.length - 1];\n    var hi = this._countBits(w);\n    return (this.length - 1) * 26 + hi;\n  };\n\n  function toBitArray (num) {\n    var w = new Array(num.bitLength());\n\n    for (var bit = 0; bit < w.length; bit++) {\n      var off = (bit / 26) | 0;\n      var wbit = bit % 26;\n\n      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;\n    }\n\n    return w;\n  }\n\n  // Number of trailing zero bits\n  BN.prototype.zeroBits = function zeroBits () {\n    if (this.isZero()) return 0;\n\n    var r = 0;\n    for (var i = 0; i < this.length; i++) {\n      var b = this._zeroBits(this.words[i]);\n      r += b;\n      if (b !== 26) break;\n    }\n    return r;\n  };\n\n  BN.prototype.byteLength = function byteLength () {\n    return Math.ceil(this.bitLength() / 8);\n  };\n\n  BN.prototype.toTwos = function toTwos (width) {\n    if (this.negative !== 0) {\n      return this.abs().inotn(width).iaddn(1);\n    }\n    return this.clone();\n  };\n\n  BN.prototype.fromTwos = function fromTwos (width) {\n    if (this.testn(width - 1)) {\n      return this.notn(width).iaddn(1).ineg();\n    }\n    return this.clone();\n  };\n\n  BN.prototype.isNeg = function isNeg () {\n    return this.negative !== 0;\n  };\n\n  // Return negative clone of `this`\n  BN.prototype.neg = function neg () {\n    return this.clone().ineg();\n  };\n\n  BN.prototype.ineg = function ineg () {\n    if (!this.isZero()) {\n      this.negative ^= 1;\n    }\n\n    return this;\n  };\n\n  // Or `num` with `this` in-place\n  BN.prototype.iuor = function iuor (num) {\n    while (this.length < num.length) {\n      this.words[this.length++] = 0;\n    }\n\n    for (var i = 0; i < num.length; i++) {\n      this.words[i] = this.words[i] | num.words[i];\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ior = function ior (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuor(num);\n  };\n\n  // Or `num` with `this`\n  BN.prototype.or = function or (num) {\n    if (this.length > num.length) return this.clone().ior(num);\n    return num.clone().ior(this);\n  };\n\n  BN.prototype.uor = function uor (num) {\n    if (this.length > num.length) return this.clone().iuor(num);\n    return num.clone().iuor(this);\n  };\n\n  // And `num` with `this` in-place\n  BN.prototype.iuand = function iuand (num) {\n    // b = min-length(num, this)\n    var b;\n    if (this.length > num.length) {\n      b = num;\n    } else {\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = this.words[i] & num.words[i];\n    }\n\n    this.length = b.length;\n\n    return this.strip();\n  };\n\n  BN.prototype.iand = function iand (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuand(num);\n  };\n\n  // And `num` with `this`\n  BN.prototype.and = function and (num) {\n    if (this.length > num.length) return this.clone().iand(num);\n    return num.clone().iand(this);\n  };\n\n  BN.prototype.uand = function uand (num) {\n    if (this.length > num.length) return this.clone().iuand(num);\n    return num.clone().iuand(this);\n  };\n\n  // Xor `num` with `this` in-place\n  BN.prototype.iuxor = function iuxor (num) {\n    // a.length > b.length\n    var a;\n    var b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = a.words[i] ^ b.words[i];\n    }\n\n    if (this !== a) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = a.length;\n\n    return this.strip();\n  };\n\n  BN.prototype.ixor = function ixor (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuxor(num);\n  };\n\n  // Xor `num` with `this`\n  BN.prototype.xor = function xor (num) {\n    if (this.length > num.length) return this.clone().ixor(num);\n    return num.clone().ixor(this);\n  };\n\n  BN.prototype.uxor = function uxor (num) {\n    if (this.length > num.length) return this.clone().iuxor(num);\n    return num.clone().iuxor(this);\n  };\n\n  // Not ``this`` with ``width`` bitwidth\n  BN.prototype.inotn = function inotn (width) {\n    assert(typeof width === 'number' && width >= 0);\n\n    var bytesNeeded = Math.ceil(width / 26) | 0;\n    var bitsLeft = width % 26;\n\n    // Extend the buffer with leading zeroes\n    this._expand(bytesNeeded);\n\n    if (bitsLeft > 0) {\n      bytesNeeded--;\n    }\n\n    // Handle complete words\n    for (var i = 0; i < bytesNeeded; i++) {\n      this.words[i] = ~this.words[i] & 0x3ffffff;\n    }\n\n    // Handle the residue\n    if (bitsLeft > 0) {\n      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n    }\n\n    // And remove leading zeroes\n    return this.strip();\n  };\n\n  BN.prototype.notn = function notn (width) {\n    return this.clone().inotn(width);\n  };\n\n  // Set `bit` of `this`\n  BN.prototype.setn = function setn (bit, val) {\n    assert(typeof bit === 'number' && bit >= 0);\n\n    var off = (bit / 26) | 0;\n    var wbit = bit % 26;\n\n    this._expand(off + 1);\n\n    if (val) {\n      this.words[off] = this.words[off] | (1 << wbit);\n    } else {\n      this.words[off] = this.words[off] & ~(1 << wbit);\n    }\n\n    return this.strip();\n  };\n\n  // Add `num` to `this` in-place\n  BN.prototype.iadd = function iadd (num) {\n    var r;\n\n    // negative + positive\n    if (this.negative !== 0 && num.negative === 0) {\n      this.negative = 0;\n      r = this.isub(num);\n      this.negative ^= 1;\n      return this._normSign();\n\n    // positive + negative\n    } else if (this.negative === 0 && num.negative !== 0) {\n      num.negative = 0;\n      r = this.isub(num);\n      num.negative = 1;\n      return r._normSign();\n    }\n\n    // a.length > b.length\n    var a, b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    this.length = a.length;\n    if (carry !== 0) {\n      this.words[this.length] = carry;\n      this.length++;\n    // Copy the rest of the words\n    } else if (a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    return this;\n  };\n\n  // Add `num` to `this`\n  BN.prototype.add = function add (num) {\n    var res;\n    if (num.negative !== 0 && this.negative === 0) {\n      num.negative = 0;\n      res = this.sub(num);\n      num.negative ^= 1;\n      return res;\n    } else if (num.negative === 0 && this.negative !== 0) {\n      this.negative = 0;\n      res = num.sub(this);\n      this.negative = 1;\n      return res;\n    }\n\n    if (this.length > num.length) return this.clone().iadd(num);\n\n    return num.clone().iadd(this);\n  };\n\n  // Subtract `num` from `this` in-place\n  BN.prototype.isub = function isub (num) {\n    // this - (-num) = this + num\n    if (num.negative !== 0) {\n      num.negative = 0;\n      var r = this.iadd(num);\n      num.negative = 1;\n      return r._normSign();\n\n    // -this - num = -(this + num)\n    } else if (this.negative !== 0) {\n      this.negative = 0;\n      this.iadd(num);\n      this.negative = 1;\n      return this._normSign();\n    }\n\n    // At this point both numbers are positive\n    var cmp = this.cmp(num);\n\n    // Optimization - zeroify\n    if (cmp === 0) {\n      this.negative = 0;\n      this.length = 1;\n      this.words[0] = 0;\n      return this;\n    }\n\n    // a > b\n    var a, b;\n    if (cmp > 0) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n\n    // Copy rest of the words\n    if (carry === 0 && i < a.length && a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = Math.max(this.length, i);\n\n    if (a !== this) {\n      this.negative = 1;\n    }\n\n    return this.strip();\n  };\n\n  // Subtract `num` from `this`\n  BN.prototype.sub = function sub (num) {\n    return this.clone().isub(num);\n  };\n\n  function smallMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    var len = (self.length + num.length) | 0;\n    out.length = len;\n    len = (len - 1) | 0;\n\n    // Peel one iteration (compiler can't do it, because of code complexity)\n    var a = self.words[0] | 0;\n    var b = num.words[0] | 0;\n    var r = a * b;\n\n    var lo = r & 0x3ffffff;\n    var carry = (r / 0x4000000) | 0;\n    out.words[0] = lo;\n\n    for (var k = 1; k < len; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = carry >>> 26;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = (k - j) | 0;\n        a = self.words[i] | 0;\n        b = num.words[j] | 0;\n        r = a * b + rword;\n        ncarry += (r / 0x4000000) | 0;\n        rword = r & 0x3ffffff;\n      }\n      out.words[k] = rword | 0;\n      carry = ncarry | 0;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry | 0;\n    } else {\n      out.length--;\n    }\n\n    return out.strip();\n  }\n\n  // TODO(indutny): it may be reasonable to omit it for users who don't need\n  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n  // multiplication (like elliptic secp256k1).\n  var comb10MulTo = function comb10MulTo (self, num, out) {\n    var a = self.words;\n    var b = num.words;\n    var o = out.words;\n    var c = 0;\n    var lo;\n    var mid;\n    var hi;\n    var a0 = a[0] | 0;\n    var al0 = a0 & 0x1fff;\n    var ah0 = a0 >>> 13;\n    var a1 = a[1] | 0;\n    var al1 = a1 & 0x1fff;\n    var ah1 = a1 >>> 13;\n    var a2 = a[2] | 0;\n    var al2 = a2 & 0x1fff;\n    var ah2 = a2 >>> 13;\n    var a3 = a[3] | 0;\n    var al3 = a3 & 0x1fff;\n    var ah3 = a3 >>> 13;\n    var a4 = a[4] | 0;\n    var al4 = a4 & 0x1fff;\n    var ah4 = a4 >>> 13;\n    var a5 = a[5] | 0;\n    var al5 = a5 & 0x1fff;\n    var ah5 = a5 >>> 13;\n    var a6 = a[6] | 0;\n    var al6 = a6 & 0x1fff;\n    var ah6 = a6 >>> 13;\n    var a7 = a[7] | 0;\n    var al7 = a7 & 0x1fff;\n    var ah7 = a7 >>> 13;\n    var a8 = a[8] | 0;\n    var al8 = a8 & 0x1fff;\n    var ah8 = a8 >>> 13;\n    var a9 = a[9] | 0;\n    var al9 = a9 & 0x1fff;\n    var ah9 = a9 >>> 13;\n    var b0 = b[0] | 0;\n    var bl0 = b0 & 0x1fff;\n    var bh0 = b0 >>> 13;\n    var b1 = b[1] | 0;\n    var bl1 = b1 & 0x1fff;\n    var bh1 = b1 >>> 13;\n    var b2 = b[2] | 0;\n    var bl2 = b2 & 0x1fff;\n    var bh2 = b2 >>> 13;\n    var b3 = b[3] | 0;\n    var bl3 = b3 & 0x1fff;\n    var bh3 = b3 >>> 13;\n    var b4 = b[4] | 0;\n    var bl4 = b4 & 0x1fff;\n    var bh4 = b4 >>> 13;\n    var b5 = b[5] | 0;\n    var bl5 = b5 & 0x1fff;\n    var bh5 = b5 >>> 13;\n    var b6 = b[6] | 0;\n    var bl6 = b6 & 0x1fff;\n    var bh6 = b6 >>> 13;\n    var b7 = b[7] | 0;\n    var bl7 = b7 & 0x1fff;\n    var bh7 = b7 >>> 13;\n    var b8 = b[8] | 0;\n    var bl8 = b8 & 0x1fff;\n    var bh8 = b8 >>> 13;\n    var b9 = b[9] | 0;\n    var bl9 = b9 & 0x1fff;\n    var bh9 = b9 >>> 13;\n\n    out.negative = self.negative ^ num.negative;\n    out.length = 19;\n    /* k = 0 */\n    lo = Math.imul(al0, bl0);\n    mid = Math.imul(al0, bh0);\n    mid = (mid + Math.imul(ah0, bl0)) | 0;\n    hi = Math.imul(ah0, bh0);\n    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\n    w0 &= 0x3ffffff;\n    /* k = 1 */\n    lo = Math.imul(al1, bl0);\n    mid = Math.imul(al1, bh0);\n    mid = (mid + Math.imul(ah1, bl0)) | 0;\n    hi = Math.imul(ah1, bh0);\n    lo = (lo + Math.imul(al0, bl1)) | 0;\n    mid = (mid + Math.imul(al0, bh1)) | 0;\n    mid = (mid + Math.imul(ah0, bl1)) | 0;\n    hi = (hi + Math.imul(ah0, bh1)) | 0;\n    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\n    w1 &= 0x3ffffff;\n    /* k = 2 */\n    lo = Math.imul(al2, bl0);\n    mid = Math.imul(al2, bh0);\n    mid = (mid + Math.imul(ah2, bl0)) | 0;\n    hi = Math.imul(ah2, bh0);\n    lo = (lo + Math.imul(al1, bl1)) | 0;\n    mid = (mid + Math.imul(al1, bh1)) | 0;\n    mid = (mid + Math.imul(ah1, bl1)) | 0;\n    hi = (hi + Math.imul(ah1, bh1)) | 0;\n    lo = (lo + Math.imul(al0, bl2)) | 0;\n    mid = (mid + Math.imul(al0, bh2)) | 0;\n    mid = (mid + Math.imul(ah0, bl2)) | 0;\n    hi = (hi + Math.imul(ah0, bh2)) | 0;\n    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\n    w2 &= 0x3ffffff;\n    /* k = 3 */\n    lo = Math.imul(al3, bl0);\n    mid = Math.imul(al3, bh0);\n    mid = (mid + Math.imul(ah3, bl0)) | 0;\n    hi = Math.imul(ah3, bh0);\n    lo = (lo + Math.imul(al2, bl1)) | 0;\n    mid = (mid + Math.imul(al2, bh1)) | 0;\n    mid = (mid + Math.imul(ah2, bl1)) | 0;\n    hi = (hi + Math.imul(ah2, bh1)) | 0;\n    lo = (lo + Math.imul(al1, bl2)) | 0;\n    mid = (mid + Math.imul(al1, bh2)) | 0;\n    mid = (mid + Math.imul(ah1, bl2)) | 0;\n    hi = (hi + Math.imul(ah1, bh2)) | 0;\n    lo = (lo + Math.imul(al0, bl3)) | 0;\n    mid = (mid + Math.imul(al0, bh3)) | 0;\n    mid = (mid + Math.imul(ah0, bl3)) | 0;\n    hi = (hi + Math.imul(ah0, bh3)) | 0;\n    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\n    w3 &= 0x3ffffff;\n    /* k = 4 */\n    lo = Math.imul(al4, bl0);\n    mid = Math.imul(al4, bh0);\n    mid = (mid + Math.imul(ah4, bl0)) | 0;\n    hi = Math.imul(ah4, bh0);\n    lo = (lo + Math.imul(al3, bl1)) | 0;\n    mid = (mid + Math.imul(al3, bh1)) | 0;\n    mid = (mid + Math.imul(ah3, bl1)) | 0;\n    hi = (hi + Math.imul(ah3, bh1)) | 0;\n    lo = (lo + Math.imul(al2, bl2)) | 0;\n    mid = (mid + Math.imul(al2, bh2)) | 0;\n    mid = (mid + Math.imul(ah2, bl2)) | 0;\n    hi = (hi + Math.imul(ah2, bh2)) | 0;\n    lo = (lo + Math.imul(al1, bl3)) | 0;\n    mid = (mid + Math.imul(al1, bh3)) | 0;\n    mid = (mid + Math.imul(ah1, bl3)) | 0;\n    hi = (hi + Math.imul(ah1, bh3)) | 0;\n    lo = (lo + Math.imul(al0, bl4)) | 0;\n    mid = (mid + Math.imul(al0, bh4)) | 0;\n    mid = (mid + Math.imul(ah0, bl4)) | 0;\n    hi = (hi + Math.imul(ah0, bh4)) | 0;\n    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\n    w4 &= 0x3ffffff;\n    /* k = 5 */\n    lo = Math.imul(al5, bl0);\n    mid = Math.imul(al5, bh0);\n    mid = (mid + Math.imul(ah5, bl0)) | 0;\n    hi = Math.imul(ah5, bh0);\n    lo = (lo + Math.imul(al4, bl1)) | 0;\n    mid = (mid + Math.imul(al4, bh1)) | 0;\n    mid = (mid + Math.imul(ah4, bl1)) | 0;\n    hi = (hi + Math.imul(ah4, bh1)) | 0;\n    lo = (lo + Math.imul(al3, bl2)) | 0;\n    mid = (mid + Math.imul(al3, bh2)) | 0;\n    mid = (mid + Math.imul(ah3, bl2)) | 0;\n    hi = (hi + Math.imul(ah3, bh2)) | 0;\n    lo = (lo + Math.imul(al2, bl3)) | 0;\n    mid = (mid + Math.imul(al2, bh3)) | 0;\n    mid = (mid + Math.imul(ah2, bl3)) | 0;\n    hi = (hi + Math.imul(ah2, bh3)) | 0;\n    lo = (lo + Math.imul(al1, bl4)) | 0;\n    mid = (mid + Math.imul(al1, bh4)) | 0;\n    mid = (mid + Math.imul(ah1, bl4)) | 0;\n    hi = (hi + Math.imul(ah1, bh4)) | 0;\n    lo = (lo + Math.imul(al0, bl5)) | 0;\n    mid = (mid + Math.imul(al0, bh5)) | 0;\n    mid = (mid + Math.imul(ah0, bl5)) | 0;\n    hi = (hi + Math.imul(ah0, bh5)) | 0;\n    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\n    w5 &= 0x3ffffff;\n    /* k = 6 */\n    lo = Math.imul(al6, bl0);\n    mid = Math.imul(al6, bh0);\n    mid = (mid + Math.imul(ah6, bl0)) | 0;\n    hi = Math.imul(ah6, bh0);\n    lo = (lo + Math.imul(al5, bl1)) | 0;\n    mid = (mid + Math.imul(al5, bh1)) | 0;\n    mid = (mid + Math.imul(ah5, bl1)) | 0;\n    hi = (hi + Math.imul(ah5, bh1)) | 0;\n    lo = (lo + Math.imul(al4, bl2)) | 0;\n    mid = (mid + Math.imul(al4, bh2)) | 0;\n    mid = (mid + Math.imul(ah4, bl2)) | 0;\n    hi = (hi + Math.imul(ah4, bh2)) | 0;\n    lo = (lo + Math.imul(al3, bl3)) | 0;\n    mid = (mid + Math.imul(al3, bh3)) | 0;\n    mid = (mid + Math.imul(ah3, bl3)) | 0;\n    hi = (hi + Math.imul(ah3, bh3)) | 0;\n    lo = (lo + Math.imul(al2, bl4)) | 0;\n    mid = (mid + Math.imul(al2, bh4)) | 0;\n    mid = (mid + Math.imul(ah2, bl4)) | 0;\n    hi = (hi + Math.imul(ah2, bh4)) | 0;\n    lo = (lo + Math.imul(al1, bl5)) | 0;\n    mid = (mid + Math.imul(al1, bh5)) | 0;\n    mid = (mid + Math.imul(ah1, bl5)) | 0;\n    hi = (hi + Math.imul(ah1, bh5)) | 0;\n    lo = (lo + Math.imul(al0, bl6)) | 0;\n    mid = (mid + Math.imul(al0, bh6)) | 0;\n    mid = (mid + Math.imul(ah0, bl6)) | 0;\n    hi = (hi + Math.imul(ah0, bh6)) | 0;\n    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\n    w6 &= 0x3ffffff;\n    /* k = 7 */\n    lo = Math.imul(al7, bl0);\n    mid = Math.imul(al7, bh0);\n    mid = (mid + Math.imul(ah7, bl0)) | 0;\n    hi = Math.imul(ah7, bh0);\n    lo = (lo + Math.imul(al6, bl1)) | 0;\n    mid = (mid + Math.imul(al6, bh1)) | 0;\n    mid = (mid + Math.imul(ah6, bl1)) | 0;\n    hi = (hi + Math.imul(ah6, bh1)) | 0;\n    lo = (lo + Math.imul(al5, bl2)) | 0;\n    mid = (mid + Math.imul(al5, bh2)) | 0;\n    mid = (mid + Math.imul(ah5, bl2)) | 0;\n    hi = (hi + Math.imul(ah5, bh2)) | 0;\n    lo = (lo + Math.imul(al4, bl3)) | 0;\n    mid = (mid + Math.imul(al4, bh3)) | 0;\n    mid = (mid + Math.imul(ah4, bl3)) | 0;\n    hi = (hi + Math.imul(ah4, bh3)) | 0;\n    lo = (lo + Math.imul(al3, bl4)) | 0;\n    mid = (mid + Math.imul(al3, bh4)) | 0;\n    mid = (mid + Math.imul(ah3, bl4)) | 0;\n    hi = (hi + Math.imul(ah3, bh4)) | 0;\n    lo = (lo + Math.imul(al2, bl5)) | 0;\n    mid = (mid + Math.imul(al2, bh5)) | 0;\n    mid = (mid + Math.imul(ah2, bl5)) | 0;\n    hi = (hi + Math.imul(ah2, bh5)) | 0;\n    lo = (lo + Math.imul(al1, bl6)) | 0;\n    mid = (mid + Math.imul(al1, bh6)) | 0;\n    mid = (mid + Math.imul(ah1, bl6)) | 0;\n    hi = (hi + Math.imul(ah1, bh6)) | 0;\n    lo = (lo + Math.imul(al0, bl7)) | 0;\n    mid = (mid + Math.imul(al0, bh7)) | 0;\n    mid = (mid + Math.imul(ah0, bl7)) | 0;\n    hi = (hi + Math.imul(ah0, bh7)) | 0;\n    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\n    w7 &= 0x3ffffff;\n    /* k = 8 */\n    lo = Math.imul(al8, bl0);\n    mid = Math.imul(al8, bh0);\n    mid = (mid + Math.imul(ah8, bl0)) | 0;\n    hi = Math.imul(ah8, bh0);\n    lo = (lo + Math.imul(al7, bl1)) | 0;\n    mid = (mid + Math.imul(al7, bh1)) | 0;\n    mid = (mid + Math.imul(ah7, bl1)) | 0;\n    hi = (hi + Math.imul(ah7, bh1)) | 0;\n    lo = (lo + Math.imul(al6, bl2)) | 0;\n    mid = (mid + Math.imul(al6, bh2)) | 0;\n    mid = (mid + Math.imul(ah6, bl2)) | 0;\n    hi = (hi + Math.imul(ah6, bh2)) | 0;\n    lo = (lo + Math.imul(al5, bl3)) | 0;\n    mid = (mid + Math.imul(al5, bh3)) | 0;\n    mid = (mid + Math.imul(ah5, bl3)) | 0;\n    hi = (hi + Math.imul(ah5, bh3)) | 0;\n    lo = (lo + Math.imul(al4, bl4)) | 0;\n    mid = (mid + Math.imul(al4, bh4)) | 0;\n    mid = (mid + Math.imul(ah4, bl4)) | 0;\n    hi = (hi + Math.imul(ah4, bh4)) | 0;\n    lo = (lo + Math.imul(al3, bl5)) | 0;\n    mid = (mid + Math.imul(al3, bh5)) | 0;\n    mid = (mid + Math.imul(ah3, bl5)) | 0;\n    hi = (hi + Math.imul(ah3, bh5)) | 0;\n    lo = (lo + Math.imul(al2, bl6)) | 0;\n    mid = (mid + Math.imul(al2, bh6)) | 0;\n    mid = (mid + Math.imul(ah2, bl6)) | 0;\n    hi = (hi + Math.imul(ah2, bh6)) | 0;\n    lo = (lo + Math.imul(al1, bl7)) | 0;\n    mid = (mid + Math.imul(al1, bh7)) | 0;\n    mid = (mid + Math.imul(ah1, bl7)) | 0;\n    hi = (hi + Math.imul(ah1, bh7)) | 0;\n    lo = (lo + Math.imul(al0, bl8)) | 0;\n    mid = (mid + Math.imul(al0, bh8)) | 0;\n    mid = (mid + Math.imul(ah0, bl8)) | 0;\n    hi = (hi + Math.imul(ah0, bh8)) | 0;\n    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\n    w8 &= 0x3ffffff;\n    /* k = 9 */\n    lo = Math.imul(al9, bl0);\n    mid = Math.imul(al9, bh0);\n    mid = (mid + Math.imul(ah9, bl0)) | 0;\n    hi = Math.imul(ah9, bh0);\n    lo = (lo + Math.imul(al8, bl1)) | 0;\n    mid = (mid + Math.imul(al8, bh1)) | 0;\n    mid = (mid + Math.imul(ah8, bl1)) | 0;\n    hi = (hi + Math.imul(ah8, bh1)) | 0;\n    lo = (lo + Math.imul(al7, bl2)) | 0;\n    mid = (mid + Math.imul(al7, bh2)) | 0;\n    mid = (mid + Math.imul(ah7, bl2)) | 0;\n    hi = (hi + Math.imul(ah7, bh2)) | 0;\n    lo = (lo + Math.imul(al6, bl3)) | 0;\n    mid = (mid + Math.imul(al6, bh3)) | 0;\n    mid = (mid + Math.imul(ah6, bl3)) | 0;\n    hi = (hi + Math.imul(ah6, bh3)) | 0;\n    lo = (lo + Math.imul(al5, bl4)) | 0;\n    mid = (mid + Math.imul(al5, bh4)) | 0;\n    mid = (mid + Math.imul(ah5, bl4)) | 0;\n    hi = (hi + Math.imul(ah5, bh4)) | 0;\n    lo = (lo + Math.imul(al4, bl5)) | 0;\n    mid = (mid + Math.imul(al4, bh5)) | 0;\n    mid = (mid + Math.imul(ah4, bl5)) | 0;\n    hi = (hi + Math.imul(ah4, bh5)) | 0;\n    lo = (lo + Math.imul(al3, bl6)) | 0;\n    mid = (mid + Math.imul(al3, bh6)) | 0;\n    mid = (mid + Math.imul(ah3, bl6)) | 0;\n    hi = (hi + Math.imul(ah3, bh6)) | 0;\n    lo = (lo + Math.imul(al2, bl7)) | 0;\n    mid = (mid + Math.imul(al2, bh7)) | 0;\n    mid = (mid + Math.imul(ah2, bl7)) | 0;\n    hi = (hi + Math.imul(ah2, bh7)) | 0;\n    lo = (lo + Math.imul(al1, bl8)) | 0;\n    mid = (mid + Math.imul(al1, bh8)) | 0;\n    mid = (mid + Math.imul(ah1, bl8)) | 0;\n    hi = (hi + Math.imul(ah1, bh8)) | 0;\n    lo = (lo + Math.imul(al0, bl9)) | 0;\n    mid = (mid + Math.imul(al0, bh9)) | 0;\n    mid = (mid + Math.imul(ah0, bl9)) | 0;\n    hi = (hi + Math.imul(ah0, bh9)) | 0;\n    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\n    w9 &= 0x3ffffff;\n    /* k = 10 */\n    lo = Math.imul(al9, bl1);\n    mid = Math.imul(al9, bh1);\n    mid = (mid + Math.imul(ah9, bl1)) | 0;\n    hi = Math.imul(ah9, bh1);\n    lo = (lo + Math.imul(al8, bl2)) | 0;\n    mid = (mid + Math.imul(al8, bh2)) | 0;\n    mid = (mid + Math.imul(ah8, bl2)) | 0;\n    hi = (hi + Math.imul(ah8, bh2)) | 0;\n    lo = (lo + Math.imul(al7, bl3)) | 0;\n    mid = (mid + Math.imul(al7, bh3)) | 0;\n    mid = (mid + Math.imul(ah7, bl3)) | 0;\n    hi = (hi + Math.imul(ah7, bh3)) | 0;\n    lo = (lo + Math.imul(al6, bl4)) | 0;\n    mid = (mid + Math.imul(al6, bh4)) | 0;\n    mid = (mid + Math.imul(ah6, bl4)) | 0;\n    hi = (hi + Math.imul(ah6, bh4)) | 0;\n    lo = (lo + Math.imul(al5, bl5)) | 0;\n    mid = (mid + Math.imul(al5, bh5)) | 0;\n    mid = (mid + Math.imul(ah5, bl5)) | 0;\n    hi = (hi + Math.imul(ah5, bh5)) | 0;\n    lo = (lo + Math.imul(al4, bl6)) | 0;\n    mid = (mid + Math.imul(al4, bh6)) | 0;\n    mid = (mid + Math.imul(ah4, bl6)) | 0;\n    hi = (hi + Math.imul(ah4, bh6)) | 0;\n    lo = (lo + Math.imul(al3, bl7)) | 0;\n    mid = (mid + Math.imul(al3, bh7)) | 0;\n    mid = (mid + Math.imul(ah3, bl7)) | 0;\n    hi = (hi + Math.imul(ah3, bh7)) | 0;\n    lo = (lo + Math.imul(al2, bl8)) | 0;\n    mid = (mid + Math.imul(al2, bh8)) | 0;\n    mid = (mid + Math.imul(ah2, bl8)) | 0;\n    hi = (hi + Math.imul(ah2, bh8)) | 0;\n    lo = (lo + Math.imul(al1, bl9)) | 0;\n    mid = (mid + Math.imul(al1, bh9)) | 0;\n    mid = (mid + Math.imul(ah1, bl9)) | 0;\n    hi = (hi + Math.imul(ah1, bh9)) | 0;\n    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\n    w10 &= 0x3ffffff;\n    /* k = 11 */\n    lo = Math.imul(al9, bl2);\n    mid = Math.imul(al9, bh2);\n    mid = (mid + Math.imul(ah9, bl2)) | 0;\n    hi = Math.imul(ah9, bh2);\n    lo = (lo + Math.imul(al8, bl3)) | 0;\n    mid = (mid + Math.imul(al8, bh3)) | 0;\n    mid = (mid + Math.imul(ah8, bl3)) | 0;\n    hi = (hi + Math.imul(ah8, bh3)) | 0;\n    lo = (lo + Math.imul(al7, bl4)) | 0;\n    mid = (mid + Math.imul(al7, bh4)) | 0;\n    mid = (mid + Math.imul(ah7, bl4)) | 0;\n    hi = (hi + Math.imul(ah7, bh4)) | 0;\n    lo = (lo + Math.imul(al6, bl5)) | 0;\n    mid = (mid + Math.imul(al6, bh5)) | 0;\n    mid = (mid + Math.imul(ah6, bl5)) | 0;\n    hi = (hi + Math.imul(ah6, bh5)) | 0;\n    lo = (lo + Math.imul(al5, bl6)) | 0;\n    mid = (mid + Math.imul(al5, bh6)) | 0;\n    mid = (mid + Math.imul(ah5, bl6)) | 0;\n    hi = (hi + Math.imul(ah5, bh6)) | 0;\n    lo = (lo + Math.imul(al4, bl7)) | 0;\n    mid = (mid + Math.imul(al4, bh7)) | 0;\n    mid = (mid + Math.imul(ah4, bl7)) | 0;\n    hi = (hi + Math.imul(ah4, bh7)) | 0;\n    lo = (lo + Math.imul(al3, bl8)) | 0;\n    mid = (mid + Math.imul(al3, bh8)) | 0;\n    mid = (mid + Math.imul(ah3, bl8)) | 0;\n    hi = (hi + Math.imul(ah3, bh8)) | 0;\n    lo = (lo + Math.imul(al2, bl9)) | 0;\n    mid = (mid + Math.imul(al2, bh9)) | 0;\n    mid = (mid + Math.imul(ah2, bl9)) | 0;\n    hi = (hi + Math.imul(ah2, bh9)) | 0;\n    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\n    w11 &= 0x3ffffff;\n    /* k = 12 */\n    lo = Math.imul(al9, bl3);\n    mid = Math.imul(al9, bh3);\n    mid = (mid + Math.imul(ah9, bl3)) | 0;\n    hi = Math.imul(ah9, bh3);\n    lo = (lo + Math.imul(al8, bl4)) | 0;\n    mid = (mid + Math.imul(al8, bh4)) | 0;\n    mid = (mid + Math.imul(ah8, bl4)) | 0;\n    hi = (hi + Math.imul(ah8, bh4)) | 0;\n    lo = (lo + Math.imul(al7, bl5)) | 0;\n    mid = (mid + Math.imul(al7, bh5)) | 0;\n    mid = (mid + Math.imul(ah7, bl5)) | 0;\n    hi = (hi + Math.imul(ah7, bh5)) | 0;\n    lo = (lo + Math.imul(al6, bl6)) | 0;\n    mid = (mid + Math.imul(al6, bh6)) | 0;\n    mid = (mid + Math.imul(ah6, bl6)) | 0;\n    hi = (hi + Math.imul(ah6, bh6)) | 0;\n    lo = (lo + Math.imul(al5, bl7)) | 0;\n    mid = (mid + Math.imul(al5, bh7)) | 0;\n    mid = (mid + Math.imul(ah5, bl7)) | 0;\n    hi = (hi + Math.imul(ah5, bh7)) | 0;\n    lo = (lo + Math.imul(al4, bl8)) | 0;\n    mid = (mid + Math.imul(al4, bh8)) | 0;\n    mid = (mid + Math.imul(ah4, bl8)) | 0;\n    hi = (hi + Math.imul(ah4, bh8)) | 0;\n    lo = (lo + Math.imul(al3, bl9)) | 0;\n    mid = (mid + Math.imul(al3, bh9)) | 0;\n    mid = (mid + Math.imul(ah3, bl9)) | 0;\n    hi = (hi + Math.imul(ah3, bh9)) | 0;\n    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\n    w12 &= 0x3ffffff;\n    /* k = 13 */\n    lo = Math.imul(al9, bl4);\n    mid = Math.imul(al9, bh4);\n    mid = (mid + Math.imul(ah9, bl4)) | 0;\n    hi = Math.imul(ah9, bh4);\n    lo = (lo + Math.imul(al8, bl5)) | 0;\n    mid = (mid + Math.imul(al8, bh5)) | 0;\n    mid = (mid + Math.imul(ah8, bl5)) | 0;\n    hi = (hi + Math.imul(ah8, bh5)) | 0;\n    lo = (lo + Math.imul(al7, bl6)) | 0;\n    mid = (mid + Math.imul(al7, bh6)) | 0;\n    mid = (mid + Math.imul(ah7, bl6)) | 0;\n    hi = (hi + Math.imul(ah7, bh6)) | 0;\n    lo = (lo + Math.imul(al6, bl7)) | 0;\n    mid = (mid + Math.imul(al6, bh7)) | 0;\n    mid = (mid + Math.imul(ah6, bl7)) | 0;\n    hi = (hi + Math.imul(ah6, bh7)) | 0;\n    lo = (lo + Math.imul(al5, bl8)) | 0;\n    mid = (mid + Math.imul(al5, bh8)) | 0;\n    mid = (mid + Math.imul(ah5, bl8)) | 0;\n    hi = (hi + Math.imul(ah5, bh8)) | 0;\n    lo = (lo + Math.imul(al4, bl9)) | 0;\n    mid = (mid + Math.imul(al4, bh9)) | 0;\n    mid = (mid + Math.imul(ah4, bl9)) | 0;\n    hi = (hi + Math.imul(ah4, bh9)) | 0;\n    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\n    w13 &= 0x3ffffff;\n    /* k = 14 */\n    lo = Math.imul(al9, bl5);\n    mid = Math.imul(al9, bh5);\n    mid = (mid + Math.imul(ah9, bl5)) | 0;\n    hi = Math.imul(ah9, bh5);\n    lo = (lo + Math.imul(al8, bl6)) | 0;\n    mid = (mid + Math.imul(al8, bh6)) | 0;\n    mid = (mid + Math.imul(ah8, bl6)) | 0;\n    hi = (hi + Math.imul(ah8, bh6)) | 0;\n    lo = (lo + Math.imul(al7, bl7)) | 0;\n    mid = (mid + Math.imul(al7, bh7)) | 0;\n    mid = (mid + Math.imul(ah7, bl7)) | 0;\n    hi = (hi + Math.imul(ah7, bh7)) | 0;\n    lo = (lo + Math.imul(al6, bl8)) | 0;\n    mid = (mid + Math.imul(al6, bh8)) | 0;\n    mid = (mid + Math.imul(ah6, bl8)) | 0;\n    hi = (hi + Math.imul(ah6, bh8)) | 0;\n    lo = (lo + Math.imul(al5, bl9)) | 0;\n    mid = (mid + Math.imul(al5, bh9)) | 0;\n    mid = (mid + Math.imul(ah5, bl9)) | 0;\n    hi = (hi + Math.imul(ah5, bh9)) | 0;\n    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\n    w14 &= 0x3ffffff;\n    /* k = 15 */\n    lo = Math.imul(al9, bl6);\n    mid = Math.imul(al9, bh6);\n    mid = (mid + Math.imul(ah9, bl6)) | 0;\n    hi = Math.imul(ah9, bh6);\n    lo = (lo + Math.imul(al8, bl7)) | 0;\n    mid = (mid + Math.imul(al8, bh7)) | 0;\n    mid = (mid + Math.imul(ah8, bl7)) | 0;\n    hi = (hi + Math.imul(ah8, bh7)) | 0;\n    lo = (lo + Math.imul(al7, bl8)) | 0;\n    mid = (mid + Math.imul(al7, bh8)) | 0;\n    mid = (mid + Math.imul(ah7, bl8)) | 0;\n    hi = (hi + Math.imul(ah7, bh8)) | 0;\n    lo = (lo + Math.imul(al6, bl9)) | 0;\n    mid = (mid + Math.imul(al6, bh9)) | 0;\n    mid = (mid + Math.imul(ah6, bl9)) | 0;\n    hi = (hi + Math.imul(ah6, bh9)) | 0;\n    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\n    w15 &= 0x3ffffff;\n    /* k = 16 */\n    lo = Math.imul(al9, bl7);\n    mid = Math.imul(al9, bh7);\n    mid = (mid + Math.imul(ah9, bl7)) | 0;\n    hi = Math.imul(ah9, bh7);\n    lo = (lo + Math.imul(al8, bl8)) | 0;\n    mid = (mid + Math.imul(al8, bh8)) | 0;\n    mid = (mid + Math.imul(ah8, bl8)) | 0;\n    hi = (hi + Math.imul(ah8, bh8)) | 0;\n    lo = (lo + Math.imul(al7, bl9)) | 0;\n    mid = (mid + Math.imul(al7, bh9)) | 0;\n    mid = (mid + Math.imul(ah7, bl9)) | 0;\n    hi = (hi + Math.imul(ah7, bh9)) | 0;\n    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\n    w16 &= 0x3ffffff;\n    /* k = 17 */\n    lo = Math.imul(al9, bl8);\n    mid = Math.imul(al9, bh8);\n    mid = (mid + Math.imul(ah9, bl8)) | 0;\n    hi = Math.imul(ah9, bh8);\n    lo = (lo + Math.imul(al8, bl9)) | 0;\n    mid = (mid + Math.imul(al8, bh9)) | 0;\n    mid = (mid + Math.imul(ah8, bl9)) | 0;\n    hi = (hi + Math.imul(ah8, bh9)) | 0;\n    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\n    w17 &= 0x3ffffff;\n    /* k = 18 */\n    lo = Math.imul(al9, bl9);\n    mid = Math.imul(al9, bh9);\n    mid = (mid + Math.imul(ah9, bl9)) | 0;\n    hi = Math.imul(ah9, bh9);\n    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\n    w18 &= 0x3ffffff;\n    o[0] = w0;\n    o[1] = w1;\n    o[2] = w2;\n    o[3] = w3;\n    o[4] = w4;\n    o[5] = w5;\n    o[6] = w6;\n    o[7] = w7;\n    o[8] = w8;\n    o[9] = w9;\n    o[10] = w10;\n    o[11] = w11;\n    o[12] = w12;\n    o[13] = w13;\n    o[14] = w14;\n    o[15] = w15;\n    o[16] = w16;\n    o[17] = w17;\n    o[18] = w18;\n    if (c !== 0) {\n      o[19] = c;\n      out.length++;\n    }\n    return out;\n  };\n\n  // Polyfill comb\n  if (!Math.imul) {\n    comb10MulTo = smallMulTo;\n  }\n\n  function bigMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    out.length = self.length + num.length;\n\n    var carry = 0;\n    var hncarry = 0;\n    for (var k = 0; k < out.length - 1; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = hncarry;\n      hncarry = 0;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = k - j;\n        var a = self.words[i] | 0;\n        var b = num.words[j] | 0;\n        var r = a * b;\n\n        var lo = r & 0x3ffffff;\n        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n        lo = (lo + rword) | 0;\n        rword = lo & 0x3ffffff;\n        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n        hncarry += ncarry >>> 26;\n        ncarry &= 0x3ffffff;\n      }\n      out.words[k] = rword;\n      carry = ncarry;\n      ncarry = hncarry;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry;\n    } else {\n      out.length--;\n    }\n\n    return out.strip();\n  }\n\n  function jumboMulTo (self, num, out) {\n    var fftm = new FFTM();\n    return fftm.mulp(self, num, out);\n  }\n\n  BN.prototype.mulTo = function mulTo (num, out) {\n    var res;\n    var len = this.length + num.length;\n    if (this.length === 10 && num.length === 10) {\n      res = comb10MulTo(this, num, out);\n    } else if (len < 63) {\n      res = smallMulTo(this, num, out);\n    } else if (len < 1024) {\n      res = bigMulTo(this, num, out);\n    } else {\n      res = jumboMulTo(this, num, out);\n    }\n\n    return res;\n  };\n\n  // Cooley-Tukey algorithm for FFT\n  // slightly revisited to rely on looping instead of recursion\n\n  function FFTM (x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  FFTM.prototype.makeRBT = function makeRBT (N) {\n    var t = new Array(N);\n    var l = BN.prototype._countBits(N) - 1;\n    for (var i = 0; i < N; i++) {\n      t[i] = this.revBin(i, l, N);\n    }\n\n    return t;\n  };\n\n  // Returns binary-reversed representation of `x`\n  FFTM.prototype.revBin = function revBin (x, l, N) {\n    if (x === 0 || x === N - 1) return x;\n\n    var rb = 0;\n    for (var i = 0; i < l; i++) {\n      rb |= (x & 1) << (l - i - 1);\n      x >>= 1;\n    }\n\n    return rb;\n  };\n\n  // Performs \"tweedling\" phase, therefore 'emulating'\n  // behaviour of the recursive algorithm\n  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n    for (var i = 0; i < N; i++) {\n      rtws[i] = rws[rbt[i]];\n      itws[i] = iws[rbt[i]];\n    }\n  };\n\n  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n    this.permute(rbt, rws, iws, rtws, itws, N);\n\n    for (var s = 1; s < N; s <<= 1) {\n      var l = s << 1;\n\n      var rtwdf = Math.cos(2 * Math.PI / l);\n      var itwdf = Math.sin(2 * Math.PI / l);\n\n      for (var p = 0; p < N; p += l) {\n        var rtwdf_ = rtwdf;\n        var itwdf_ = itwdf;\n\n        for (var j = 0; j < s; j++) {\n          var re = rtws[p + j];\n          var ie = itws[p + j];\n\n          var ro = rtws[p + j + s];\n          var io = itws[p + j + s];\n\n          var rx = rtwdf_ * ro - itwdf_ * io;\n\n          io = rtwdf_ * io + itwdf_ * ro;\n          ro = rx;\n\n          rtws[p + j] = re + ro;\n          itws[p + j] = ie + io;\n\n          rtws[p + j + s] = re - ro;\n          itws[p + j + s] = ie - io;\n\n          /* jshint maxdepth : false */\n          if (j !== l) {\n            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n            rtwdf_ = rx;\n          }\n        }\n      }\n    }\n  };\n\n  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n    var N = Math.max(m, n) | 1;\n    var odd = N & 1;\n    var i = 0;\n    for (N = N / 2 | 0; N; N = N >>> 1) {\n      i++;\n    }\n\n    return 1 << i + 1 + odd;\n  };\n\n  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n    if (N <= 1) return;\n\n    for (var i = 0; i < N / 2; i++) {\n      var t = rws[i];\n\n      rws[i] = rws[N - i - 1];\n      rws[N - i - 1] = t;\n\n      t = iws[i];\n\n      iws[i] = -iws[N - i - 1];\n      iws[N - i - 1] = -t;\n    }\n  };\n\n  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n    var carry = 0;\n    for (var i = 0; i < N / 2; i++) {\n      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n        Math.round(ws[2 * i] / N) +\n        carry;\n\n      ws[i] = w & 0x3ffffff;\n\n      if (w < 0x4000000) {\n        carry = 0;\n      } else {\n        carry = w / 0x4000000 | 0;\n      }\n    }\n\n    return ws;\n  };\n\n  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n    var carry = 0;\n    for (var i = 0; i < len; i++) {\n      carry = carry + (ws[i] | 0);\n\n      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n    }\n\n    // Pad with zeroes\n    for (i = 2 * len; i < N; ++i) {\n      rws[i] = 0;\n    }\n\n    assert(carry === 0);\n    assert((carry & ~0x1fff) === 0);\n  };\n\n  FFTM.prototype.stub = function stub (N) {\n    var ph = new Array(N);\n    for (var i = 0; i < N; i++) {\n      ph[i] = 0;\n    }\n\n    return ph;\n  };\n\n  FFTM.prototype.mulp = function mulp (x, y, out) {\n    var N = 2 * this.guessLen13b(x.length, y.length);\n\n    var rbt = this.makeRBT(N);\n\n    var _ = this.stub(N);\n\n    var rws = new Array(N);\n    var rwst = new Array(N);\n    var iwst = new Array(N);\n\n    var nrws = new Array(N);\n    var nrwst = new Array(N);\n    var niwst = new Array(N);\n\n    var rmws = out.words;\n    rmws.length = N;\n\n    this.convert13b(x.words, x.length, rws, N);\n    this.convert13b(y.words, y.length, nrws, N);\n\n    this.transform(rws, _, rwst, iwst, N, rbt);\n    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n    for (var i = 0; i < N; i++) {\n      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n      rwst[i] = rx;\n    }\n\n    this.conjugate(rwst, iwst, N);\n    this.transform(rwst, iwst, rmws, _, N, rbt);\n    this.conjugate(rmws, _, N);\n    this.normalize13b(rmws, N);\n\n    out.negative = x.negative ^ y.negative;\n    out.length = x.length + y.length;\n    return out.strip();\n  };\n\n  // Multiply `this` by `num`\n  BN.prototype.mul = function mul (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return this.mulTo(num, out);\n  };\n\n  // Multiply employing FFT\n  BN.prototype.mulf = function mulf (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return jumboMulTo(this, num, out);\n  };\n\n  // In-place Multiplication\n  BN.prototype.imul = function imul (num) {\n    return this.clone().mulTo(num, this);\n  };\n\n  BN.prototype.imuln = function imuln (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n\n    // Carry\n    var carry = 0;\n    for (var i = 0; i < this.length; i++) {\n      var w = (this.words[i] | 0) * num;\n      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n      carry >>= 26;\n      carry += (w / 0x4000000) | 0;\n      // NOTE: lo is 27bit maximum\n      carry += lo >>> 26;\n      this.words[i] = lo & 0x3ffffff;\n    }\n\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n\n    return this;\n  };\n\n  BN.prototype.muln = function muln (num) {\n    return this.clone().imuln(num);\n  };\n\n  // `this` * `this`\n  BN.prototype.sqr = function sqr () {\n    return this.mul(this);\n  };\n\n  // `this` * `this` in-place\n  BN.prototype.isqr = function isqr () {\n    return this.imul(this.clone());\n  };\n\n  // Math.pow(`this`, `num`)\n  BN.prototype.pow = function pow (num) {\n    var w = toBitArray(num);\n    if (w.length === 0) return new BN(1);\n\n    // Skip leading zeroes\n    var res = this;\n    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n      if (w[i] !== 0) break;\n    }\n\n    if (++i < w.length) {\n      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n        if (w[i] === 0) continue;\n\n        res = res.mul(q);\n      }\n    }\n\n    return res;\n  };\n\n  // Shift-left in-place\n  BN.prototype.iushln = function iushln (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n    var i;\n\n    if (r !== 0) {\n      var carry = 0;\n\n      for (i = 0; i < this.length; i++) {\n        var newCarry = this.words[i] & carryMask;\n        var c = ((this.words[i] | 0) - newCarry) << r;\n        this.words[i] = c | carry;\n        carry = newCarry >>> (26 - r);\n      }\n\n      if (carry) {\n        this.words[i] = carry;\n        this.length++;\n      }\n    }\n\n    if (s !== 0) {\n      for (i = this.length - 1; i >= 0; i--) {\n        this.words[i + s] = this.words[i];\n      }\n\n      for (i = 0; i < s; i++) {\n        this.words[i] = 0;\n      }\n\n      this.length += s;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ishln = function ishln (bits) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushln(bits);\n  };\n\n  // Shift-right in-place\n  // NOTE: `hint` is a lowest bit before trailing zeroes\n  // NOTE: if `extended` is present - it will be filled with destroyed bits\n  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var h;\n    if (hint) {\n      h = (hint - (hint % 26)) / 26;\n    } else {\n      h = 0;\n    }\n\n    var r = bits % 26;\n    var s = Math.min((bits - r) / 26, this.length);\n    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n    var maskedWords = extended;\n\n    h -= s;\n    h = Math.max(0, h);\n\n    // Extended mode, copy masked part\n    if (maskedWords) {\n      for (var i = 0; i < s; i++) {\n        maskedWords.words[i] = this.words[i];\n      }\n      maskedWords.length = s;\n    }\n\n    if (s === 0) {\n      // No-op, we should not move anything at all\n    } else if (this.length > s) {\n      this.length -= s;\n      for (i = 0; i < this.length; i++) {\n        this.words[i] = this.words[i + s];\n      }\n    } else {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    var carry = 0;\n    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n      var word = this.words[i] | 0;\n      this.words[i] = (carry << (26 - r)) | (word >>> r);\n      carry = word & mask;\n    }\n\n    // Push carried bits as a mask\n    if (maskedWords && carry !== 0) {\n      maskedWords.words[maskedWords.length++] = carry;\n    }\n\n    if (this.length === 0) {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushrn(bits, hint, extended);\n  };\n\n  // Shift-left\n  BN.prototype.shln = function shln (bits) {\n    return this.clone().ishln(bits);\n  };\n\n  BN.prototype.ushln = function ushln (bits) {\n    return this.clone().iushln(bits);\n  };\n\n  // Shift-right\n  BN.prototype.shrn = function shrn (bits) {\n    return this.clone().ishrn(bits);\n  };\n\n  BN.prototype.ushrn = function ushrn (bits) {\n    return this.clone().iushrn(bits);\n  };\n\n  // Test if n bit is set\n  BN.prototype.testn = function testn (bit) {\n    assert(typeof bit === 'number' && bit >= 0);\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) return false;\n\n    // Check bit and return\n    var w = this.words[s];\n\n    return !!(w & q);\n  };\n\n  // Return only lowers bits of number (in-place)\n  BN.prototype.imaskn = function imaskn (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n\n    assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n    if (this.length <= s) {\n      return this;\n    }\n\n    if (r !== 0) {\n      s++;\n    }\n    this.length = Math.min(s, this.length);\n\n    if (r !== 0) {\n      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n      this.words[this.length - 1] &= mask;\n    }\n\n    return this.strip();\n  };\n\n  // Return only lowers bits of number\n  BN.prototype.maskn = function maskn (bits) {\n    return this.clone().imaskn(bits);\n  };\n\n  // Add plain number `num` to `this`\n  BN.prototype.iaddn = function iaddn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.isubn(-num);\n\n    // Possible sign change\n    if (this.negative !== 0) {\n      if (this.length === 1 && (this.words[0] | 0) < num) {\n        this.words[0] = num - (this.words[0] | 0);\n        this.negative = 0;\n        return this;\n      }\n\n      this.negative = 0;\n      this.isubn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    // Add without checks\n    return this._iaddn(num);\n  };\n\n  BN.prototype._iaddn = function _iaddn (num) {\n    this.words[0] += num;\n\n    // Carry\n    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n      this.words[i] -= 0x4000000;\n      if (i === this.length - 1) {\n        this.words[i + 1] = 1;\n      } else {\n        this.words[i + 1]++;\n      }\n    }\n    this.length = Math.max(this.length, i + 1);\n\n    return this;\n  };\n\n  // Subtract plain number `num` from `this`\n  BN.prototype.isubn = function isubn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.iaddn(-num);\n\n    if (this.negative !== 0) {\n      this.negative = 0;\n      this.iaddn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    this.words[0] -= num;\n\n    if (this.length === 1 && this.words[0] < 0) {\n      this.words[0] = -this.words[0];\n      this.negative = 1;\n    } else {\n      // Carry\n      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n        this.words[i] += 0x4000000;\n        this.words[i + 1] -= 1;\n      }\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.addn = function addn (num) {\n    return this.clone().iaddn(num);\n  };\n\n  BN.prototype.subn = function subn (num) {\n    return this.clone().isubn(num);\n  };\n\n  BN.prototype.iabs = function iabs () {\n    this.negative = 0;\n\n    return this;\n  };\n\n  BN.prototype.abs = function abs () {\n    return this.clone().iabs();\n  };\n\n  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n    var len = num.length + shift;\n    var i;\n\n    this._expand(len);\n\n    var w;\n    var carry = 0;\n    for (i = 0; i < num.length; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      var right = (num.words[i] | 0) * mul;\n      w -= right & 0x3ffffff;\n      carry = (w >> 26) - ((right / 0x4000000) | 0);\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n    for (; i < this.length - shift; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      carry = w >> 26;\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    if (carry === 0) return this.strip();\n\n    // Subtraction overflow\n    assert(carry === -1);\n    carry = 0;\n    for (i = 0; i < this.length; i++) {\n      w = -(this.words[i] | 0) + carry;\n      carry = w >> 26;\n      this.words[i] = w & 0x3ffffff;\n    }\n    this.negative = 1;\n\n    return this.strip();\n  };\n\n  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n    var shift = this.length - num.length;\n\n    var a = this.clone();\n    var b = num;\n\n    // Normalize\n    var bhi = b.words[b.length - 1] | 0;\n    var bhiBits = this._countBits(bhi);\n    shift = 26 - bhiBits;\n    if (shift !== 0) {\n      b = b.ushln(shift);\n      a.iushln(shift);\n      bhi = b.words[b.length - 1] | 0;\n    }\n\n    // Initialize quotient\n    var m = a.length - b.length;\n    var q;\n\n    if (mode !== 'mod') {\n      q = new BN(null);\n      q.length = m + 1;\n      q.words = new Array(q.length);\n      for (var i = 0; i < q.length; i++) {\n        q.words[i] = 0;\n      }\n    }\n\n    var diff = a.clone()._ishlnsubmul(b, 1, m);\n    if (diff.negative === 0) {\n      a = diff;\n      if (q) {\n        q.words[m] = 1;\n      }\n    }\n\n    for (var j = m - 1; j >= 0; j--) {\n      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n        (a.words[b.length + j - 1] | 0);\n\n      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n      // (0x7ffffff)\n      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n      a._ishlnsubmul(b, qj, j);\n      while (a.negative !== 0) {\n        qj--;\n        a.negative = 0;\n        a._ishlnsubmul(b, 1, j);\n        if (!a.isZero()) {\n          a.negative ^= 1;\n        }\n      }\n      if (q) {\n        q.words[j] = qj;\n      }\n    }\n    if (q) {\n      q.strip();\n    }\n    a.strip();\n\n    // Denormalize\n    if (mode !== 'div' && shift !== 0) {\n      a.iushrn(shift);\n    }\n\n    return {\n      div: q || null,\n      mod: a\n    };\n  };\n\n  // NOTE: 1) `mode` can be set to `mod` to request mod only,\n  //       to `div` to request div only, or be absent to\n  //       request both div & mod\n  //       2) `positive` is true if unsigned mod is requested\n  BN.prototype.divmod = function divmod (num, mode, positive) {\n    assert(!num.isZero());\n\n    if (this.isZero()) {\n      return {\n        div: new BN(0),\n        mod: new BN(0)\n      };\n    }\n\n    var div, mod, res;\n    if (this.negative !== 0 && num.negative === 0) {\n      res = this.neg().divmod(num, mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.iadd(num);\n        }\n      }\n\n      return {\n        div: div,\n        mod: mod\n      };\n    }\n\n    if (this.negative === 0 && num.negative !== 0) {\n      res = this.divmod(num.neg(), mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      return {\n        div: div,\n        mod: res.mod\n      };\n    }\n\n    if ((this.negative & num.negative) !== 0) {\n      res = this.neg().divmod(num.neg(), mode);\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.isub(num);\n        }\n      }\n\n      return {\n        div: res.div,\n        mod: mod\n      };\n    }\n\n    // Both numbers are positive at this point\n\n    // Strip both numbers to approximate shift value\n    if (num.length > this.length || this.cmp(num) < 0) {\n      return {\n        div: new BN(0),\n        mod: this\n      };\n    }\n\n    // Very short reduction\n    if (num.length === 1) {\n      if (mode === 'div') {\n        return {\n          div: this.divn(num.words[0]),\n          mod: null\n        };\n      }\n\n      if (mode === 'mod') {\n        return {\n          div: null,\n          mod: new BN(this.modn(num.words[0]))\n        };\n      }\n\n      return {\n        div: this.divn(num.words[0]),\n        mod: new BN(this.modn(num.words[0]))\n      };\n    }\n\n    return this._wordDiv(num, mode);\n  };\n\n  // Find `this` / `num`\n  BN.prototype.div = function div (num) {\n    return this.divmod(num, 'div', false).div;\n  };\n\n  // Find `this` % `num`\n  BN.prototype.mod = function mod (num) {\n    return this.divmod(num, 'mod', false).mod;\n  };\n\n  BN.prototype.umod = function umod (num) {\n    return this.divmod(num, 'mod', true).mod;\n  };\n\n  // Find Round(`this` / `num`)\n  BN.prototype.divRound = function divRound (num) {\n    var dm = this.divmod(num);\n\n    // Fast case - exact division\n    if (dm.mod.isZero()) return dm.div;\n\n    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n    var half = num.ushrn(1);\n    var r2 = num.andln(1);\n    var cmp = mod.cmp(half);\n\n    // Round down\n    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;\n\n    // Round up\n    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n  };\n\n  BN.prototype.modn = function modn (num) {\n    assert(num <= 0x3ffffff);\n    var p = (1 << 26) % num;\n\n    var acc = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      acc = (p * acc + (this.words[i] | 0)) % num;\n    }\n\n    return acc;\n  };\n\n  // In-place division by number\n  BN.prototype.idivn = function idivn (num) {\n    assert(num <= 0x3ffffff);\n\n    var carry = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var w = (this.words[i] | 0) + carry * 0x4000000;\n      this.words[i] = (w / num) | 0;\n      carry = w % num;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.divn = function divn (num) {\n    return this.clone().idivn(num);\n  };\n\n  BN.prototype.egcd = function egcd (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var x = this;\n    var y = p.clone();\n\n    if (x.negative !== 0) {\n      x = x.umod(p);\n    } else {\n      x = x.clone();\n    }\n\n    // A * x + B * y = x\n    var A = new BN(1);\n    var B = new BN(0);\n\n    // C * x + D * y = y\n    var C = new BN(0);\n    var D = new BN(1);\n\n    var g = 0;\n\n    while (x.isEven() && y.isEven()) {\n      x.iushrn(1);\n      y.iushrn(1);\n      ++g;\n    }\n\n    var yp = y.clone();\n    var xp = x.clone();\n\n    while (!x.isZero()) {\n      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        x.iushrn(i);\n        while (i-- > 0) {\n          if (A.isOdd() || B.isOdd()) {\n            A.iadd(yp);\n            B.isub(xp);\n          }\n\n          A.iushrn(1);\n          B.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        y.iushrn(j);\n        while (j-- > 0) {\n          if (C.isOdd() || D.isOdd()) {\n            C.iadd(yp);\n            D.isub(xp);\n          }\n\n          C.iushrn(1);\n          D.iushrn(1);\n        }\n      }\n\n      if (x.cmp(y) >= 0) {\n        x.isub(y);\n        A.isub(C);\n        B.isub(D);\n      } else {\n        y.isub(x);\n        C.isub(A);\n        D.isub(B);\n      }\n    }\n\n    return {\n      a: C,\n      b: D,\n      gcd: y.iushln(g)\n    };\n  };\n\n  // This is reduced incarnation of the binary EEA\n  // above, designated to invert members of the\n  // _prime_ fields F(p) at a maximal speed\n  BN.prototype._invmp = function _invmp (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var a = this;\n    var b = p.clone();\n\n    if (a.negative !== 0) {\n      a = a.umod(p);\n    } else {\n      a = a.clone();\n    }\n\n    var x1 = new BN(1);\n    var x2 = new BN(0);\n\n    var delta = b.clone();\n\n    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        a.iushrn(i);\n        while (i-- > 0) {\n          if (x1.isOdd()) {\n            x1.iadd(delta);\n          }\n\n          x1.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        b.iushrn(j);\n        while (j-- > 0) {\n          if (x2.isOdd()) {\n            x2.iadd(delta);\n          }\n\n          x2.iushrn(1);\n        }\n      }\n\n      if (a.cmp(b) >= 0) {\n        a.isub(b);\n        x1.isub(x2);\n      } else {\n        b.isub(a);\n        x2.isub(x1);\n      }\n    }\n\n    var res;\n    if (a.cmpn(1) === 0) {\n      res = x1;\n    } else {\n      res = x2;\n    }\n\n    if (res.cmpn(0) < 0) {\n      res.iadd(p);\n    }\n\n    return res;\n  };\n\n  BN.prototype.gcd = function gcd (num) {\n    if (this.isZero()) return num.abs();\n    if (num.isZero()) return this.abs();\n\n    var a = this.clone();\n    var b = num.clone();\n    a.negative = 0;\n    b.negative = 0;\n\n    // Remove common factor of two\n    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n      a.iushrn(1);\n      b.iushrn(1);\n    }\n\n    do {\n      while (a.isEven()) {\n        a.iushrn(1);\n      }\n      while (b.isEven()) {\n        b.iushrn(1);\n      }\n\n      var r = a.cmp(b);\n      if (r < 0) {\n        // Swap `a` and `b` to make `a` always bigger than `b`\n        var t = a;\n        a = b;\n        b = t;\n      } else if (r === 0 || b.cmpn(1) === 0) {\n        break;\n      }\n\n      a.isub(b);\n    } while (true);\n\n    return b.iushln(shift);\n  };\n\n  // Invert number in the field F(num)\n  BN.prototype.invm = function invm (num) {\n    return this.egcd(num).a.umod(num);\n  };\n\n  BN.prototype.isEven = function isEven () {\n    return (this.words[0] & 1) === 0;\n  };\n\n  BN.prototype.isOdd = function isOdd () {\n    return (this.words[0] & 1) === 1;\n  };\n\n  // And first word and num\n  BN.prototype.andln = function andln (num) {\n    return this.words[0] & num;\n  };\n\n  // Increment at the bit position in-line\n  BN.prototype.bincn = function bincn (bit) {\n    assert(typeof bit === 'number');\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) {\n      this._expand(s + 1);\n      this.words[s] |= q;\n      return this;\n    }\n\n    // Add bit and propagate, if needed\n    var carry = q;\n    for (var i = s; carry !== 0 && i < this.length; i++) {\n      var w = this.words[i] | 0;\n      w += carry;\n      carry = w >>> 26;\n      w &= 0x3ffffff;\n      this.words[i] = w;\n    }\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n    return this;\n  };\n\n  BN.prototype.isZero = function isZero () {\n    return this.length === 1 && this.words[0] === 0;\n  };\n\n  BN.prototype.cmpn = function cmpn (num) {\n    var negative = num < 0;\n\n    if (this.negative !== 0 && !negative) return -1;\n    if (this.negative === 0 && negative) return 1;\n\n    this.strip();\n\n    var res;\n    if (this.length > 1) {\n      res = 1;\n    } else {\n      if (negative) {\n        num = -num;\n      }\n\n      assert(num <= 0x3ffffff, 'Number is too big');\n\n      var w = this.words[0] | 0;\n      res = w === num ? 0 : w < num ? -1 : 1;\n    }\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Compare two numbers and return:\n  // 1 - if `this` > `num`\n  // 0 - if `this` == `num`\n  // -1 - if `this` < `num`\n  BN.prototype.cmp = function cmp (num) {\n    if (this.negative !== 0 && num.negative === 0) return -1;\n    if (this.negative === 0 && num.negative !== 0) return 1;\n\n    var res = this.ucmp(num);\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Unsigned comparison\n  BN.prototype.ucmp = function ucmp (num) {\n    // At this point both numbers have the same sign\n    if (this.length > num.length) return 1;\n    if (this.length < num.length) return -1;\n\n    var res = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var a = this.words[i] | 0;\n      var b = num.words[i] | 0;\n\n      if (a === b) continue;\n      if (a < b) {\n        res = -1;\n      } else if (a > b) {\n        res = 1;\n      }\n      break;\n    }\n    return res;\n  };\n\n  BN.prototype.gtn = function gtn (num) {\n    return this.cmpn(num) === 1;\n  };\n\n  BN.prototype.gt = function gt (num) {\n    return this.cmp(num) === 1;\n  };\n\n  BN.prototype.gten = function gten (num) {\n    return this.cmpn(num) >= 0;\n  };\n\n  BN.prototype.gte = function gte (num) {\n    return this.cmp(num) >= 0;\n  };\n\n  BN.prototype.ltn = function ltn (num) {\n    return this.cmpn(num) === -1;\n  };\n\n  BN.prototype.lt = function lt (num) {\n    return this.cmp(num) === -1;\n  };\n\n  BN.prototype.lten = function lten (num) {\n    return this.cmpn(num) <= 0;\n  };\n\n  BN.prototype.lte = function lte (num) {\n    return this.cmp(num) <= 0;\n  };\n\n  BN.prototype.eqn = function eqn (num) {\n    return this.cmpn(num) === 0;\n  };\n\n  BN.prototype.eq = function eq (num) {\n    return this.cmp(num) === 0;\n  };\n\n  //\n  // A reduce context, could be using montgomery or something better, depending\n  // on the `m` itself.\n  //\n  BN.red = function red (num) {\n    return new Red(num);\n  };\n\n  BN.prototype.toRed = function toRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    assert(this.negative === 0, 'red works only with positives');\n    return ctx.convertTo(this)._forceRed(ctx);\n  };\n\n  BN.prototype.fromRed = function fromRed () {\n    assert(this.red, 'fromRed works only with numbers in reduction context');\n    return this.red.convertFrom(this);\n  };\n\n  BN.prototype._forceRed = function _forceRed (ctx) {\n    this.red = ctx;\n    return this;\n  };\n\n  BN.prototype.forceRed = function forceRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    return this._forceRed(ctx);\n  };\n\n  BN.prototype.redAdd = function redAdd (num) {\n    assert(this.red, 'redAdd works only with red numbers');\n    return this.red.add(this, num);\n  };\n\n  BN.prototype.redIAdd = function redIAdd (num) {\n    assert(this.red, 'redIAdd works only with red numbers');\n    return this.red.iadd(this, num);\n  };\n\n  BN.prototype.redSub = function redSub (num) {\n    assert(this.red, 'redSub works only with red numbers');\n    return this.red.sub(this, num);\n  };\n\n  BN.prototype.redISub = function redISub (num) {\n    assert(this.red, 'redISub works only with red numbers');\n    return this.red.isub(this, num);\n  };\n\n  BN.prototype.redShl = function redShl (num) {\n    assert(this.red, 'redShl works only with red numbers');\n    return this.red.shl(this, num);\n  };\n\n  BN.prototype.redMul = function redMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.mul(this, num);\n  };\n\n  BN.prototype.redIMul = function redIMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.imul(this, num);\n  };\n\n  BN.prototype.redSqr = function redSqr () {\n    assert(this.red, 'redSqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqr(this);\n  };\n\n  BN.prototype.redISqr = function redISqr () {\n    assert(this.red, 'redISqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.isqr(this);\n  };\n\n  // Square root over p\n  BN.prototype.redSqrt = function redSqrt () {\n    assert(this.red, 'redSqrt works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqrt(this);\n  };\n\n  BN.prototype.redInvm = function redInvm () {\n    assert(this.red, 'redInvm works only with red numbers');\n    this.red._verify1(this);\n    return this.red.invm(this);\n  };\n\n  // Return negative clone of `this` % `red modulo`\n  BN.prototype.redNeg = function redNeg () {\n    assert(this.red, 'redNeg works only with red numbers');\n    this.red._verify1(this);\n    return this.red.neg(this);\n  };\n\n  BN.prototype.redPow = function redPow (num) {\n    assert(this.red && !num.red, 'redPow(normalNum)');\n    this.red._verify1(this);\n    return this.red.pow(this, num);\n  };\n\n  // Prime numbers with efficient reduction\n  var primes = {\n    k256: null,\n    p224: null,\n    p192: null,\n    p25519: null\n  };\n\n  // Pseudo-Mersenne prime\n  function MPrime (name, p) {\n    // P = 2 ^ N - K\n    this.name = name;\n    this.p = new BN(p, 16);\n    this.n = this.p.bitLength();\n    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n    this.tmp = this._tmp();\n  }\n\n  MPrime.prototype._tmp = function _tmp () {\n    var tmp = new BN(null);\n    tmp.words = new Array(Math.ceil(this.n / 13));\n    return tmp;\n  };\n\n  MPrime.prototype.ireduce = function ireduce (num) {\n    // Assumes that `num` is less than `P^2`\n    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n    var r = num;\n    var rlen;\n\n    do {\n      this.split(r, this.tmp);\n      r = this.imulK(r);\n      r = r.iadd(this.tmp);\n      rlen = r.bitLength();\n    } while (rlen > this.n);\n\n    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n    if (cmp === 0) {\n      r.words[0] = 0;\n      r.length = 1;\n    } else if (cmp > 0) {\n      r.isub(this.p);\n    } else {\n      if (r.strip !== undefined) {\n        // r is BN v4 instance\n        r.strip();\n      } else {\n        // r is BN v5 instance\n        r._strip();\n      }\n    }\n\n    return r;\n  };\n\n  MPrime.prototype.split = function split (input, out) {\n    input.iushrn(this.n, 0, out);\n  };\n\n  MPrime.prototype.imulK = function imulK (num) {\n    return num.imul(this.k);\n  };\n\n  function K256 () {\n    MPrime.call(\n      this,\n      'k256',\n      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n  }\n  inherits(K256, MPrime);\n\n  K256.prototype.split = function split (input, output) {\n    // 256 = 9 * 26 + 22\n    var mask = 0x3fffff;\n\n    var outLen = Math.min(input.length, 9);\n    for (var i = 0; i < outLen; i++) {\n      output.words[i] = input.words[i];\n    }\n    output.length = outLen;\n\n    if (input.length <= 9) {\n      input.words[0] = 0;\n      input.length = 1;\n      return;\n    }\n\n    // Shift by 9 limbs\n    var prev = input.words[9];\n    output.words[output.length++] = prev & mask;\n\n    for (i = 10; i < input.length; i++) {\n      var next = input.words[i] | 0;\n      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n      prev = next;\n    }\n    prev >>>= 22;\n    input.words[i - 10] = prev;\n    if (prev === 0 && input.length > 10) {\n      input.length -= 10;\n    } else {\n      input.length -= 9;\n    }\n  };\n\n  K256.prototype.imulK = function imulK (num) {\n    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n    num.words[num.length] = 0;\n    num.words[num.length + 1] = 0;\n    num.length += 2;\n\n    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n    var lo = 0;\n    for (var i = 0; i < num.length; i++) {\n      var w = num.words[i] | 0;\n      lo += w * 0x3d1;\n      num.words[i] = lo & 0x3ffffff;\n      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n    }\n\n    // Fast length reduction\n    if (num.words[num.length - 1] === 0) {\n      num.length--;\n      if (num.words[num.length - 1] === 0) {\n        num.length--;\n      }\n    }\n    return num;\n  };\n\n  function P224 () {\n    MPrime.call(\n      this,\n      'p224',\n      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n  }\n  inherits(P224, MPrime);\n\n  function P192 () {\n    MPrime.call(\n      this,\n      'p192',\n      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n  }\n  inherits(P192, MPrime);\n\n  function P25519 () {\n    // 2 ^ 255 - 19\n    MPrime.call(\n      this,\n      '25519',\n      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n  }\n  inherits(P25519, MPrime);\n\n  P25519.prototype.imulK = function imulK (num) {\n    // K = 0x13\n    var carry = 0;\n    for (var i = 0; i < num.length; i++) {\n      var hi = (num.words[i] | 0) * 0x13 + carry;\n      var lo = hi & 0x3ffffff;\n      hi >>>= 26;\n\n      num.words[i] = lo;\n      carry = hi;\n    }\n    if (carry !== 0) {\n      num.words[num.length++] = carry;\n    }\n    return num;\n  };\n\n  // Exported mostly for testing purposes, use plain name instead\n  BN._prime = function prime (name) {\n    // Cached version of prime\n    if (primes[name]) return primes[name];\n\n    var prime;\n    if (name === 'k256') {\n      prime = new K256();\n    } else if (name === 'p224') {\n      prime = new P224();\n    } else if (name === 'p192') {\n      prime = new P192();\n    } else if (name === 'p25519') {\n      prime = new P25519();\n    } else {\n      throw new Error('Unknown prime ' + name);\n    }\n    primes[name] = prime;\n\n    return prime;\n  };\n\n  //\n  // Base reduction engine\n  //\n  function Red (m) {\n    if (typeof m === 'string') {\n      var prime = BN._prime(m);\n      this.m = prime.p;\n      this.prime = prime;\n    } else {\n      assert(m.gtn(1), 'modulus must be greater than 1');\n      this.m = m;\n      this.prime = null;\n    }\n  }\n\n  Red.prototype._verify1 = function _verify1 (a) {\n    assert(a.negative === 0, 'red works only with positives');\n    assert(a.red, 'red works only with red numbers');\n  };\n\n  Red.prototype._verify2 = function _verify2 (a, b) {\n    assert((a.negative | b.negative) === 0, 'red works only with positives');\n    assert(a.red && a.red === b.red,\n      'red works only with red numbers');\n  };\n\n  Red.prototype.imod = function imod (a) {\n    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n    return a.umod(this.m)._forceRed(this);\n  };\n\n  Red.prototype.neg = function neg (a) {\n    if (a.isZero()) {\n      return a.clone();\n    }\n\n    return this.m.sub(a)._forceRed(this);\n  };\n\n  Red.prototype.add = function add (a, b) {\n    this._verify2(a, b);\n\n    var res = a.add(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.iadd = function iadd (a, b) {\n    this._verify2(a, b);\n\n    var res = a.iadd(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.sub = function sub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.sub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.isub = function isub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.isub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.shl = function shl (a, num) {\n    this._verify1(a);\n    return this.imod(a.ushln(num));\n  };\n\n  Red.prototype.imul = function imul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.imul(b));\n  };\n\n  Red.prototype.mul = function mul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.mul(b));\n  };\n\n  Red.prototype.isqr = function isqr (a) {\n    return this.imul(a, a.clone());\n  };\n\n  Red.prototype.sqr = function sqr (a) {\n    return this.mul(a, a);\n  };\n\n  Red.prototype.sqrt = function sqrt (a) {\n    if (a.isZero()) return a.clone();\n\n    var mod3 = this.m.andln(3);\n    assert(mod3 % 2 === 1);\n\n    // Fast case\n    if (mod3 === 3) {\n      var pow = this.m.add(new BN(1)).iushrn(2);\n      return this.pow(a, pow);\n    }\n\n    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n    //\n    // Find Q and S, that Q * 2 ^ S = (P - 1)\n    var q = this.m.subn(1);\n    var s = 0;\n    while (!q.isZero() && q.andln(1) === 0) {\n      s++;\n      q.iushrn(1);\n    }\n    assert(!q.isZero());\n\n    var one = new BN(1).toRed(this);\n    var nOne = one.redNeg();\n\n    // Find quadratic non-residue\n    // NOTE: Max is such because of generalized Riemann hypothesis.\n    var lpow = this.m.subn(1).iushrn(1);\n    var z = this.m.bitLength();\n    z = new BN(2 * z * z).toRed(this);\n\n    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n      z.redIAdd(nOne);\n    }\n\n    var c = this.pow(z, q);\n    var r = this.pow(a, q.addn(1).iushrn(1));\n    var t = this.pow(a, q);\n    var m = s;\n    while (t.cmp(one) !== 0) {\n      var tmp = t;\n      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n        tmp = tmp.redSqr();\n      }\n      assert(i < m);\n      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n      r = r.redMul(b);\n      c = b.redSqr();\n      t = t.redMul(c);\n      m = i;\n    }\n\n    return r;\n  };\n\n  Red.prototype.invm = function invm (a) {\n    var inv = a._invmp(this.m);\n    if (inv.negative !== 0) {\n      inv.negative = 0;\n      return this.imod(inv).redNeg();\n    } else {\n      return this.imod(inv);\n    }\n  };\n\n  Red.prototype.pow = function pow (a, num) {\n    if (num.isZero()) return new BN(1).toRed(this);\n    if (num.cmpn(1) === 0) return a.clone();\n\n    var windowSize = 4;\n    var wnd = new Array(1 << windowSize);\n    wnd[0] = new BN(1).toRed(this);\n    wnd[1] = a;\n    for (var i = 2; i < wnd.length; i++) {\n      wnd[i] = this.mul(wnd[i - 1], a);\n    }\n\n    var res = wnd[0];\n    var current = 0;\n    var currentLen = 0;\n    var start = num.bitLength() % 26;\n    if (start === 0) {\n      start = 26;\n    }\n\n    for (i = num.length - 1; i >= 0; i--) {\n      var word = num.words[i];\n      for (var j = start - 1; j >= 0; j--) {\n        var bit = (word >> j) & 1;\n        if (res !== wnd[0]) {\n          res = this.sqr(res);\n        }\n\n        if (bit === 0 && current === 0) {\n          currentLen = 0;\n          continue;\n        }\n\n        current <<= 1;\n        current |= bit;\n        currentLen++;\n        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n        res = this.mul(res, wnd[current]);\n        currentLen = 0;\n        current = 0;\n      }\n      start = 26;\n    }\n\n    return res;\n  };\n\n  Red.prototype.convertTo = function convertTo (num) {\n    var r = num.umod(this.m);\n\n    return r === num ? r.clone() : r;\n  };\n\n  Red.prototype.convertFrom = function convertFrom (num) {\n    var res = num.clone();\n    res.red = null;\n    return res;\n  };\n\n  //\n  // Montgomery method engine\n  //\n\n  BN.mont = function mont (num) {\n    return new Mont(num);\n  };\n\n  function Mont (m) {\n    Red.call(this, m);\n\n    this.shift = this.m.bitLength();\n    if (this.shift % 26 !== 0) {\n      this.shift += 26 - (this.shift % 26);\n    }\n\n    this.r = new BN(1).iushln(this.shift);\n    this.r2 = this.imod(this.r.sqr());\n    this.rinv = this.r._invmp(this.m);\n\n    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n    this.minv = this.minv.umod(this.r);\n    this.minv = this.r.sub(this.minv);\n  }\n  inherits(Mont, Red);\n\n  Mont.prototype.convertTo = function convertTo (num) {\n    return this.imod(num.ushln(this.shift));\n  };\n\n  Mont.prototype.convertFrom = function convertFrom (num) {\n    var r = this.imod(num.mul(this.rinv));\n    r.red = null;\n    return r;\n  };\n\n  Mont.prototype.imul = function imul (a, b) {\n    if (a.isZero() || b.isZero()) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    var t = a.imul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.mul = function mul (a, b) {\n    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n    var t = a.mul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.invm = function invm (a) {\n    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n    var res = this.imod(a._invmp(this.m).mul(this.r2));\n    return res._forceRed(this);\n  };\n})( false || module, this);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack://Fabric/./node_modules/bn.js/lib/bn.js?");
./assets/fabric.min.js:eval("/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {\n  'use strict';\n\n  // Utils\n  function assert (val, msg) {\n    if (!val) throw new Error(msg || 'Assertion failed');\n  }\n\n  // Could use `inherits` module, but don't want to move from single file\n  // architecture yet.\n  function inherits (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  }\n\n  // BN\n\n  function BN (number, base, endian) {\n    if (BN.isBN(number)) {\n      return number;\n    }\n\n    this.negative = 0;\n    this.words = null;\n    this.length = 0;\n\n    // Reduction context\n    this.red = null;\n\n    if (number !== null) {\n      if (base === 'le' || base === 'be') {\n        endian = base;\n        base = 10;\n      }\n\n      this._init(number || 0, base || 10, endian || 'be');\n    }\n  }\n  if (typeof module === 'object') {\n    module.exports = BN;\n  } else {\n    exports.BN = BN;\n  }\n\n  BN.BN = BN;\n  BN.wordSize = 26;\n\n  var Buffer;\n  try {\n    Buffer = __webpack_require__(/*! buffer */ 8).Buffer;\n  } catch (e) {\n  }\n\n  BN.isBN = function isBN (num) {\n    if (num instanceof BN) {\n      return true;\n    }\n\n    return num !== null && typeof num === 'object' &&\n      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n  };\n\n  BN.max = function max (left, right) {\n    if (left.cmp(right) > 0) return left;\n    return right;\n  };\n\n  BN.min = function min (left, right) {\n    if (left.cmp(right) < 0) return left;\n    return right;\n  };\n\n  BN.prototype._init = function init (number, base, endian) {\n    if (typeof number === 'number') {\n      return this._initNumber(number, base, endian);\n    }\n\n    if (typeof number === 'object') {\n      return this._initArray(number, base, endian);\n    }\n\n    if (base === 'hex') {\n      base = 16;\n    }\n    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n    number = number.toString().replace(/\\s+/g, '');\n    var start = 0;\n    if (number[0] === '-') {\n      start++;\n    }\n\n    if (base === 16) {\n      this._parseHex(number, start);\n    } else {\n      this._parseBase(number, base, start);\n    }\n\n    if (number[0] === '-') {\n      this.negative = 1;\n    }\n\n    this._strip();\n\n    if (endian !== 'le') return;\n\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n    if (number < 0) {\n      this.negative = 1;\n      number = -number;\n    }\n    if (number < 0x4000000) {\n      this.words = [number & 0x3ffffff];\n      this.length = 1;\n    } else if (number < 0x10000000000000) {\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff\n      ];\n      this.length = 2;\n    } else {\n      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff,\n        1\n      ];\n      this.length = 3;\n    }\n\n    if (endian !== 'le') return;\n\n    // Reverse the bytes\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initArray = function _initArray (number, base, endian) {\n    // Perhaps a Uint8Array\n    assert(typeof number.length === 'number');\n    if (number.length <= 0) {\n      this.words = [0];\n      this.length = 1;\n      return this;\n    }\n\n    this.length = Math.ceil(number.length / 3);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    var off = 0;\n    if (endian === 'be') {\n      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    } else if (endian === 'le') {\n      for (i = 0, j = 0; i < number.length; i += 3) {\n        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    }\n    return this._strip();\n  };\n\n  function parseHex (str, start, end) {\n    var r = 0;\n    var len = Math.min(str.length, end);\n    var z = 0;\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r <<= 4;\n\n      var b;\n\n      // 'a' - 'f'\n      if (c >= 49 && c <= 54) {\n        b = c - 49 + 0xa;\n\n      // 'A' - 'F'\n      } else if (c >= 17 && c <= 22) {\n        b = c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        b = c;\n      }\n\n      r |= b;\n      z |= b;\n    }\n\n    assert(!(z & 0xf0), 'Invalid character in ' + str);\n    return r;\n  }\n\n  BN.prototype._parseHex = function _parseHex (number, start) {\n    // Create possibly bigger array to ensure that it fits the number\n    this.length = Math.ceil((number.length - start) / 6);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    // Scan 24-bit chunks and add them to the number\n    var off = 0;\n    for (i = number.length - 6, j = 0; i >= start; i -= 6) {\n      w = parseHex(number, i, i + 6);\n      this.words[j] |= (w << off) & 0x3ffffff;\n      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb\n      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n      off += 24;\n      if (off >= 26) {\n        off -= 26;\n        j++;\n      }\n    }\n    if (i + 6 !== start) {\n      w = parseHex(number, start, i + 6);\n      this.words[j] |= (w << off) & 0x3ffffff;\n      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n    }\n    this._strip();\n  };\n\n  function parseBase (str, start, end, mul) {\n    var r = 0;\n    var b = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r *= mul;\n\n      // 'a'\n      if (c >= 49) {\n        b = c - 49 + 0xa;\n\n      // 'A'\n      } else if (c >= 17) {\n        b = c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        b = c;\n      }\n      assert(c >= 0 && b < mul, 'Invalid character');\n      r += b;\n    }\n    return r;\n  }\n\n  BN.prototype._parseBase = function _parseBase (number, base, start) {\n    // Initialize as zero\n    this.words = [0];\n    this.length = 1;\n\n    // Find length of limb in base\n    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n      limbLen++;\n    }\n    limbLen--;\n    limbPow = (limbPow / base) | 0;\n\n    var total = number.length - start;\n    var mod = total % limbLen;\n    var end = Math.min(total, total - mod) + start;\n\n    var word = 0;\n    for (var i = start; i < end; i += limbLen) {\n      word = parseBase(number, i, i + limbLen, base);\n\n      this.imuln(limbPow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    if (mod !== 0) {\n      var pow = 1;\n      word = parseBase(number, i, number.length, base);\n\n      for (i = 0; i < mod; i++) {\n        pow *= base;\n      }\n\n      this.imuln(pow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n  };\n\n  BN.prototype.copy = function copy (dest) {\n    dest.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      dest.words[i] = this.words[i];\n    }\n    dest.length = this.length;\n    dest.negative = this.negative;\n    dest.red = this.red;\n  };\n\n  function move (dest, src) {\n    dest.words = src.words;\n    dest.length = src.length;\n    dest.negative = src.negative;\n    dest.red = src.red;\n  }\n\n  BN.prototype._move = function _move (dest) {\n    move(dest, this);\n  };\n\n  BN.prototype.clone = function clone () {\n    var r = new BN(null);\n    this.copy(r);\n    return r;\n  };\n\n  BN.prototype._expand = function _expand (size) {\n    while (this.length < size) {\n      this.words[this.length++] = 0;\n    }\n    return this;\n  };\n\n  // Remove leading `0` from `this`\n  BN.prototype._strip = function strip () {\n    while (this.length > 1 && this.words[this.length - 1] === 0) {\n      this.length--;\n    }\n    return this._normSign();\n  };\n\n  BN.prototype._normSign = function _normSign () {\n    // -0 = 0\n    if (this.length === 1 && this.words[0] === 0) {\n      this.negative = 0;\n    }\n    return this;\n  };\n\n  // Check Symbol.for because not everywhere where Symbol defined\n  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility\n  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {\n    try {\n      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;\n    } catch (e) {\n      BN.prototype.inspect = inspect;\n    }\n  } else {\n    BN.prototype.inspect = inspect;\n  }\n\n  function inspect () {\n    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n  }\n\n  /*\n\n  var zeros = [];\n  var groupSizes = [];\n  var groupBases = [];\n\n  var s = '';\n  var i = -1;\n  while (++i < BN.wordSize) {\n    zeros[i] = s;\n    s += '0';\n  }\n  groupSizes[0] = 0;\n  groupSizes[1] = 0;\n  groupBases[0] = 0;\n  groupBases[1] = 0;\n  var base = 2 - 1;\n  while (++base < 36 + 1) {\n    var groupSize = 0;\n    var groupBase = 1;\n    while (groupBase < (1 << BN.wordSize) / base) {\n      groupBase *= base;\n      groupSize += 1;\n    }\n    groupSizes[base] = groupSize;\n    groupBases[base] = groupBase;\n  }\n\n  */\n\n  var zeros = [\n    '',\n    '0',\n    '00',\n    '000',\n    '0000',\n    '00000',\n    '000000',\n    '0000000',\n    '00000000',\n    '000000000',\n    '0000000000',\n    '00000000000',\n    '000000000000',\n    '0000000000000',\n    '00000000000000',\n    '000000000000000',\n    '0000000000000000',\n    '00000000000000000',\n    '000000000000000000',\n    '0000000000000000000',\n    '00000000000000000000',\n    '000000000000000000000',\n    '0000000000000000000000',\n    '00000000000000000000000',\n    '000000000000000000000000',\n    '0000000000000000000000000'\n  ];\n\n  var groupSizes = [\n    0, 0,\n    25, 16, 12, 11, 10, 9, 8,\n    8, 7, 7, 7, 7, 6, 6,\n    6, 6, 6, 6, 6, 5, 5,\n    5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5\n  ];\n\n  var groupBases = [\n    0, 0,\n    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n  ];\n\n  BN.prototype.toString = function toString (base, padding) {\n    base = base || 10;\n    padding = padding | 0 || 1;\n\n    var out;\n    if (base === 16 || base === 'hex') {\n      out = '';\n      var off = 0;\n      var carry = 0;\n      for (var i = 0; i < this.length; i++) {\n        var w = this.words[i];\n        var word = (((w << off) | carry) & 0xffffff).toString(16);\n        carry = (w >>> (24 - off)) & 0xffffff;\n        if (carry !== 0 || i !== this.length - 1) {\n          out = zeros[6 - word.length] + word + out;\n        } else {\n          out = word + out;\n        }\n        off += 2;\n        if (off >= 26) {\n          off -= 26;\n          i--;\n        }\n      }\n      if (carry !== 0) {\n        out = carry.toString(16) + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    if (base === (base | 0) && base >= 2 && base <= 36) {\n      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n      var groupSize = groupSizes[base];\n      // var groupBase = Math.pow(base, groupSize);\n      var groupBase = groupBases[base];\n      out = '';\n      var c = this.clone();\n      c.negative = 0;\n      while (!c.isZero()) {\n        var r = c.modrn(groupBase).toString(base);\n        c = c.idivn(groupBase);\n\n        if (!c.isZero()) {\n          out = zeros[groupSize - r.length] + r + out;\n        } else {\n          out = r + out;\n        }\n      }\n      if (this.isZero()) {\n        out = '0' + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    assert(false, 'Base should be between 2 and 36');\n  };\n\n  BN.prototype.toNumber = function toNumber () {\n    var ret = this.words[0];\n    if (this.length === 2) {\n      ret += this.words[1] * 0x4000000;\n    } else if (this.length === 3 && this.words[2] === 0x01) {\n      // NOTE: at this stage it is known that the top bit is set\n      ret += 0x10000000000000 + (this.words[1] * 0x4000000);\n    } else if (this.length > 2) {\n      assert(false, 'Number can only safely store up to 53 bits');\n    }\n    return (this.negative !== 0) ? -ret : ret;\n  };\n\n  BN.prototype.toJSON = function toJSON () {\n    return this.toString(16, 2);\n  };\n\n  if (Buffer) {\n    BN.prototype.toBuffer = function toBuffer (endian, length) {\n      return this.toArrayLike(Buffer, endian, length);\n    };\n  }\n\n  BN.prototype.toArray = function toArray (endian, length) {\n    return this.toArrayLike(Array, endian, length);\n  };\n\n  var allocate = function allocate (ArrayType, size) {\n    if (ArrayType.allocUnsafe) {\n      return ArrayType.allocUnsafe(size);\n    }\n    return new ArrayType(size);\n  };\n\n  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {\n    this._strip();\n\n    var byteLength = this.byteLength();\n    var reqLength = length || Math.max(1, byteLength);\n    assert(byteLength <= reqLength, 'byte array longer than desired length');\n    assert(reqLength > 0, 'Requested array length <= 0');\n\n    var res = allocate(ArrayType, reqLength);\n    var postfix = endian === 'le' ? 'LE' : 'BE';\n    this['_toArrayLike' + postfix](res, byteLength);\n    return res;\n  };\n\n  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {\n    var position = 0;\n    var carry = 0;\n\n    for (var i = 0, shift = 0; i < this.length; i++) {\n      var word = (this.words[i] << shift) | carry;\n\n      res[position++] = word & 0xff;\n      if (position < res.length) {\n        res[position++] = (word >> 8) & 0xff;\n      }\n      if (position < res.length) {\n        res[position++] = (word >> 16) & 0xff;\n      }\n\n      if (shift === 6) {\n        if (position < res.length) {\n          res[position++] = (word >> 24) & 0xff;\n        }\n        carry = 0;\n        shift = 0;\n      } else {\n        carry = word >>> 24;\n        shift += 2;\n      }\n    }\n\n    if (position < res.length) {\n      res[position++] = carry;\n\n      while (position < res.length) {\n        res[position++] = 0;\n      }\n    }\n  };\n\n  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {\n    var position = res.length - 1;\n    var carry = 0;\n\n    for (var i = 0, shift = 0; i < this.length; i++) {\n      var word = (this.words[i] << shift) | carry;\n\n      res[position--] = word & 0xff;\n      if (position >= 0) {\n        res[position--] = (word >> 8) & 0xff;\n      }\n      if (position >= 0) {\n        res[position--] = (word >> 16) & 0xff;\n      }\n\n      if (shift === 6) {\n        if (position >= 0) {\n          res[position--] = (word >> 24) & 0xff;\n        }\n        carry = 0;\n        shift = 0;\n      } else {\n        carry = word >>> 24;\n        shift += 2;\n      }\n    }\n\n    if (position >= 0) {\n      res[position--] = carry;\n\n      while (position >= 0) {\n        res[position--] = 0;\n      }\n    }\n  };\n\n  if (Math.clz32) {\n    BN.prototype._countBits = function _countBits (w) {\n      return 32 - Math.clz32(w);\n    };\n  } else {\n    BN.prototype._countBits = function _countBits (w) {\n      var t = w;\n      var r = 0;\n      if (t >= 0x1000) {\n        r += 13;\n        t >>>= 13;\n      }\n      if (t >= 0x40) {\n        r += 7;\n        t >>>= 7;\n      }\n      if (t >= 0x8) {\n        r += 4;\n        t >>>= 4;\n      }\n      if (t >= 0x02) {\n        r += 2;\n        t >>>= 2;\n      }\n      return r + t;\n    };\n  }\n\n  BN.prototype._zeroBits = function _zeroBits (w) {\n    // Short-cut\n    if (w === 0) return 26;\n\n    var t = w;\n    var r = 0;\n    if ((t & 0x1fff) === 0) {\n      r += 13;\n      t >>>= 13;\n    }\n    if ((t & 0x7f) === 0) {\n      r += 7;\n      t >>>= 7;\n    }\n    if ((t & 0xf) === 0) {\n      r += 4;\n      t >>>= 4;\n    }\n    if ((t & 0x3) === 0) {\n      r += 2;\n      t >>>= 2;\n    }\n    if ((t & 0x1) === 0) {\n      r++;\n    }\n    return r;\n  };\n\n  // Return number of used bits in a BN\n  BN.prototype.bitLength = function bitLength () {\n    var w = this.words[this.length - 1];\n    var hi = this._countBits(w);\n    return (this.length - 1) * 26 + hi;\n  };\n\n  function toBitArray (num) {\n    var w = new Array(num.bitLength());\n\n    for (var bit = 0; bit < w.length; bit++) {\n      var off = (bit / 26) | 0;\n      var wbit = bit % 26;\n\n      w[bit] = (num.words[off] >>> wbit) & 0x01;\n    }\n\n    return w;\n  }\n\n  // Number of trailing zero bits\n  BN.prototype.zeroBits = function zeroBits () {\n    if (this.isZero()) return 0;\n\n    var r = 0;\n    for (var i = 0; i < this.length; i++) {\n      var b = this._zeroBits(this.words[i]);\n      r += b;\n      if (b !== 26) break;\n    }\n    return r;\n  };\n\n  BN.prototype.byteLength = function byteLength () {\n    return Math.ceil(this.bitLength() / 8);\n  };\n\n  BN.prototype.toTwos = function toTwos (width) {\n    if (this.negative !== 0) {\n      return this.abs().inotn(width).iaddn(1);\n    }\n    return this.clone();\n  };\n\n  BN.prototype.fromTwos = function fromTwos (width) {\n    if (this.testn(width - 1)) {\n      return this.notn(width).iaddn(1).ineg();\n    }\n    return this.clone();\n  };\n\n  BN.prototype.isNeg = function isNeg () {\n    return this.negative !== 0;\n  };\n\n  // Return negative clone of `this`\n  BN.prototype.neg = function neg () {\n    return this.clone().ineg();\n  };\n\n  BN.prototype.ineg = function ineg () {\n    if (!this.isZero()) {\n      this.negative ^= 1;\n    }\n\n    return this;\n  };\n\n  // Or `num` with `this` in-place\n  BN.prototype.iuor = function iuor (num) {\n    while (this.length < num.length) {\n      this.words[this.length++] = 0;\n    }\n\n    for (var i = 0; i < num.length; i++) {\n      this.words[i] = this.words[i] | num.words[i];\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ior = function ior (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuor(num);\n  };\n\n  // Or `num` with `this`\n  BN.prototype.or = function or (num) {\n    if (this.length > num.length) return this.clone().ior(num);\n    return num.clone().ior(this);\n  };\n\n  BN.prototype.uor = function uor (num) {\n    if (this.length > num.length) return this.clone().iuor(num);\n    return num.clone().iuor(this);\n  };\n\n  // And `num` with `this` in-place\n  BN.prototype.iuand = function iuand (num) {\n    // b = min-length(num, this)\n    var b;\n    if (this.length > num.length) {\n      b = num;\n    } else {\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = this.words[i] & num.words[i];\n    }\n\n    this.length = b.length;\n\n    return this._strip();\n  };\n\n  BN.prototype.iand = function iand (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuand(num);\n  };\n\n  // And `num` with `this`\n  BN.prototype.and = function and (num) {\n    if (this.length > num.length) return this.clone().iand(num);\n    return num.clone().iand(this);\n  };\n\n  BN.prototype.uand = function uand (num) {\n    if (this.length > num.length) return this.clone().iuand(num);\n    return num.clone().iuand(this);\n  };\n\n  // Xor `num` with `this` in-place\n  BN.prototype.iuxor = function iuxor (num) {\n    // a.length > b.length\n    var a;\n    var b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = a.words[i] ^ b.words[i];\n    }\n\n    if (this !== a) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = a.length;\n\n    return this._strip();\n  };\n\n  BN.prototype.ixor = function ixor (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuxor(num);\n  };\n\n  // Xor `num` with `this`\n  BN.prototype.xor = function xor (num) {\n    if (this.length > num.length) return this.clone().ixor(num);\n    return num.clone().ixor(this);\n  };\n\n  BN.prototype.uxor = function uxor (num) {\n    if (this.length > num.length) return this.clone().iuxor(num);\n    return num.clone().iuxor(this);\n  };\n\n  // Not ``this`` with ``width`` bitwidth\n  BN.prototype.inotn = function inotn (width) {\n    assert(typeof width === 'number' && width >= 0);\n\n    var bytesNeeded = Math.ceil(width / 26) | 0;\n    var bitsLeft = width % 26;\n\n    // Extend the buffer with leading zeroes\n    this._expand(bytesNeeded);\n\n    if (bitsLeft > 0) {\n      bytesNeeded--;\n    }\n\n    // Handle complete words\n    for (var i = 0; i < bytesNeeded; i++) {\n      this.words[i] = ~this.words[i] & 0x3ffffff;\n    }\n\n    // Handle the residue\n    if (bitsLeft > 0) {\n      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n    }\n\n    // And remove leading zeroes\n    return this._strip();\n  };\n\n  BN.prototype.notn = function notn (width) {\n    return this.clone().inotn(width);\n  };\n\n  // Set `bit` of `this`\n  BN.prototype.setn = function setn (bit, val) {\n    assert(typeof bit === 'number' && bit >= 0);\n\n    var off = (bit / 26) | 0;\n    var wbit = bit % 26;\n\n    this._expand(off + 1);\n\n    if (val) {\n      this.words[off] = this.words[off] | (1 << wbit);\n    } else {\n      this.words[off] = this.words[off] & ~(1 << wbit);\n    }\n\n    return this._strip();\n  };\n\n  // Add `num` to `this` in-place\n  BN.prototype.iadd = function iadd (num) {\n    var r;\n\n    // negative + positive\n    if (this.negative !== 0 && num.negative === 0) {\n      this.negative = 0;\n      r = this.isub(num);\n      this.negative ^= 1;\n      return this._normSign();\n\n    // positive + negative\n    } else if (this.negative === 0 && num.negative !== 0) {\n      num.negative = 0;\n      r = this.isub(num);\n      num.negative = 1;\n      return r._normSign();\n    }\n\n    // a.length > b.length\n    var a, b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    this.length = a.length;\n    if (carry !== 0) {\n      this.words[this.length] = carry;\n      this.length++;\n    // Copy the rest of the words\n    } else if (a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    return this;\n  };\n\n  // Add `num` to `this`\n  BN.prototype.add = function add (num) {\n    var res;\n    if (num.negative !== 0 && this.negative === 0) {\n      num.negative = 0;\n      res = this.sub(num);\n      num.negative ^= 1;\n      return res;\n    } else if (num.negative === 0 && this.negative !== 0) {\n      this.negative = 0;\n      res = num.sub(this);\n      this.negative = 1;\n      return res;\n    }\n\n    if (this.length > num.length) return this.clone().iadd(num);\n\n    return num.clone().iadd(this);\n  };\n\n  // Subtract `num` from `this` in-place\n  BN.prototype.isub = function isub (num) {\n    // this - (-num) = this + num\n    if (num.negative !== 0) {\n      num.negative = 0;\n      var r = this.iadd(num);\n      num.negative = 1;\n      return r._normSign();\n\n    // -this - num = -(this + num)\n    } else if (this.negative !== 0) {\n      this.negative = 0;\n      this.iadd(num);\n      this.negative = 1;\n      return this._normSign();\n    }\n\n    // At this point both numbers are positive\n    var cmp = this.cmp(num);\n\n    // Optimization - zeroify\n    if (cmp === 0) {\n      this.negative = 0;\n      this.length = 1;\n      this.words[0] = 0;\n      return this;\n    }\n\n    // a > b\n    var a, b;\n    if (cmp > 0) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n\n    // Copy rest of the words\n    if (carry === 0 && i < a.length && a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = Math.max(this.length, i);\n\n    if (a !== this) {\n      this.negative = 1;\n    }\n\n    return this._strip();\n  };\n\n  // Subtract `num` from `this`\n  BN.prototype.sub = function sub (num) {\n    return this.clone().isub(num);\n  };\n\n  function smallMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    var len = (self.length + num.length) | 0;\n    out.length = len;\n    len = (len - 1) | 0;\n\n    // Peel one iteration (compiler can't do it, because of code complexity)\n    var a = self.words[0] | 0;\n    var b = num.words[0] | 0;\n    var r = a * b;\n\n    var lo = r & 0x3ffffff;\n    var carry = (r / 0x4000000) | 0;\n    out.words[0] = lo;\n\n    for (var k = 1; k < len; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = carry >>> 26;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = (k - j) | 0;\n        a = self.words[i] | 0;\n        b = num.words[j] | 0;\n        r = a * b + rword;\n        ncarry += (r / 0x4000000) | 0;\n        rword = r & 0x3ffffff;\n      }\n      out.words[k] = rword | 0;\n      carry = ncarry | 0;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry | 0;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  }\n\n  // TODO(indutny): it may be reasonable to omit it for users who don't need\n  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n  // multiplication (like elliptic secp256k1).\n  var comb10MulTo = function comb10MulTo (self, num, out) {\n    var a = self.words;\n    var b = num.words;\n    var o = out.words;\n    var c = 0;\n    var lo;\n    var mid;\n    var hi;\n    var a0 = a[0] | 0;\n    var al0 = a0 & 0x1fff;\n    var ah0 = a0 >>> 13;\n    var a1 = a[1] | 0;\n    var al1 = a1 & 0x1fff;\n    var ah1 = a1 >>> 13;\n    var a2 = a[2] | 0;\n    var al2 = a2 & 0x1fff;\n    var ah2 = a2 >>> 13;\n    var a3 = a[3] | 0;\n    var al3 = a3 & 0x1fff;\n    var ah3 = a3 >>> 13;\n    var a4 = a[4] | 0;\n    var al4 = a4 & 0x1fff;\n    var ah4 = a4 >>> 13;\n    var a5 = a[5] | 0;\n    var al5 = a5 & 0x1fff;\n    var ah5 = a5 >>> 13;\n    var a6 = a[6] | 0;\n    var al6 = a6 & 0x1fff;\n    var ah6 = a6 >>> 13;\n    var a7 = a[7] | 0;\n    var al7 = a7 & 0x1fff;\n    var ah7 = a7 >>> 13;\n    var a8 = a[8] | 0;\n    var al8 = a8 & 0x1fff;\n    var ah8 = a8 >>> 13;\n    var a9 = a[9] | 0;\n    var al9 = a9 & 0x1fff;\n    var ah9 = a9 >>> 13;\n    var b0 = b[0] | 0;\n    var bl0 = b0 & 0x1fff;\n    var bh0 = b0 >>> 13;\n    var b1 = b[1] | 0;\n    var bl1 = b1 & 0x1fff;\n    var bh1 = b1 >>> 13;\n    var b2 = b[2] | 0;\n    var bl2 = b2 & 0x1fff;\n    var bh2 = b2 >>> 13;\n    var b3 = b[3] | 0;\n    var bl3 = b3 & 0x1fff;\n    var bh3 = b3 >>> 13;\n    var b4 = b[4] | 0;\n    var bl4 = b4 & 0x1fff;\n    var bh4 = b4 >>> 13;\n    var b5 = b[5] | 0;\n    var bl5 = b5 & 0x1fff;\n    var bh5 = b5 >>> 13;\n    var b6 = b[6] | 0;\n    var bl6 = b6 & 0x1fff;\n    var bh6 = b6 >>> 13;\n    var b7 = b[7] | 0;\n    var bl7 = b7 & 0x1fff;\n    var bh7 = b7 >>> 13;\n    var b8 = b[8] | 0;\n    var bl8 = b8 & 0x1fff;\n    var bh8 = b8 >>> 13;\n    var b9 = b[9] | 0;\n    var bl9 = b9 & 0x1fff;\n    var bh9 = b9 >>> 13;\n\n    out.negative = self.negative ^ num.negative;\n    out.length = 19;\n    /* k = 0 */\n    lo = Math.imul(al0, bl0);\n    mid = Math.imul(al0, bh0);\n    mid = (mid + Math.imul(ah0, bl0)) | 0;\n    hi = Math.imul(ah0, bh0);\n    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\n    w0 &= 0x3ffffff;\n    /* k = 1 */\n    lo = Math.imul(al1, bl0);\n    mid = Math.imul(al1, bh0);\n    mid = (mid + Math.imul(ah1, bl0)) | 0;\n    hi = Math.imul(ah1, bh0);\n    lo = (lo + Math.imul(al0, bl1)) | 0;\n    mid = (mid + Math.imul(al0, bh1)) | 0;\n    mid = (mid + Math.imul(ah0, bl1)) | 0;\n    hi = (hi + Math.imul(ah0, bh1)) | 0;\n    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\n    w1 &= 0x3ffffff;\n    /* k = 2 */\n    lo = Math.imul(al2, bl0);\n    mid = Math.imul(al2, bh0);\n    mid = (mid + Math.imul(ah2, bl0)) | 0;\n    hi = Math.imul(ah2, bh0);\n    lo = (lo + Math.imul(al1, bl1)) | 0;\n    mid = (mid + Math.imul(al1, bh1)) | 0;\n    mid = (mid + Math.imul(ah1, bl1)) | 0;\n    hi = (hi + Math.imul(ah1, bh1)) | 0;\n    lo = (lo + Math.imul(al0, bl2)) | 0;\n    mid = (mid + Math.imul(al0, bh2)) | 0;\n    mid = (mid + Math.imul(ah0, bl2)) | 0;\n    hi = (hi + Math.imul(ah0, bh2)) | 0;\n    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\n    w2 &= 0x3ffffff;\n    /* k = 3 */\n    lo = Math.imul(al3, bl0);\n    mid = Math.imul(al3, bh0);\n    mid = (mid + Math.imul(ah3, bl0)) | 0;\n    hi = Math.imul(ah3, bh0);\n    lo = (lo + Math.imul(al2, bl1)) | 0;\n    mid = (mid + Math.imul(al2, bh1)) | 0;\n    mid = (mid + Math.imul(ah2, bl1)) | 0;\n    hi = (hi + Math.imul(ah2, bh1)) | 0;\n    lo = (lo + Math.imul(al1, bl2)) | 0;\n    mid = (mid + Math.imul(al1, bh2)) | 0;\n    mid = (mid + Math.imul(ah1, bl2)) | 0;\n    hi = (hi + Math.imul(ah1, bh2)) | 0;\n    lo = (lo + Math.imul(al0, bl3)) | 0;\n    mid = (mid + Math.imul(al0, bh3)) | 0;\n    mid = (mid + Math.imul(ah0, bl3)) | 0;\n    hi = (hi + Math.imul(ah0, bh3)) | 0;\n    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\n    w3 &= 0x3ffffff;\n    /* k = 4 */\n    lo = Math.imul(al4, bl0);\n    mid = Math.imul(al4, bh0);\n    mid = (mid + Math.imul(ah4, bl0)) | 0;\n    hi = Math.imul(ah4, bh0);\n    lo = (lo + Math.imul(al3, bl1)) | 0;\n    mid = (mid + Math.imul(al3, bh1)) | 0;\n    mid = (mid + Math.imul(ah3, bl1)) | 0;\n    hi = (hi + Math.imul(ah3, bh1)) | 0;\n    lo = (lo + Math.imul(al2, bl2)) | 0;\n    mid = (mid + Math.imul(al2, bh2)) | 0;\n    mid = (mid + Math.imul(ah2, bl2)) | 0;\n    hi = (hi + Math.imul(ah2, bh2)) | 0;\n    lo = (lo + Math.imul(al1, bl3)) | 0;\n    mid = (mid + Math.imul(al1, bh3)) | 0;\n    mid = (mid + Math.imul(ah1, bl3)) | 0;\n    hi = (hi + Math.imul(ah1, bh3)) | 0;\n    lo = (lo + Math.imul(al0, bl4)) | 0;\n    mid = (mid + Math.imul(al0, bh4)) | 0;\n    mid = (mid + Math.imul(ah0, bl4)) | 0;\n    hi = (hi + Math.imul(ah0, bh4)) | 0;\n    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\n    w4 &= 0x3ffffff;\n    /* k = 5 */\n    lo = Math.imul(al5, bl0);\n    mid = Math.imul(al5, bh0);\n    mid = (mid + Math.imul(ah5, bl0)) | 0;\n    hi = Math.imul(ah5, bh0);\n    lo = (lo + Math.imul(al4, bl1)) | 0;\n    mid = (mid + Math.imul(al4, bh1)) | 0;\n    mid = (mid + Math.imul(ah4, bl1)) | 0;\n    hi = (hi + Math.imul(ah4, bh1)) | 0;\n    lo = (lo + Math.imul(al3, bl2)) | 0;\n    mid = (mid + Math.imul(al3, bh2)) | 0;\n    mid = (mid + Math.imul(ah3, bl2)) | 0;\n    hi = (hi + Math.imul(ah3, bh2)) | 0;\n    lo = (lo + Math.imul(al2, bl3)) | 0;\n    mid = (mid + Math.imul(al2, bh3)) | 0;\n    mid = (mid + Math.imul(ah2, bl3)) | 0;\n    hi = (hi + Math.imul(ah2, bh3)) | 0;\n    lo = (lo + Math.imul(al1, bl4)) | 0;\n    mid = (mid + Math.imul(al1, bh4)) | 0;\n    mid = (mid + Math.imul(ah1, bl4)) | 0;\n    hi = (hi + Math.imul(ah1, bh4)) | 0;\n    lo = (lo + Math.imul(al0, bl5)) | 0;\n    mid = (mid + Math.imul(al0, bh5)) | 0;\n    mid = (mid + Math.imul(ah0, bl5)) | 0;\n    hi = (hi + Math.imul(ah0, bh5)) | 0;\n    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\n    w5 &= 0x3ffffff;\n    /* k = 6 */\n    lo = Math.imul(al6, bl0);\n    mid = Math.imul(al6, bh0);\n    mid = (mid + Math.imul(ah6, bl0)) | 0;\n    hi = Math.imul(ah6, bh0);\n    lo = (lo + Math.imul(al5, bl1)) | 0;\n    mid = (mid + Math.imul(al5, bh1)) | 0;\n    mid = (mid + Math.imul(ah5, bl1)) | 0;\n    hi = (hi + Math.imul(ah5, bh1)) | 0;\n    lo = (lo + Math.imul(al4, bl2)) | 0;\n    mid = (mid + Math.imul(al4, bh2)) | 0;\n    mid = (mid + Math.imul(ah4, bl2)) | 0;\n    hi = (hi + Math.imul(ah4, bh2)) | 0;\n    lo = (lo + Math.imul(al3, bl3)) | 0;\n    mid = (mid + Math.imul(al3, bh3)) | 0;\n    mid = (mid + Math.imul(ah3, bl3)) | 0;\n    hi = (hi + Math.imul(ah3, bh3)) | 0;\n    lo = (lo + Math.imul(al2, bl4)) | 0;\n    mid = (mid + Math.imul(al2, bh4)) | 0;\n    mid = (mid + Math.imul(ah2, bl4)) | 0;\n    hi = (hi + Math.imul(ah2, bh4)) | 0;\n    lo = (lo + Math.imul(al1, bl5)) | 0;\n    mid = (mid + Math.imul(al1, bh5)) | 0;\n    mid = (mid + Math.imul(ah1, bl5)) | 0;\n    hi = (hi + Math.imul(ah1, bh5)) | 0;\n    lo = (lo + Math.imul(al0, bl6)) | 0;\n    mid = (mid + Math.imul(al0, bh6)) | 0;\n    mid = (mid + Math.imul(ah0, bl6)) | 0;\n    hi = (hi + Math.imul(ah0, bh6)) | 0;\n    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\n    w6 &= 0x3ffffff;\n    /* k = 7 */\n    lo = Math.imul(al7, bl0);\n    mid = Math.imul(al7, bh0);\n    mid = (mid + Math.imul(ah7, bl0)) | 0;\n    hi = Math.imul(ah7, bh0);\n    lo = (lo + Math.imul(al6, bl1)) | 0;\n    mid = (mid + Math.imul(al6, bh1)) | 0;\n    mid = (mid + Math.imul(ah6, bl1)) | 0;\n    hi = (hi + Math.imul(ah6, bh1)) | 0;\n    lo = (lo + Math.imul(al5, bl2)) | 0;\n    mid = (mid + Math.imul(al5, bh2)) | 0;\n    mid = (mid + Math.imul(ah5, bl2)) | 0;\n    hi = (hi + Math.imul(ah5, bh2)) | 0;\n    lo = (lo + Math.imul(al4, bl3)) | 0;\n    mid = (mid + Math.imul(al4, bh3)) | 0;\n    mid = (mid + Math.imul(ah4, bl3)) | 0;\n    hi = (hi + Math.imul(ah4, bh3)) | 0;\n    lo = (lo + Math.imul(al3, bl4)) | 0;\n    mid = (mid + Math.imul(al3, bh4)) | 0;\n    mid = (mid + Math.imul(ah3, bl4)) | 0;\n    hi = (hi + Math.imul(ah3, bh4)) | 0;\n    lo = (lo + Math.imul(al2, bl5)) | 0;\n    mid = (mid + Math.imul(al2, bh5)) | 0;\n    mid = (mid + Math.imul(ah2, bl5)) | 0;\n    hi = (hi + Math.imul(ah2, bh5)) | 0;\n    lo = (lo + Math.imul(al1, bl6)) | 0;\n    mid = (mid + Math.imul(al1, bh6)) | 0;\n    mid = (mid + Math.imul(ah1, bl6)) | 0;\n    hi = (hi + Math.imul(ah1, bh6)) | 0;\n    lo = (lo + Math.imul(al0, bl7)) | 0;\n    mid = (mid + Math.imul(al0, bh7)) | 0;\n    mid = (mid + Math.imul(ah0, bl7)) | 0;\n    hi = (hi + Math.imul(ah0, bh7)) | 0;\n    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\n    w7 &= 0x3ffffff;\n    /* k = 8 */\n    lo = Math.imul(al8, bl0);\n    mid = Math.imul(al8, bh0);\n    mid = (mid + Math.imul(ah8, bl0)) | 0;\n    hi = Math.imul(ah8, bh0);\n    lo = (lo + Math.imul(al7, bl1)) | 0;\n    mid = (mid + Math.imul(al7, bh1)) | 0;\n    mid = (mid + Math.imul(ah7, bl1)) | 0;\n    hi = (hi + Math.imul(ah7, bh1)) | 0;\n    lo = (lo + Math.imul(al6, bl2)) | 0;\n    mid = (mid + Math.imul(al6, bh2)) | 0;\n    mid = (mid + Math.imul(ah6, bl2)) | 0;\n    hi = (hi + Math.imul(ah6, bh2)) | 0;\n    lo = (lo + Math.imul(al5, bl3)) | 0;\n    mid = (mid + Math.imul(al5, bh3)) | 0;\n    mid = (mid + Math.imul(ah5, bl3)) | 0;\n    hi = (hi + Math.imul(ah5, bh3)) | 0;\n    lo = (lo + Math.imul(al4, bl4)) | 0;\n    mid = (mid + Math.imul(al4, bh4)) | 0;\n    mid = (mid + Math.imul(ah4, bl4)) | 0;\n    hi = (hi + Math.imul(ah4, bh4)) | 0;\n    lo = (lo + Math.imul(al3, bl5)) | 0;\n    mid = (mid + Math.imul(al3, bh5)) | 0;\n    mid = (mid + Math.imul(ah3, bl5)) | 0;\n    hi = (hi + Math.imul(ah3, bh5)) | 0;\n    lo = (lo + Math.imul(al2, bl6)) | 0;\n    mid = (mid + Math.imul(al2, bh6)) | 0;\n    mid = (mid + Math.imul(ah2, bl6)) | 0;\n    hi = (hi + Math.imul(ah2, bh6)) | 0;\n    lo = (lo + Math.imul(al1, bl7)) | 0;\n    mid = (mid + Math.imul(al1, bh7)) | 0;\n    mid = (mid + Math.imul(ah1, bl7)) | 0;\n    hi = (hi + Math.imul(ah1, bh7)) | 0;\n    lo = (lo + Math.imul(al0, bl8)) | 0;\n    mid = (mid + Math.imul(al0, bh8)) | 0;\n    mid = (mid + Math.imul(ah0, bl8)) | 0;\n    hi = (hi + Math.imul(ah0, bh8)) | 0;\n    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\n    w8 &= 0x3ffffff;\n    /* k = 9 */\n    lo = Math.imul(al9, bl0);\n    mid = Math.imul(al9, bh0);\n    mid = (mid + Math.imul(ah9, bl0)) | 0;\n    hi = Math.imul(ah9, bh0);\n    lo = (lo + Math.imul(al8, bl1)) | 0;\n    mid = (mid + Math.imul(al8, bh1)) | 0;\n    mid = (mid + Math.imul(ah8, bl1)) | 0;\n    hi = (hi + Math.imul(ah8, bh1)) | 0;\n    lo = (lo + Math.imul(al7, bl2)) | 0;\n    mid = (mid + Math.imul(al7, bh2)) | 0;\n    mid = (mid + Math.imul(ah7, bl2)) | 0;\n    hi = (hi + Math.imul(ah7, bh2)) | 0;\n    lo = (lo + Math.imul(al6, bl3)) | 0;\n    mid = (mid + Math.imul(al6, bh3)) | 0;\n    mid = (mid + Math.imul(ah6, bl3)) | 0;\n    hi = (hi + Math.imul(ah6, bh3)) | 0;\n    lo = (lo + Math.imul(al5, bl4)) | 0;\n    mid = (mid + Math.imul(al5, bh4)) | 0;\n    mid = (mid + Math.imul(ah5, bl4)) | 0;\n    hi = (hi + Math.imul(ah5, bh4)) | 0;\n    lo = (lo + Math.imul(al4, bl5)) | 0;\n    mid = (mid + Math.imul(al4, bh5)) | 0;\n    mid = (mid + Math.imul(ah4, bl5)) | 0;\n    hi = (hi + Math.imul(ah4, bh5)) | 0;\n    lo = (lo + Math.imul(al3, bl6)) | 0;\n    mid = (mid + Math.imul(al3, bh6)) | 0;\n    mid = (mid + Math.imul(ah3, bl6)) | 0;\n    hi = (hi + Math.imul(ah3, bh6)) | 0;\n    lo = (lo + Math.imul(al2, bl7)) | 0;\n    mid = (mid + Math.imul(al2, bh7)) | 0;\n    mid = (mid + Math.imul(ah2, bl7)) | 0;\n    hi = (hi + Math.imul(ah2, bh7)) | 0;\n    lo = (lo + Math.imul(al1, bl8)) | 0;\n    mid = (mid + Math.imul(al1, bh8)) | 0;\n    mid = (mid + Math.imul(ah1, bl8)) | 0;\n    hi = (hi + Math.imul(ah1, bh8)) | 0;\n    lo = (lo + Math.imul(al0, bl9)) | 0;\n    mid = (mid + Math.imul(al0, bh9)) | 0;\n    mid = (mid + Math.imul(ah0, bl9)) | 0;\n    hi = (hi + Math.imul(ah0, bh9)) | 0;\n    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\n    w9 &= 0x3ffffff;\n    /* k = 10 */\n    lo = Math.imul(al9, bl1);\n    mid = Math.imul(al9, bh1);\n    mid = (mid + Math.imul(ah9, bl1)) | 0;\n    hi = Math.imul(ah9, bh1);\n    lo = (lo + Math.imul(al8, bl2)) | 0;\n    mid = (mid + Math.imul(al8, bh2)) | 0;\n    mid = (mid + Math.imul(ah8, bl2)) | 0;\n    hi = (hi + Math.imul(ah8, bh2)) | 0;\n    lo = (lo + Math.imul(al7, bl3)) | 0;\n    mid = (mid + Math.imul(al7, bh3)) | 0;\n    mid = (mid + Math.imul(ah7, bl3)) | 0;\n    hi = (hi + Math.imul(ah7, bh3)) | 0;\n    lo = (lo + Math.imul(al6, bl4)) | 0;\n    mid = (mid + Math.imul(al6, bh4)) | 0;\n    mid = (mid + Math.imul(ah6, bl4)) | 0;\n    hi = (hi + Math.imul(ah6, bh4)) | 0;\n    lo = (lo + Math.imul(al5, bl5)) | 0;\n    mid = (mid + Math.imul(al5, bh5)) | 0;\n    mid = (mid + Math.imul(ah5, bl5)) | 0;\n    hi = (hi + Math.imul(ah5, bh5)) | 0;\n    lo = (lo + Math.imul(al4, bl6)) | 0;\n    mid = (mid + Math.imul(al4, bh6)) | 0;\n    mid = (mid + Math.imul(ah4, bl6)) | 0;\n    hi = (hi + Math.imul(ah4, bh6)) | 0;\n    lo = (lo + Math.imul(al3, bl7)) | 0;\n    mid = (mid + Math.imul(al3, bh7)) | 0;\n    mid = (mid + Math.imul(ah3, bl7)) | 0;\n    hi = (hi + Math.imul(ah3, bh7)) | 0;\n    lo = (lo + Math.imul(al2, bl8)) | 0;\n    mid = (mid + Math.imul(al2, bh8)) | 0;\n    mid = (mid + Math.imul(ah2, bl8)) | 0;\n    hi = (hi + Math.imul(ah2, bh8)) | 0;\n    lo = (lo + Math.imul(al1, bl9)) | 0;\n    mid = (mid + Math.imul(al1, bh9)) | 0;\n    mid = (mid + Math.imul(ah1, bl9)) | 0;\n    hi = (hi + Math.imul(ah1, bh9)) | 0;\n    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\n    w10 &= 0x3ffffff;\n    /* k = 11 */\n    lo = Math.imul(al9, bl2);\n    mid = Math.imul(al9, bh2);\n    mid = (mid + Math.imul(ah9, bl2)) | 0;\n    hi = Math.imul(ah9, bh2);\n    lo = (lo + Math.imul(al8, bl3)) | 0;\n    mid = (mid + Math.imul(al8, bh3)) | 0;\n    mid = (mid + Math.imul(ah8, bl3)) | 0;\n    hi = (hi + Math.imul(ah8, bh3)) | 0;\n    lo = (lo + Math.imul(al7, bl4)) | 0;\n    mid = (mid + Math.imul(al7, bh4)) | 0;\n    mid = (mid + Math.imul(ah7, bl4)) | 0;\n    hi = (hi + Math.imul(ah7, bh4)) | 0;\n    lo = (lo + Math.imul(al6, bl5)) | 0;\n    mid = (mid + Math.imul(al6, bh5)) | 0;\n    mid = (mid + Math.imul(ah6, bl5)) | 0;\n    hi = (hi + Math.imul(ah6, bh5)) | 0;\n    lo = (lo + Math.imul(al5, bl6)) | 0;\n    mid = (mid + Math.imul(al5, bh6)) | 0;\n    mid = (mid + Math.imul(ah5, bl6)) | 0;\n    hi = (hi + Math.imul(ah5, bh6)) | 0;\n    lo = (lo + Math.imul(al4, bl7)) | 0;\n    mid = (mid + Math.imul(al4, bh7)) | 0;\n    mid = (mid + Math.imul(ah4, bl7)) | 0;\n    hi = (hi + Math.imul(ah4, bh7)) | 0;\n    lo = (lo + Math.imul(al3, bl8)) | 0;\n    mid = (mid + Math.imul(al3, bh8)) | 0;\n    mid = (mid + Math.imul(ah3, bl8)) | 0;\n    hi = (hi + Math.imul(ah3, bh8)) | 0;\n    lo = (lo + Math.imul(al2, bl9)) | 0;\n    mid = (mid + Math.imul(al2, bh9)) | 0;\n    mid = (mid + Math.imul(ah2, bl9)) | 0;\n    hi = (hi + Math.imul(ah2, bh9)) | 0;\n    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\n    w11 &= 0x3ffffff;\n    /* k = 12 */\n    lo = Math.imul(al9, bl3);\n    mid = Math.imul(al9, bh3);\n    mid = (mid + Math.imul(ah9, bl3)) | 0;\n    hi = Math.imul(ah9, bh3);\n    lo = (lo + Math.imul(al8, bl4)) | 0;\n    mid = (mid + Math.imul(al8, bh4)) | 0;\n    mid = (mid + Math.imul(ah8, bl4)) | 0;\n    hi = (hi + Math.imul(ah8, bh4)) | 0;\n    lo = (lo + Math.imul(al7, bl5)) | 0;\n    mid = (mid + Math.imul(al7, bh5)) | 0;\n    mid = (mid + Math.imul(ah7, bl5)) | 0;\n    hi = (hi + Math.imul(ah7, bh5)) | 0;\n    lo = (lo + Math.imul(al6, bl6)) | 0;\n    mid = (mid + Math.imul(al6, bh6)) | 0;\n    mid = (mid + Math.imul(ah6, bl6)) | 0;\n    hi = (hi + Math.imul(ah6, bh6)) | 0;\n    lo = (lo + Math.imul(al5, bl7)) | 0;\n    mid = (mid + Math.imul(al5, bh7)) | 0;\n    mid = (mid + Math.imul(ah5, bl7)) | 0;\n    hi = (hi + Math.imul(ah5, bh7)) | 0;\n    lo = (lo + Math.imul(al4, bl8)) | 0;\n    mid = (mid + Math.imul(al4, bh8)) | 0;\n    mid = (mid + Math.imul(ah4, bl8)) | 0;\n    hi = (hi + Math.imul(ah4, bh8)) | 0;\n    lo = (lo + Math.imul(al3, bl9)) | 0;\n    mid = (mid + Math.imul(al3, bh9)) | 0;\n    mid = (mid + Math.imul(ah3, bl9)) | 0;\n    hi = (hi + Math.imul(ah3, bh9)) | 0;\n    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\n    w12 &= 0x3ffffff;\n    /* k = 13 */\n    lo = Math.imul(al9, bl4);\n    mid = Math.imul(al9, bh4);\n    mid = (mid + Math.imul(ah9, bl4)) | 0;\n    hi = Math.imul(ah9, bh4);\n    lo = (lo + Math.imul(al8, bl5)) | 0;\n    mid = (mid + Math.imul(al8, bh5)) | 0;\n    mid = (mid + Math.imul(ah8, bl5)) | 0;\n    hi = (hi + Math.imul(ah8, bh5)) | 0;\n    lo = (lo + Math.imul(al7, bl6)) | 0;\n    mid = (mid + Math.imul(al7, bh6)) | 0;\n    mid = (mid + Math.imul(ah7, bl6)) | 0;\n    hi = (hi + Math.imul(ah7, bh6)) | 0;\n    lo = (lo + Math.imul(al6, bl7)) | 0;\n    mid = (mid + Math.imul(al6, bh7)) | 0;\n    mid = (mid + Math.imul(ah6, bl7)) | 0;\n    hi = (hi + Math.imul(ah6, bh7)) | 0;\n    lo = (lo + Math.imul(al5, bl8)) | 0;\n    mid = (mid + Math.imul(al5, bh8)) | 0;\n    mid = (mid + Math.imul(ah5, bl8)) | 0;\n    hi = (hi + Math.imul(ah5, bh8)) | 0;\n    lo = (lo + Math.imul(al4, bl9)) | 0;\n    mid = (mid + Math.imul(al4, bh9)) | 0;\n    mid = (mid + Math.imul(ah4, bl9)) | 0;\n    hi = (hi + Math.imul(ah4, bh9)) | 0;\n    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\n    w13 &= 0x3ffffff;\n    /* k = 14 */\n    lo = Math.imul(al9, bl5);\n    mid = Math.imul(al9, bh5);\n    mid = (mid + Math.imul(ah9, bl5)) | 0;\n    hi = Math.imul(ah9, bh5);\n    lo = (lo + Math.imul(al8, bl6)) | 0;\n    mid = (mid + Math.imul(al8, bh6)) | 0;\n    mid = (mid + Math.imul(ah8, bl6)) | 0;\n    hi = (hi + Math.imul(ah8, bh6)) | 0;\n    lo = (lo + Math.imul(al7, bl7)) | 0;\n    mid = (mid + Math.imul(al7, bh7)) | 0;\n    mid = (mid + Math.imul(ah7, bl7)) | 0;\n    hi = (hi + Math.imul(ah7, bh7)) | 0;\n    lo = (lo + Math.imul(al6, bl8)) | 0;\n    mid = (mid + Math.imul(al6, bh8)) | 0;\n    mid = (mid + Math.imul(ah6, bl8)) | 0;\n    hi = (hi + Math.imul(ah6, bh8)) | 0;\n    lo = (lo + Math.imul(al5, bl9)) | 0;\n    mid = (mid + Math.imul(al5, bh9)) | 0;\n    mid = (mid + Math.imul(ah5, bl9)) | 0;\n    hi = (hi + Math.imul(ah5, bh9)) | 0;\n    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\n    w14 &= 0x3ffffff;\n    /* k = 15 */\n    lo = Math.imul(al9, bl6);\n    mid = Math.imul(al9, bh6);\n    mid = (mid + Math.imul(ah9, bl6)) | 0;\n    hi = Math.imul(ah9, bh6);\n    lo = (lo + Math.imul(al8, bl7)) | 0;\n    mid = (mid + Math.imul(al8, bh7)) | 0;\n    mid = (mid + Math.imul(ah8, bl7)) | 0;\n    hi = (hi + Math.imul(ah8, bh7)) | 0;\n    lo = (lo + Math.imul(al7, bl8)) | 0;\n    mid = (mid + Math.imul(al7, bh8)) | 0;\n    mid = (mid + Math.imul(ah7, bl8)) | 0;\n    hi = (hi + Math.imul(ah7, bh8)) | 0;\n    lo = (lo + Math.imul(al6, bl9)) | 0;\n    mid = (mid + Math.imul(al6, bh9)) | 0;\n    mid = (mid + Math.imul(ah6, bl9)) | 0;\n    hi = (hi + Math.imul(ah6, bh9)) | 0;\n    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\n    w15 &= 0x3ffffff;\n    /* k = 16 */\n    lo = Math.imul(al9, bl7);\n    mid = Math.imul(al9, bh7);\n    mid = (mid + Math.imul(ah9, bl7)) | 0;\n    hi = Math.imul(ah9, bh7);\n    lo = (lo + Math.imul(al8, bl8)) | 0;\n    mid = (mid + Math.imul(al8, bh8)) | 0;\n    mid = (mid + Math.imul(ah8, bl8)) | 0;\n    hi = (hi + Math.imul(ah8, bh8)) | 0;\n    lo = (lo + Math.imul(al7, bl9)) | 0;\n    mid = (mid + Math.imul(al7, bh9)) | 0;\n    mid = (mid + Math.imul(ah7, bl9)) | 0;\n    hi = (hi + Math.imul(ah7, bh9)) | 0;\n    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\n    w16 &= 0x3ffffff;\n    /* k = 17 */\n    lo = Math.imul(al9, bl8);\n    mid = Math.imul(al9, bh8);\n    mid = (mid + Math.imul(ah9, bl8)) | 0;\n    hi = Math.imul(ah9, bh8);\n    lo = (lo + Math.imul(al8, bl9)) | 0;\n    mid = (mid + Math.imul(al8, bh9)) | 0;\n    mid = (mid + Math.imul(ah8, bl9)) | 0;\n    hi = (hi + Math.imul(ah8, bh9)) | 0;\n    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\n    w17 &= 0x3ffffff;\n    /* k = 18 */\n    lo = Math.imul(al9, bl9);\n    mid = Math.imul(al9, bh9);\n    mid = (mid + Math.imul(ah9, bl9)) | 0;\n    hi = Math.imul(ah9, bh9);\n    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\n    w18 &= 0x3ffffff;\n    o[0] = w0;\n    o[1] = w1;\n    o[2] = w2;\n    o[3] = w3;\n    o[4] = w4;\n    o[5] = w5;\n    o[6] = w6;\n    o[7] = w7;\n    o[8] = w8;\n    o[9] = w9;\n    o[10] = w10;\n    o[11] = w11;\n    o[12] = w12;\n    o[13] = w13;\n    o[14] = w14;\n    o[15] = w15;\n    o[16] = w16;\n    o[17] = w17;\n    o[18] = w18;\n    if (c !== 0) {\n      o[19] = c;\n      out.length++;\n    }\n    return out;\n  };\n\n  // Polyfill comb\n  if (!Math.imul) {\n    comb10MulTo = smallMulTo;\n  }\n\n  function bigMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    out.length = self.length + num.length;\n\n    var carry = 0;\n    var hncarry = 0;\n    for (var k = 0; k < out.length - 1; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = hncarry;\n      hncarry = 0;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = k - j;\n        var a = self.words[i] | 0;\n        var b = num.words[j] | 0;\n        var r = a * b;\n\n        var lo = r & 0x3ffffff;\n        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n        lo = (lo + rword) | 0;\n        rword = lo & 0x3ffffff;\n        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n        hncarry += ncarry >>> 26;\n        ncarry &= 0x3ffffff;\n      }\n      out.words[k] = rword;\n      carry = ncarry;\n      ncarry = hncarry;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  }\n\n  function jumboMulTo (self, num, out) {\n    // Temporary disable, see https://github.com/indutny/bn.js/issues/211\n    // var fftm = new FFTM();\n    // return fftm.mulp(self, num, out);\n    return bigMulTo(self, num, out);\n  }\n\n  BN.prototype.mulTo = function mulTo (num, out) {\n    var res;\n    var len = this.length + num.length;\n    if (this.length === 10 && num.length === 10) {\n      res = comb10MulTo(this, num, out);\n    } else if (len < 63) {\n      res = smallMulTo(this, num, out);\n    } else if (len < 1024) {\n      res = bigMulTo(this, num, out);\n    } else {\n      res = jumboMulTo(this, num, out);\n    }\n\n    return res;\n  };\n\n  // Cooley-Tukey algorithm for FFT\n  // slightly revisited to rely on looping instead of recursion\n\n  function FFTM (x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  FFTM.prototype.makeRBT = function makeRBT (N) {\n    var t = new Array(N);\n    var l = BN.prototype._countBits(N) - 1;\n    for (var i = 0; i < N; i++) {\n      t[i] = this.revBin(i, l, N);\n    }\n\n    return t;\n  };\n\n  // Returns binary-reversed representation of `x`\n  FFTM.prototype.revBin = function revBin (x, l, N) {\n    if (x === 0 || x === N - 1) return x;\n\n    var rb = 0;\n    for (var i = 0; i < l; i++) {\n      rb |= (x & 1) << (l - i - 1);\n      x >>= 1;\n    }\n\n    return rb;\n  };\n\n  // Performs \"tweedling\" phase, therefore 'emulating'\n  // behaviour of the recursive algorithm\n  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n    for (var i = 0; i < N; i++) {\n      rtws[i] = rws[rbt[i]];\n      itws[i] = iws[rbt[i]];\n    }\n  };\n\n  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n    this.permute(rbt, rws, iws, rtws, itws, N);\n\n    for (var s = 1; s < N; s <<= 1) {\n      var l = s << 1;\n\n      var rtwdf = Math.cos(2 * Math.PI / l);\n      var itwdf = Math.sin(2 * Math.PI / l);\n\n      for (var p = 0; p < N; p += l) {\n        var rtwdf_ = rtwdf;\n        var itwdf_ = itwdf;\n\n        for (var j = 0; j < s; j++) {\n          var re = rtws[p + j];\n          var ie = itws[p + j];\n\n          var ro = rtws[p + j + s];\n          var io = itws[p + j + s];\n\n          var rx = rtwdf_ * ro - itwdf_ * io;\n\n          io = rtwdf_ * io + itwdf_ * ro;\n          ro = rx;\n\n          rtws[p + j] = re + ro;\n          itws[p + j] = ie + io;\n\n          rtws[p + j + s] = re - ro;\n          itws[p + j + s] = ie - io;\n\n          /* jshint maxdepth : false */\n          if (j !== l) {\n            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n            rtwdf_ = rx;\n          }\n        }\n      }\n    }\n  };\n\n  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n    var N = Math.max(m, n) | 1;\n    var odd = N & 1;\n    var i = 0;\n    for (N = N / 2 | 0; N; N = N >>> 1) {\n      i++;\n    }\n\n    return 1 << i + 1 + odd;\n  };\n\n  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n    if (N <= 1) return;\n\n    for (var i = 0; i < N / 2; i++) {\n      var t = rws[i];\n\n      rws[i] = rws[N - i - 1];\n      rws[N - i - 1] = t;\n\n      t = iws[i];\n\n      iws[i] = -iws[N - i - 1];\n      iws[N - i - 1] = -t;\n    }\n  };\n\n  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n    var carry = 0;\n    for (var i = 0; i < N / 2; i++) {\n      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n        Math.round(ws[2 * i] / N) +\n        carry;\n\n      ws[i] = w & 0x3ffffff;\n\n      if (w < 0x4000000) {\n        carry = 0;\n      } else {\n        carry = w / 0x4000000 | 0;\n      }\n    }\n\n    return ws;\n  };\n\n  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n    var carry = 0;\n    for (var i = 0; i < len; i++) {\n      carry = carry + (ws[i] | 0);\n\n      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n    }\n\n    // Pad with zeroes\n    for (i = 2 * len; i < N; ++i) {\n      rws[i] = 0;\n    }\n\n    assert(carry === 0);\n    assert((carry & ~0x1fff) === 0);\n  };\n\n  FFTM.prototype.stub = function stub (N) {\n    var ph = new Array(N);\n    for (var i = 0; i < N; i++) {\n      ph[i] = 0;\n    }\n\n    return ph;\n  };\n\n  FFTM.prototype.mulp = function mulp (x, y, out) {\n    var N = 2 * this.guessLen13b(x.length, y.length);\n\n    var rbt = this.makeRBT(N);\n\n    var _ = this.stub(N);\n\n    var rws = new Array(N);\n    var rwst = new Array(N);\n    var iwst = new Array(N);\n\n    var nrws = new Array(N);\n    var nrwst = new Array(N);\n    var niwst = new Array(N);\n\n    var rmws = out.words;\n    rmws.length = N;\n\n    this.convert13b(x.words, x.length, rws, N);\n    this.convert13b(y.words, y.length, nrws, N);\n\n    this.transform(rws, _, rwst, iwst, N, rbt);\n    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n    for (var i = 0; i < N; i++) {\n      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n      rwst[i] = rx;\n    }\n\n    this.conjugate(rwst, iwst, N);\n    this.transform(rwst, iwst, rmws, _, N, rbt);\n    this.conjugate(rmws, _, N);\n    this.normalize13b(rmws, N);\n\n    out.negative = x.negative ^ y.negative;\n    out.length = x.length + y.length;\n    return out._strip();\n  };\n\n  // Multiply `this` by `num`\n  BN.prototype.mul = function mul (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return this.mulTo(num, out);\n  };\n\n  // Multiply employing FFT\n  BN.prototype.mulf = function mulf (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return jumboMulTo(this, num, out);\n  };\n\n  // In-place Multiplication\n  BN.prototype.imul = function imul (num) {\n    return this.clone().mulTo(num, this);\n  };\n\n  BN.prototype.imuln = function imuln (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n\n    // Carry\n    var carry = 0;\n    for (var i = 0; i < this.length; i++) {\n      var w = (this.words[i] | 0) * num;\n      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n      carry >>= 26;\n      carry += (w / 0x4000000) | 0;\n      // NOTE: lo is 27bit maximum\n      carry += lo >>> 26;\n      this.words[i] = lo & 0x3ffffff;\n    }\n\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.muln = function muln (num) {\n    return this.clone().imuln(num);\n  };\n\n  // `this` * `this`\n  BN.prototype.sqr = function sqr () {\n    return this.mul(this);\n  };\n\n  // `this` * `this` in-place\n  BN.prototype.isqr = function isqr () {\n    return this.imul(this.clone());\n  };\n\n  // Math.pow(`this`, `num`)\n  BN.prototype.pow = function pow (num) {\n    var w = toBitArray(num);\n    if (w.length === 0) return new BN(1);\n\n    // Skip leading zeroes\n    var res = this;\n    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n      if (w[i] !== 0) break;\n    }\n\n    if (++i < w.length) {\n      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n        if (w[i] === 0) continue;\n\n        res = res.mul(q);\n      }\n    }\n\n    return res;\n  };\n\n  // Shift-left in-place\n  BN.prototype.iushln = function iushln (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n    var i;\n\n    if (r !== 0) {\n      var carry = 0;\n\n      for (i = 0; i < this.length; i++) {\n        var newCarry = this.words[i] & carryMask;\n        var c = ((this.words[i] | 0) - newCarry) << r;\n        this.words[i] = c | carry;\n        carry = newCarry >>> (26 - r);\n      }\n\n      if (carry) {\n        this.words[i] = carry;\n        this.length++;\n      }\n    }\n\n    if (s !== 0) {\n      for (i = this.length - 1; i >= 0; i--) {\n        this.words[i + s] = this.words[i];\n      }\n\n      for (i = 0; i < s; i++) {\n        this.words[i] = 0;\n      }\n\n      this.length += s;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishln = function ishln (bits) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushln(bits);\n  };\n\n  // Shift-right in-place\n  // NOTE: `hint` is a lowest bit before trailing zeroes\n  // NOTE: if `extended` is present - it will be filled with destroyed bits\n  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var h;\n    if (hint) {\n      h = (hint - (hint % 26)) / 26;\n    } else {\n      h = 0;\n    }\n\n    var r = bits % 26;\n    var s = Math.min((bits - r) / 26, this.length);\n    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n    var maskedWords = extended;\n\n    h -= s;\n    h = Math.max(0, h);\n\n    // Extended mode, copy masked part\n    if (maskedWords) {\n      for (var i = 0; i < s; i++) {\n        maskedWords.words[i] = this.words[i];\n      }\n      maskedWords.length = s;\n    }\n\n    if (s === 0) {\n      // No-op, we should not move anything at all\n    } else if (this.length > s) {\n      this.length -= s;\n      for (i = 0; i < this.length; i++) {\n        this.words[i] = this.words[i + s];\n      }\n    } else {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    var carry = 0;\n    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n      var word = this.words[i] | 0;\n      this.words[i] = (carry << (26 - r)) | (word >>> r);\n      carry = word & mask;\n    }\n\n    // Push carried bits as a mask\n    if (maskedWords && carry !== 0) {\n      maskedWords.words[maskedWords.length++] = carry;\n    }\n\n    if (this.length === 0) {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushrn(bits, hint, extended);\n  };\n\n  // Shift-left\n  BN.prototype.shln = function shln (bits) {\n    return this.clone().ishln(bits);\n  };\n\n  BN.prototype.ushln = function ushln (bits) {\n    return this.clone().iushln(bits);\n  };\n\n  // Shift-right\n  BN.prototype.shrn = function shrn (bits) {\n    return this.clone().ishrn(bits);\n  };\n\n  BN.prototype.ushrn = function ushrn (bits) {\n    return this.clone().iushrn(bits);\n  };\n\n  // Test if n bit is set\n  BN.prototype.testn = function testn (bit) {\n    assert(typeof bit === 'number' && bit >= 0);\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) return false;\n\n    // Check bit and return\n    var w = this.words[s];\n\n    return !!(w & q);\n  };\n\n  // Return only lowers bits of number (in-place)\n  BN.prototype.imaskn = function imaskn (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n\n    assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n    if (this.length <= s) {\n      return this;\n    }\n\n    if (r !== 0) {\n      s++;\n    }\n    this.length = Math.min(s, this.length);\n\n    if (r !== 0) {\n      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n      this.words[this.length - 1] &= mask;\n    }\n\n    return this._strip();\n  };\n\n  // Return only lowers bits of number\n  BN.prototype.maskn = function maskn (bits) {\n    return this.clone().imaskn(bits);\n  };\n\n  // Add plain number `num` to `this`\n  BN.prototype.iaddn = function iaddn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.isubn(-num);\n\n    // Possible sign change\n    if (this.negative !== 0) {\n      if (this.length === 1 && (this.words[0] | 0) <= num) {\n        this.words[0] = num - (this.words[0] | 0);\n        this.negative = 0;\n        return this;\n      }\n\n      this.negative = 0;\n      this.isubn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    // Add without checks\n    return this._iaddn(num);\n  };\n\n  BN.prototype._iaddn = function _iaddn (num) {\n    this.words[0] += num;\n\n    // Carry\n    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n      this.words[i] -= 0x4000000;\n      if (i === this.length - 1) {\n        this.words[i + 1] = 1;\n      } else {\n        this.words[i + 1]++;\n      }\n    }\n    this.length = Math.max(this.length, i + 1);\n\n    return this;\n  };\n\n  // Subtract plain number `num` from `this`\n  BN.prototype.isubn = function isubn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.iaddn(-num);\n\n    if (this.negative !== 0) {\n      this.negative = 0;\n      this.iaddn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    this.words[0] -= num;\n\n    if (this.length === 1 && this.words[0] < 0) {\n      this.words[0] = -this.words[0];\n      this.negative = 1;\n    } else {\n      // Carry\n      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n        this.words[i] += 0x4000000;\n        this.words[i + 1] -= 1;\n      }\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.addn = function addn (num) {\n    return this.clone().iaddn(num);\n  };\n\n  BN.prototype.subn = function subn (num) {\n    return this.clone().isubn(num);\n  };\n\n  BN.prototype.iabs = function iabs () {\n    this.negative = 0;\n\n    return this;\n  };\n\n  BN.prototype.abs = function abs () {\n    return this.clone().iabs();\n  };\n\n  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n    var len = num.length + shift;\n    var i;\n\n    this._expand(len);\n\n    var w;\n    var carry = 0;\n    for (i = 0; i < num.length; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      var right = (num.words[i] | 0) * mul;\n      w -= right & 0x3ffffff;\n      carry = (w >> 26) - ((right / 0x4000000) | 0);\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n    for (; i < this.length - shift; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      carry = w >> 26;\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    if (carry === 0) return this._strip();\n\n    // Subtraction overflow\n    assert(carry === -1);\n    carry = 0;\n    for (i = 0; i < this.length; i++) {\n      w = -(this.words[i] | 0) + carry;\n      carry = w >> 26;\n      this.words[i] = w & 0x3ffffff;\n    }\n    this.negative = 1;\n\n    return this._strip();\n  };\n\n  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n    var shift = this.length - num.length;\n\n    var a = this.clone();\n    var b = num;\n\n    // Normalize\n    var bhi = b.words[b.length - 1] | 0;\n    var bhiBits = this._countBits(bhi);\n    shift = 26 - bhiBits;\n    if (shift !== 0) {\n      b = b.ushln(shift);\n      a.iushln(shift);\n      bhi = b.words[b.length - 1] | 0;\n    }\n\n    // Initialize quotient\n    var m = a.length - b.length;\n    var q;\n\n    if (mode !== 'mod') {\n      q = new BN(null);\n      q.length = m + 1;\n      q.words = new Array(q.length);\n      for (var i = 0; i < q.length; i++) {\n        q.words[i] = 0;\n      }\n    }\n\n    var diff = a.clone()._ishlnsubmul(b, 1, m);\n    if (diff.negative === 0) {\n      a = diff;\n      if (q) {\n        q.words[m] = 1;\n      }\n    }\n\n    for (var j = m - 1; j >= 0; j--) {\n      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n        (a.words[b.length + j - 1] | 0);\n\n      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n      // (0x7ffffff)\n      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n      a._ishlnsubmul(b, qj, j);\n      while (a.negative !== 0) {\n        qj--;\n        a.negative = 0;\n        a._ishlnsubmul(b, 1, j);\n        if (!a.isZero()) {\n          a.negative ^= 1;\n        }\n      }\n      if (q) {\n        q.words[j] = qj;\n      }\n    }\n    if (q) {\n      q._strip();\n    }\n    a._strip();\n\n    // Denormalize\n    if (mode !== 'div' && shift !== 0) {\n      a.iushrn(shift);\n    }\n\n    return {\n      div: q || null,\n      mod: a\n    };\n  };\n\n  // NOTE: 1) `mode` can be set to `mod` to request mod only,\n  //       to `div` to request div only, or be absent to\n  //       request both div & mod\n  //       2) `positive` is true if unsigned mod is requested\n  BN.prototype.divmod = function divmod (num, mode, positive) {\n    assert(!num.isZero());\n\n    if (this.isZero()) {\n      return {\n        div: new BN(0),\n        mod: new BN(0)\n      };\n    }\n\n    var div, mod, res;\n    if (this.negative !== 0 && num.negative === 0) {\n      res = this.neg().divmod(num, mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.iadd(num);\n        }\n      }\n\n      return {\n        div: div,\n        mod: mod\n      };\n    }\n\n    if (this.negative === 0 && num.negative !== 0) {\n      res = this.divmod(num.neg(), mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      return {\n        div: div,\n        mod: res.mod\n      };\n    }\n\n    if ((this.negative & num.negative) !== 0) {\n      res = this.neg().divmod(num.neg(), mode);\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.isub(num);\n        }\n      }\n\n      return {\n        div: res.div,\n        mod: mod\n      };\n    }\n\n    // Both numbers are positive at this point\n\n    // Strip both numbers to approximate shift value\n    if (num.length > this.length || this.cmp(num) < 0) {\n      return {\n        div: new BN(0),\n        mod: this\n      };\n    }\n\n    // Very short reduction\n    if (num.length === 1) {\n      if (mode === 'div') {\n        return {\n          div: this.divn(num.words[0]),\n          mod: null\n        };\n      }\n\n      if (mode === 'mod') {\n        return {\n          div: null,\n          mod: new BN(this.modrn(num.words[0]))\n        };\n      }\n\n      return {\n        div: this.divn(num.words[0]),\n        mod: new BN(this.modrn(num.words[0]))\n      };\n    }\n\n    return this._wordDiv(num, mode);\n  };\n\n  // Find `this` / `num`\n  BN.prototype.div = function div (num) {\n    return this.divmod(num, 'div', false).div;\n  };\n\n  // Find `this` % `num`\n  BN.prototype.mod = function mod (num) {\n    return this.divmod(num, 'mod', false).mod;\n  };\n\n  BN.prototype.umod = function umod (num) {\n    return this.divmod(num, 'mod', true).mod;\n  };\n\n  // Find Round(`this` / `num`)\n  BN.prototype.divRound = function divRound (num) {\n    var dm = this.divmod(num);\n\n    // Fast case - exact division\n    if (dm.mod.isZero()) return dm.div;\n\n    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n    var half = num.ushrn(1);\n    var r2 = num.andln(1);\n    var cmp = mod.cmp(half);\n\n    // Round down\n    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;\n\n    // Round up\n    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n  };\n\n  BN.prototype.modrn = function modrn (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(num <= 0x3ffffff);\n    var p = (1 << 26) % num;\n\n    var acc = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      acc = (p * acc + (this.words[i] | 0)) % num;\n    }\n\n    return isNegNum ? -acc : acc;\n  };\n\n  // WARNING: DEPRECATED\n  BN.prototype.modn = function modn (num) {\n    return this.modrn(num);\n  };\n\n  // In-place division by number\n  BN.prototype.idivn = function idivn (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(num <= 0x3ffffff);\n\n    var carry = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var w = (this.words[i] | 0) + carry * 0x4000000;\n      this.words[i] = (w / num) | 0;\n      carry = w % num;\n    }\n\n    this._strip();\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.divn = function divn (num) {\n    return this.clone().idivn(num);\n  };\n\n  BN.prototype.egcd = function egcd (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var x = this;\n    var y = p.clone();\n\n    if (x.negative !== 0) {\n      x = x.umod(p);\n    } else {\n      x = x.clone();\n    }\n\n    // A * x + B * y = x\n    var A = new BN(1);\n    var B = new BN(0);\n\n    // C * x + D * y = y\n    var C = new BN(0);\n    var D = new BN(1);\n\n    var g = 0;\n\n    while (x.isEven() && y.isEven()) {\n      x.iushrn(1);\n      y.iushrn(1);\n      ++g;\n    }\n\n    var yp = y.clone();\n    var xp = x.clone();\n\n    while (!x.isZero()) {\n      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        x.iushrn(i);\n        while (i-- > 0) {\n          if (A.isOdd() || B.isOdd()) {\n            A.iadd(yp);\n            B.isub(xp);\n          }\n\n          A.iushrn(1);\n          B.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        y.iushrn(j);\n        while (j-- > 0) {\n          if (C.isOdd() || D.isOdd()) {\n            C.iadd(yp);\n            D.isub(xp);\n          }\n\n          C.iushrn(1);\n          D.iushrn(1);\n        }\n      }\n\n      if (x.cmp(y) >= 0) {\n        x.isub(y);\n        A.isub(C);\n        B.isub(D);\n      } else {\n        y.isub(x);\n        C.isub(A);\n        D.isub(B);\n      }\n    }\n\n    return {\n      a: C,\n      b: D,\n      gcd: y.iushln(g)\n    };\n  };\n\n  // This is reduced incarnation of the binary EEA\n  // above, designated to invert members of the\n  // _prime_ fields F(p) at a maximal speed\n  BN.prototype._invmp = function _invmp (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var a = this;\n    var b = p.clone();\n\n    if (a.negative !== 0) {\n      a = a.umod(p);\n    } else {\n      a = a.clone();\n    }\n\n    var x1 = new BN(1);\n    var x2 = new BN(0);\n\n    var delta = b.clone();\n\n    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        a.iushrn(i);\n        while (i-- > 0) {\n          if (x1.isOdd()) {\n            x1.iadd(delta);\n          }\n\n          x1.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        b.iushrn(j);\n        while (j-- > 0) {\n          if (x2.isOdd()) {\n            x2.iadd(delta);\n          }\n\n          x2.iushrn(1);\n        }\n      }\n\n      if (a.cmp(b) >= 0) {\n        a.isub(b);\n        x1.isub(x2);\n      } else {\n        b.isub(a);\n        x2.isub(x1);\n      }\n    }\n\n    var res;\n    if (a.cmpn(1) === 0) {\n      res = x1;\n    } else {\n      res = x2;\n    }\n\n    if (res.cmpn(0) < 0) {\n      res.iadd(p);\n    }\n\n    return res;\n  };\n\n  BN.prototype.gcd = function gcd (num) {\n    if (this.isZero()) return num.abs();\n    if (num.isZero()) return this.abs();\n\n    var a = this.clone();\n    var b = num.clone();\n    a.negative = 0;\n    b.negative = 0;\n\n    // Remove common factor of two\n    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n      a.iushrn(1);\n      b.iushrn(1);\n    }\n\n    do {\n      while (a.isEven()) {\n        a.iushrn(1);\n      }\n      while (b.isEven()) {\n        b.iushrn(1);\n      }\n\n      var r = a.cmp(b);\n      if (r < 0) {\n        // Swap `a` and `b` to make `a` always bigger than `b`\n        var t = a;\n        a = b;\n        b = t;\n      } else if (r === 0 || b.cmpn(1) === 0) {\n        break;\n      }\n\n      a.isub(b);\n    } while (true);\n\n    return b.iushln(shift);\n  };\n\n  // Invert number in the field F(num)\n  BN.prototype.invm = function invm (num) {\n    return this.egcd(num).a.umod(num);\n  };\n\n  BN.prototype.isEven = function isEven () {\n    return (this.words[0] & 1) === 0;\n  };\n\n  BN.prototype.isOdd = function isOdd () {\n    return (this.words[0] & 1) === 1;\n  };\n\n  // And first word and num\n  BN.prototype.andln = function andln (num) {\n    return this.words[0] & num;\n  };\n\n  // Increment at the bit position in-line\n  BN.prototype.bincn = function bincn (bit) {\n    assert(typeof bit === 'number');\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) {\n      this._expand(s + 1);\n      this.words[s] |= q;\n      return this;\n    }\n\n    // Add bit and propagate, if needed\n    var carry = q;\n    for (var i = s; carry !== 0 && i < this.length; i++) {\n      var w = this.words[i] | 0;\n      w += carry;\n      carry = w >>> 26;\n      w &= 0x3ffffff;\n      this.words[i] = w;\n    }\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n    return this;\n  };\n\n  BN.prototype.isZero = function isZero () {\n    return this.length === 1 && this.words[0] === 0;\n  };\n\n  BN.prototype.cmpn = function cmpn (num) {\n    var negative = num < 0;\n\n    if (this.negative !== 0 && !negative) return -1;\n    if (this.negative === 0 && negative) return 1;\n\n    this._strip();\n\n    var res;\n    if (this.length > 1) {\n      res = 1;\n    } else {\n      if (negative) {\n        num = -num;\n      }\n\n      assert(num <= 0x3ffffff, 'Number is too big');\n\n      var w = this.words[0] | 0;\n      res = w === num ? 0 : w < num ? -1 : 1;\n    }\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Compare two numbers and return:\n  // 1 - if `this` > `num`\n  // 0 - if `this` == `num`\n  // -1 - if `this` < `num`\n  BN.prototype.cmp = function cmp (num) {\n    if (this.negative !== 0 && num.negative === 0) return -1;\n    if (this.negative === 0 && num.negative !== 0) return 1;\n\n    var res = this.ucmp(num);\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Unsigned comparison\n  BN.prototype.ucmp = function ucmp (num) {\n    // At this point both numbers have the same sign\n    if (this.length > num.length) return 1;\n    if (this.length < num.length) return -1;\n\n    var res = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var a = this.words[i] | 0;\n      var b = num.words[i] | 0;\n\n      if (a === b) continue;\n      if (a < b) {\n        res = -1;\n      } else if (a > b) {\n        res = 1;\n      }\n      break;\n    }\n    return res;\n  };\n\n  BN.prototype.gtn = function gtn (num) {\n    return this.cmpn(num) === 1;\n  };\n\n  BN.prototype.gt = function gt (num) {\n    return this.cmp(num) === 1;\n  };\n\n  BN.prototype.gten = function gten (num) {\n    return this.cmpn(num) >= 0;\n  };\n\n  BN.prototype.gte = function gte (num) {\n    return this.cmp(num) >= 0;\n  };\n\n  BN.prototype.ltn = function ltn (num) {\n    return this.cmpn(num) === -1;\n  };\n\n  BN.prototype.lt = function lt (num) {\n    return this.cmp(num) === -1;\n  };\n\n  BN.prototype.lten = function lten (num) {\n    return this.cmpn(num) <= 0;\n  };\n\n  BN.prototype.lte = function lte (num) {\n    return this.cmp(num) <= 0;\n  };\n\n  BN.prototype.eqn = function eqn (num) {\n    return this.cmpn(num) === 0;\n  };\n\n  BN.prototype.eq = function eq (num) {\n    return this.cmp(num) === 0;\n  };\n\n  //\n  // A reduce context, could be using montgomery or something better, depending\n  // on the `m` itself.\n  //\n  BN.red = function red (num) {\n    return new Red(num);\n  };\n\n  BN.prototype.toRed = function toRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    assert(this.negative === 0, 'red works only with positives');\n    return ctx.convertTo(this)._forceRed(ctx);\n  };\n\n  BN.prototype.fromRed = function fromRed () {\n    assert(this.red, 'fromRed works only with numbers in reduction context');\n    return this.red.convertFrom(this);\n  };\n\n  BN.prototype._forceRed = function _forceRed (ctx) {\n    this.red = ctx;\n    return this;\n  };\n\n  BN.prototype.forceRed = function forceRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    return this._forceRed(ctx);\n  };\n\n  BN.prototype.redAdd = function redAdd (num) {\n    assert(this.red, 'redAdd works only with red numbers');\n    return this.red.add(this, num);\n  };\n\n  BN.prototype.redIAdd = function redIAdd (num) {\n    assert(this.red, 'redIAdd works only with red numbers');\n    return this.red.iadd(this, num);\n  };\n\n  BN.prototype.redSub = function redSub (num) {\n    assert(this.red, 'redSub works only with red numbers');\n    return this.red.sub(this, num);\n  };\n\n  BN.prototype.redISub = function redISub (num) {\n    assert(this.red, 'redISub works only with red numbers');\n    return this.red.isub(this, num);\n  };\n\n  BN.prototype.redShl = function redShl (num) {\n    assert(this.red, 'redShl works only with red numbers');\n    return this.red.shl(this, num);\n  };\n\n  BN.prototype.redMul = function redMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.mul(this, num);\n  };\n\n  BN.prototype.redIMul = function redIMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.imul(this, num);\n  };\n\n  BN.prototype.redSqr = function redSqr () {\n    assert(this.red, 'redSqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqr(this);\n  };\n\n  BN.prototype.redISqr = function redISqr () {\n    assert(this.red, 'redISqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.isqr(this);\n  };\n\n  // Square root over p\n  BN.prototype.redSqrt = function redSqrt () {\n    assert(this.red, 'redSqrt works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqrt(this);\n  };\n\n  BN.prototype.redInvm = function redInvm () {\n    assert(this.red, 'redInvm works only with red numbers');\n    this.red._verify1(this);\n    return this.red.invm(this);\n  };\n\n  // Return negative clone of `this` % `red modulo`\n  BN.prototype.redNeg = function redNeg () {\n    assert(this.red, 'redNeg works only with red numbers');\n    this.red._verify1(this);\n    return this.red.neg(this);\n  };\n\n  BN.prototype.redPow = function redPow (num) {\n    assert(this.red && !num.red, 'redPow(normalNum)');\n    this.red._verify1(this);\n    return this.red.pow(this, num);\n  };\n\n  // Prime numbers with efficient reduction\n  var primes = {\n    k256: null,\n    p224: null,\n    p192: null,\n    p25519: null\n  };\n\n  // Pseudo-Mersenne prime\n  function MPrime (name, p) {\n    // P = 2 ^ N - K\n    this.name = name;\n    this.p = new BN(p, 16);\n    this.n = this.p.bitLength();\n    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n    this.tmp = this._tmp();\n  }\n\n  MPrime.prototype._tmp = function _tmp () {\n    var tmp = new BN(null);\n    tmp.words = new Array(Math.ceil(this.n / 13));\n    return tmp;\n  };\n\n  MPrime.prototype.ireduce = function ireduce (num) {\n    // Assumes that `num` is less than `P^2`\n    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n    var r = num;\n    var rlen;\n\n    do {\n      this.split(r, this.tmp);\n      r = this.imulK(r);\n      r = r.iadd(this.tmp);\n      rlen = r.bitLength();\n    } while (rlen > this.n);\n\n    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n    if (cmp === 0) {\n      r.words[0] = 0;\n      r.length = 1;\n    } else if (cmp > 0) {\n      r.isub(this.p);\n    } else {\n      if (r.strip !== undefined) {\n        // r is a BN v4 instance\n        r.strip();\n      } else {\n        // r is a BN v5 instance\n        r._strip();\n      }\n    }\n\n    return r;\n  };\n\n  MPrime.prototype.split = function split (input, out) {\n    input.iushrn(this.n, 0, out);\n  };\n\n  MPrime.prototype.imulK = function imulK (num) {\n    return num.imul(this.k);\n  };\n\n  function K256 () {\n    MPrime.call(\n      this,\n      'k256',\n      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n  }\n  inherits(K256, MPrime);\n\n  K256.prototype.split = function split (input, output) {\n    // 256 = 9 * 26 + 22\n    var mask = 0x3fffff;\n\n    var outLen = Math.min(input.length, 9);\n    for (var i = 0; i < outLen; i++) {\n      output.words[i] = input.words[i];\n    }\n    output.length = outLen;\n\n    if (input.length <= 9) {\n      input.words[0] = 0;\n      input.length = 1;\n      return;\n    }\n\n    // Shift by 9 limbs\n    var prev = input.words[9];\n    output.words[output.length++] = prev & mask;\n\n    for (i = 10; i < input.length; i++) {\n      var next = input.words[i] | 0;\n      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n      prev = next;\n    }\n    prev >>>= 22;\n    input.words[i - 10] = prev;\n    if (prev === 0 && input.length > 10) {\n      input.length -= 10;\n    } else {\n      input.length -= 9;\n    }\n  };\n\n  K256.prototype.imulK = function imulK (num) {\n    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n    num.words[num.length] = 0;\n    num.words[num.length + 1] = 0;\n    num.length += 2;\n\n    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n    var lo = 0;\n    for (var i = 0; i < num.length; i++) {\n      var w = num.words[i] | 0;\n      lo += w * 0x3d1;\n      num.words[i] = lo & 0x3ffffff;\n      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n    }\n\n    // Fast length reduction\n    if (num.words[num.length - 1] === 0) {\n      num.length--;\n      if (num.words[num.length - 1] === 0) {\n        num.length--;\n      }\n    }\n    return num;\n  };\n\n  function P224 () {\n    MPrime.call(\n      this,\n      'p224',\n      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n  }\n  inherits(P224, MPrime);\n\n  function P192 () {\n    MPrime.call(\n      this,\n      'p192',\n      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n  }\n  inherits(P192, MPrime);\n\n  function P25519 () {\n    // 2 ^ 255 - 19\n    MPrime.call(\n      this,\n      '25519',\n      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n  }\n  inherits(P25519, MPrime);\n\n  P25519.prototype.imulK = function imulK (num) {\n    // K = 0x13\n    var carry = 0;\n    for (var i = 0; i < num.length; i++) {\n      var hi = (num.words[i] | 0) * 0x13 + carry;\n      var lo = hi & 0x3ffffff;\n      hi >>>= 26;\n\n      num.words[i] = lo;\n      carry = hi;\n    }\n    if (carry !== 0) {\n      num.words[num.length++] = carry;\n    }\n    return num;\n  };\n\n  // Exported mostly for testing purposes, use plain name instead\n  BN._prime = function prime (name) {\n    // Cached version of prime\n    if (primes[name]) return primes[name];\n\n    var prime;\n    if (name === 'k256') {\n      prime = new K256();\n    } else if (name === 'p224') {\n      prime = new P224();\n    } else if (name === 'p192') {\n      prime = new P192();\n    } else if (name === 'p25519') {\n      prime = new P25519();\n    } else {\n      throw new Error('Unknown prime ' + name);\n    }\n    primes[name] = prime;\n\n    return prime;\n  };\n\n  //\n  // Base reduction engine\n  //\n  function Red (m) {\n    if (typeof m === 'string') {\n      var prime = BN._prime(m);\n      this.m = prime.p;\n      this.prime = prime;\n    } else {\n      assert(m.gtn(1), 'modulus must be greater than 1');\n      this.m = m;\n      this.prime = null;\n    }\n  }\n\n  Red.prototype._verify1 = function _verify1 (a) {\n    assert(a.negative === 0, 'red works only with positives');\n    assert(a.red, 'red works only with red numbers');\n  };\n\n  Red.prototype._verify2 = function _verify2 (a, b) {\n    assert((a.negative | b.negative) === 0, 'red works only with positives');\n    assert(a.red && a.red === b.red,\n      'red works only with red numbers');\n  };\n\n  Red.prototype.imod = function imod (a) {\n    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n\n    move(a, a.umod(this.m)._forceRed(this));\n    return a;\n  };\n\n  Red.prototype.neg = function neg (a) {\n    if (a.isZero()) {\n      return a.clone();\n    }\n\n    return this.m.sub(a)._forceRed(this);\n  };\n\n  Red.prototype.add = function add (a, b) {\n    this._verify2(a, b);\n\n    var res = a.add(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.iadd = function iadd (a, b) {\n    this._verify2(a, b);\n\n    var res = a.iadd(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.sub = function sub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.sub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.isub = function isub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.isub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.shl = function shl (a, num) {\n    this._verify1(a);\n    return this.imod(a.ushln(num));\n  };\n\n  Red.prototype.imul = function imul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.imul(b));\n  };\n\n  Red.prototype.mul = function mul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.mul(b));\n  };\n\n  Red.prototype.isqr = function isqr (a) {\n    return this.imul(a, a.clone());\n  };\n\n  Red.prototype.sqr = function sqr (a) {\n    return this.mul(a, a);\n  };\n\n  Red.prototype.sqrt = function sqrt (a) {\n    if (a.isZero()) return a.clone();\n\n    var mod3 = this.m.andln(3);\n    assert(mod3 % 2 === 1);\n\n    // Fast case\n    if (mod3 === 3) {\n      var pow = this.m.add(new BN(1)).iushrn(2);\n      return this.pow(a, pow);\n    }\n\n    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n    //\n    // Find Q and S, that Q * 2 ^ S = (P - 1)\n    var q = this.m.subn(1);\n    var s = 0;\n    while (!q.isZero() && q.andln(1) === 0) {\n      s++;\n      q.iushrn(1);\n    }\n    assert(!q.isZero());\n\n    var one = new BN(1).toRed(this);\n    var nOne = one.redNeg();\n\n    // Find quadratic non-residue\n    // NOTE: Max is such because of generalized Riemann hypothesis.\n    var lpow = this.m.subn(1).iushrn(1);\n    var z = this.m.bitLength();\n    z = new BN(2 * z * z).toRed(this);\n\n    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n      z.redIAdd(nOne);\n    }\n\n    var c = this.pow(z, q);\n    var r = this.pow(a, q.addn(1).iushrn(1));\n    var t = this.pow(a, q);\n    var m = s;\n    while (t.cmp(one) !== 0) {\n      var tmp = t;\n      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n        tmp = tmp.redSqr();\n      }\n      assert(i < m);\n      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n      r = r.redMul(b);\n      c = b.redSqr();\n      t = t.redMul(c);\n      m = i;\n    }\n\n    return r;\n  };\n\n  Red.prototype.invm = function invm (a) {\n    var inv = a._invmp(this.m);\n    if (inv.negative !== 0) {\n      inv.negative = 0;\n      return this.imod(inv).redNeg();\n    } else {\n      return this.imod(inv);\n    }\n  };\n\n  Red.prototype.pow = function pow (a, num) {\n    if (num.isZero()) return new BN(1).toRed(this);\n    if (num.cmpn(1) === 0) return a.clone();\n\n    var windowSize = 4;\n    var wnd = new Array(1 << windowSize);\n    wnd[0] = new BN(1).toRed(this);\n    wnd[1] = a;\n    for (var i = 2; i < wnd.length; i++) {\n      wnd[i] = this.mul(wnd[i - 1], a);\n    }\n\n    var res = wnd[0];\n    var current = 0;\n    var currentLen = 0;\n    var start = num.bitLength() % 26;\n    if (start === 0) {\n      start = 26;\n    }\n\n    for (i = num.length - 1; i >= 0; i--) {\n      var word = num.words[i];\n      for (var j = start - 1; j >= 0; j--) {\n        var bit = (word >> j) & 1;\n        if (res !== wnd[0]) {\n          res = this.sqr(res);\n        }\n\n        if (bit === 0 && current === 0) {\n          currentLen = 0;\n          continue;\n        }\n\n        current <<= 1;\n        current |= bit;\n        currentLen++;\n        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n        res = this.mul(res, wnd[current]);\n        currentLen = 0;\n        current = 0;\n      }\n      start = 26;\n    }\n\n    return res;\n  };\n\n  Red.prototype.convertTo = function convertTo (num) {\n    var r = num.umod(this.m);\n\n    return r === num ? r.clone() : r;\n  };\n\n  Red.prototype.convertFrom = function convertFrom (num) {\n    var res = num.clone();\n    res.red = null;\n    return res;\n  };\n\n  //\n  // Montgomery method engine\n  //\n\n  BN.mont = function mont (num) {\n    return new Mont(num);\n  };\n\n  function Mont (m) {\n    Red.call(this, m);\n\n    this.shift = this.m.bitLength();\n    if (this.shift % 26 !== 0) {\n      this.shift += 26 - (this.shift % 26);\n    }\n\n    this.r = new BN(1).iushln(this.shift);\n    this.r2 = this.imod(this.r.sqr());\n    this.rinv = this.r._invmp(this.m);\n\n    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n    this.minv = this.minv.umod(this.r);\n    this.minv = this.r.sub(this.minv);\n  }\n  inherits(Mont, Red);\n\n  Mont.prototype.convertTo = function convertTo (num) {\n    return this.imod(num.ushln(this.shift));\n  };\n\n  Mont.prototype.convertFrom = function convertFrom (num) {\n    var r = this.imod(num.mul(this.rinv));\n    r.red = null;\n    return r;\n  };\n\n  Mont.prototype.imul = function imul (a, b) {\n    if (a.isZero() || b.isZero()) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    var t = a.imul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.mul = function mul (a, b) {\n    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n    var t = a.mul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.invm = function invm (a) {\n    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n    var res = this.imod(a._invmp(this.m).mul(this.r2));\n    return res._forceRed(this);\n  };\n})( false || module, this);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack://Fabric/./node_modules/browserify-rsa/node_modules/bn.js/lib/bn.js?");
./assets/fabric.min.js:eval("/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {\n  'use strict';\n\n  // Utils\n  function assert (val, msg) {\n    if (!val) throw new Error(msg || 'Assertion failed');\n  }\n\n  // Could use `inherits` module, but don't want to move from single file\n  // architecture yet.\n  function inherits (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  }\n\n  // BN\n\n  function BN (number, base, endian) {\n    if (BN.isBN(number)) {\n      return number;\n    }\n\n    this.negative = 0;\n    this.words = null;\n    this.length = 0;\n\n    // Reduction context\n    this.red = null;\n\n    if (number !== null) {\n      if (base === 'le' || base === 'be') {\n        endian = base;\n        base = 10;\n      }\n\n      this._init(number || 0, base || 10, endian || 'be');\n    }\n  }\n  if (typeof module === 'object') {\n    module.exports = BN;\n  } else {\n    exports.BN = BN;\n  }\n\n  BN.BN = BN;\n  BN.wordSize = 26;\n\n  var Buffer;\n  try {\n    Buffer = __webpack_require__(/*! buffer */ 9).Buffer;\n  } catch (e) {\n  }\n\n  BN.isBN = function isBN (num) {\n    if (num instanceof BN) {\n      return true;\n    }\n\n    return num !== null && typeof num === 'object' &&\n      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n  };\n\n  BN.max = function max (left, right) {\n    if (left.cmp(right) > 0) return left;\n    return right;\n  };\n\n  BN.min = function min (left, right) {\n    if (left.cmp(right) < 0) return left;\n    return right;\n  };\n\n  BN.prototype._init = function init (number, base, endian) {\n    if (typeof number === 'number') {\n      return this._initNumber(number, base, endian);\n    }\n\n    if (typeof number === 'object') {\n      return this._initArray(number, base, endian);\n    }\n\n    if (base === 'hex') {\n      base = 16;\n    }\n    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n    number = number.toString().replace(/\\s+/g, '');\n    var start = 0;\n    if (number[0] === '-') {\n      start++;\n    }\n\n    if (base === 16) {\n      this._parseHex(number, start);\n    } else {\n      this._parseBase(number, base, start);\n    }\n\n    if (number[0] === '-') {\n      this.negative = 1;\n    }\n\n    this._strip();\n\n    if (endian !== 'le') return;\n\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n    if (number < 0) {\n      this.negative = 1;\n      number = -number;\n    }\n    if (number < 0x4000000) {\n      this.words = [number & 0x3ffffff];\n      this.length = 1;\n    } else if (number < 0x10000000000000) {\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff\n      ];\n      this.length = 2;\n    } else {\n      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff,\n        1\n      ];\n      this.length = 3;\n    }\n\n    if (endian !== 'le') return;\n\n    // Reverse the bytes\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initArray = function _initArray (number, base, endian) {\n    // Perhaps a Uint8Array\n    assert(typeof number.length === 'number');\n    if (number.length <= 0) {\n      this.words = [0];\n      this.length = 1;\n      return this;\n    }\n\n    this.length = Math.ceil(number.length / 3);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    var off = 0;\n    if (endian === 'be') {\n      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    } else if (endian === 'le') {\n      for (i = 0, j = 0; i < number.length; i += 3) {\n        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    }\n    return this._strip();\n  };\n\n  function parseHex (str, start, end) {\n    var r = 0;\n    var len = Math.min(str.length, end);\n    var z = 0;\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r <<= 4;\n\n      var b;\n\n      // 'a' - 'f'\n      if (c >= 49 && c <= 54) {\n        b = c - 49 + 0xa;\n\n      // 'A' - 'F'\n      } else if (c >= 17 && c <= 22) {\n        b = c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        b = c;\n      }\n\n      r |= b;\n      z |= b;\n    }\n\n    assert(!(z & 0xf0), 'Invalid character in ' + str);\n    return r;\n  }\n\n  BN.prototype._parseHex = function _parseHex (number, start) {\n    // Create possibly bigger array to ensure that it fits the number\n    this.length = Math.ceil((number.length - start) / 6);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    // Scan 24-bit chunks and add them to the number\n    var off = 0;\n    for (i = number.length - 6, j = 0; i >= start; i -= 6) {\n      w = parseHex(number, i, i + 6);\n      this.words[j] |= (w << off) & 0x3ffffff;\n      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb\n      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n      off += 24;\n      if (off >= 26) {\n        off -= 26;\n        j++;\n      }\n    }\n    if (i + 6 !== start) {\n      w = parseHex(number, start, i + 6);\n      this.words[j] |= (w << off) & 0x3ffffff;\n      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n    }\n    this._strip();\n  };\n\n  function parseBase (str, start, end, mul) {\n    var r = 0;\n    var b = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r *= mul;\n\n      // 'a'\n      if (c >= 49) {\n        b = c - 49 + 0xa;\n\n      // 'A'\n      } else if (c >= 17) {\n        b = c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        b = c;\n      }\n      assert(c >= 0 && b < mul, 'Invalid character');\n      r += b;\n    }\n    return r;\n  }\n\n  BN.prototype._parseBase = function _parseBase (number, base, start) {\n    // Initialize as zero\n    this.words = [0];\n    this.length = 1;\n\n    // Find length of limb in base\n    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n      limbLen++;\n    }\n    limbLen--;\n    limbPow = (limbPow / base) | 0;\n\n    var total = number.length - start;\n    var mod = total % limbLen;\n    var end = Math.min(total, total - mod) + start;\n\n    var word = 0;\n    for (var i = start; i < end; i += limbLen) {\n      word = parseBase(number, i, i + limbLen, base);\n\n      this.imuln(limbPow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    if (mod !== 0) {\n      var pow = 1;\n      word = parseBase(number, i, number.length, base);\n\n      for (i = 0; i < mod; i++) {\n        pow *= base;\n      }\n\n      this.imuln(pow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n  };\n\n  BN.prototype.copy = function copy (dest) {\n    dest.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      dest.words[i] = this.words[i];\n    }\n    dest.length = this.length;\n    dest.negative = this.negative;\n    dest.red = this.red;\n  };\n\n  function move (dest, src) {\n    dest.words = src.words;\n    dest.length = src.length;\n    dest.negative = src.negative;\n    dest.red = src.red;\n  }\n\n  BN.prototype._move = function _move (dest) {\n    move(dest, this);\n  };\n\n  BN.prototype.clone = function clone () {\n    var r = new BN(null);\n    this.copy(r);\n    return r;\n  };\n\n  BN.prototype._expand = function _expand (size) {\n    while (this.length < size) {\n      this.words[this.length++] = 0;\n    }\n    return this;\n  };\n\n  // Remove leading `0` from `this`\n  BN.prototype._strip = function strip () {\n    while (this.length > 1 && this.words[this.length - 1] === 0) {\n      this.length--;\n    }\n    return this._normSign();\n  };\n\n  BN.prototype._normSign = function _normSign () {\n    // -0 = 0\n    if (this.length === 1 && this.words[0] === 0) {\n      this.negative = 0;\n    }\n    return this;\n  };\n\n  // Check Symbol.for because not everywhere where Symbol defined\n  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility\n  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {\n    try {\n      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;\n    } catch (e) {\n      BN.prototype.inspect = inspect;\n    }\n  } else {\n    BN.prototype.inspect = inspect;\n  }\n\n  function inspect () {\n    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n  }\n\n  /*\n\n  var zeros = [];\n  var groupSizes = [];\n  var groupBases = [];\n\n  var s = '';\n  var i = -1;\n  while (++i < BN.wordSize) {\n    zeros[i] = s;\n    s += '0';\n  }\n  groupSizes[0] = 0;\n  groupSizes[1] = 0;\n  groupBases[0] = 0;\n  groupBases[1] = 0;\n  var base = 2 - 1;\n  while (++base < 36 + 1) {\n    var groupSize = 0;\n    var groupBase = 1;\n    while (groupBase < (1 << BN.wordSize) / base) {\n      groupBase *= base;\n      groupSize += 1;\n    }\n    groupSizes[base] = groupSize;\n    groupBases[base] = groupBase;\n  }\n\n  */\n\n  var zeros = [\n    '',\n    '0',\n    '00',\n    '000',\n    '0000',\n    '00000',\n    '000000',\n    '0000000',\n    '00000000',\n    '000000000',\n    '0000000000',\n    '00000000000',\n    '000000000000',\n    '0000000000000',\n    '00000000000000',\n    '000000000000000',\n    '0000000000000000',\n    '00000000000000000',\n    '000000000000000000',\n    '0000000000000000000',\n    '00000000000000000000',\n    '000000000000000000000',\n    '0000000000000000000000',\n    '00000000000000000000000',\n    '000000000000000000000000',\n    '0000000000000000000000000'\n  ];\n\n  var groupSizes = [\n    0, 0,\n    25, 16, 12, 11, 10, 9, 8,\n    8, 7, 7, 7, 7, 6, 6,\n    6, 6, 6, 6, 6, 5, 5,\n    5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5\n  ];\n\n  var groupBases = [\n    0, 0,\n    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n  ];\n\n  BN.prototype.toString = function toString (base, padding) {\n    base = base || 10;\n    padding = padding | 0 || 1;\n\n    var out;\n    if (base === 16 || base === 'hex') {\n      out = '';\n      var off = 0;\n      var carry = 0;\n      for (var i = 0; i < this.length; i++) {\n        var w = this.words[i];\n        var word = (((w << off) | carry) & 0xffffff).toString(16);\n        carry = (w >>> (24 - off)) & 0xffffff;\n        if (carry !== 0 || i !== this.length - 1) {\n          out = zeros[6 - word.length] + word + out;\n        } else {\n          out = word + out;\n        }\n        off += 2;\n        if (off >= 26) {\n          off -= 26;\n          i--;\n        }\n      }\n      if (carry !== 0) {\n        out = carry.toString(16) + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    if (base === (base | 0) && base >= 2 && base <= 36) {\n      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n      var groupSize = groupSizes[base];\n      // var groupBase = Math.pow(base, groupSize);\n      var groupBase = groupBases[base];\n      out = '';\n      var c = this.clone();\n      c.negative = 0;\n      while (!c.isZero()) {\n        var r = c.modrn(groupBase).toString(base);\n        c = c.idivn(groupBase);\n\n        if (!c.isZero()) {\n          out = zeros[groupSize - r.length] + r + out;\n        } else {\n          out = r + out;\n        }\n      }\n      if (this.isZero()) {\n        out = '0' + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    assert(false, 'Base should be between 2 and 36');\n  };\n\n  BN.prototype.toNumber = function toNumber () {\n    var ret = this.words[0];\n    if (this.length === 2) {\n      ret += this.words[1] * 0x4000000;\n    } else if (this.length === 3 && this.words[2] === 0x01) {\n      // NOTE: at this stage it is known that the top bit is set\n      ret += 0x10000000000000 + (this.words[1] * 0x4000000);\n    } else if (this.length > 2) {\n      assert(false, 'Number can only safely store up to 53 bits');\n    }\n    return (this.negative !== 0) ? -ret : ret;\n  };\n\n  BN.prototype.toJSON = function toJSON () {\n    return this.toString(16, 2);\n  };\n\n  if (Buffer) {\n    BN.prototype.toBuffer = function toBuffer (endian, length) {\n      return this.toArrayLike(Buffer, endian, length);\n    };\n  }\n\n  BN.prototype.toArray = function toArray (endian, length) {\n    return this.toArrayLike(Array, endian, length);\n  };\n\n  var allocate = function allocate (ArrayType, size) {\n    if (ArrayType.allocUnsafe) {\n      return ArrayType.allocUnsafe(size);\n    }\n    return new ArrayType(size);\n  };\n\n  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {\n    this._strip();\n\n    var byteLength = this.byteLength();\n    var reqLength = length || Math.max(1, byteLength);\n    assert(byteLength <= reqLength, 'byte array longer than desired length');\n    assert(reqLength > 0, 'Requested array length <= 0');\n\n    var res = allocate(ArrayType, reqLength);\n    var postfix = endian === 'le' ? 'LE' : 'BE';\n    this['_toArrayLike' + postfix](res, byteLength);\n    return res;\n  };\n\n  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {\n    var position = 0;\n    var carry = 0;\n\n    for (var i = 0, shift = 0; i < this.length; i++) {\n      var word = (this.words[i] << shift) | carry;\n\n      res[position++] = word & 0xff;\n      if (position < res.length) {\n        res[position++] = (word >> 8) & 0xff;\n      }\n      if (position < res.length) {\n        res[position++] = (word >> 16) & 0xff;\n      }\n\n      if (shift === 6) {\n        if (position < res.length) {\n          res[position++] = (word >> 24) & 0xff;\n        }\n        carry = 0;\n        shift = 0;\n      } else {\n        carry = word >>> 24;\n        shift += 2;\n      }\n    }\n\n    if (position < res.length) {\n      res[position++] = carry;\n\n      while (position < res.length) {\n        res[position++] = 0;\n      }\n    }\n  };\n\n  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {\n    var position = res.length - 1;\n    var carry = 0;\n\n    for (var i = 0, shift = 0; i < this.length; i++) {\n      var word = (this.words[i] << shift) | carry;\n\n      res[position--] = word & 0xff;\n      if (position >= 0) {\n        res[position--] = (word >> 8) & 0xff;\n      }\n      if (position >= 0) {\n        res[position--] = (word >> 16) & 0xff;\n      }\n\n      if (shift === 6) {\n        if (position >= 0) {\n          res[position--] = (word >> 24) & 0xff;\n        }\n        carry = 0;\n        shift = 0;\n      } else {\n        carry = word >>> 24;\n        shift += 2;\n      }\n    }\n\n    if (position >= 0) {\n      res[position--] = carry;\n\n      while (position >= 0) {\n        res[position--] = 0;\n      }\n    }\n  };\n\n  if (Math.clz32) {\n    BN.prototype._countBits = function _countBits (w) {\n      return 32 - Math.clz32(w);\n    };\n  } else {\n    BN.prototype._countBits = function _countBits (w) {\n      var t = w;\n      var r = 0;\n      if (t >= 0x1000) {\n        r += 13;\n        t >>>= 13;\n      }\n      if (t >= 0x40) {\n        r += 7;\n        t >>>= 7;\n      }\n      if (t >= 0x8) {\n        r += 4;\n        t >>>= 4;\n      }\n      if (t >= 0x02) {\n        r += 2;\n        t >>>= 2;\n      }\n      return r + t;\n    };\n  }\n\n  BN.prototype._zeroBits = function _zeroBits (w) {\n    // Short-cut\n    if (w === 0) return 26;\n\n    var t = w;\n    var r = 0;\n    if ((t & 0x1fff) === 0) {\n      r += 13;\n      t >>>= 13;\n    }\n    if ((t & 0x7f) === 0) {\n      r += 7;\n      t >>>= 7;\n    }\n    if ((t & 0xf) === 0) {\n      r += 4;\n      t >>>= 4;\n    }\n    if ((t & 0x3) === 0) {\n      r += 2;\n      t >>>= 2;\n    }\n    if ((t & 0x1) === 0) {\n      r++;\n    }\n    return r;\n  };\n\n  // Return number of used bits in a BN\n  BN.prototype.bitLength = function bitLength () {\n    var w = this.words[this.length - 1];\n    var hi = this._countBits(w);\n    return (this.length - 1) * 26 + hi;\n  };\n\n  function toBitArray (num) {\n    var w = new Array(num.bitLength());\n\n    for (var bit = 0; bit < w.length; bit++) {\n      var off = (bit / 26) | 0;\n      var wbit = bit % 26;\n\n      w[bit] = (num.words[off] >>> wbit) & 0x01;\n    }\n\n    return w;\n  }\n\n  // Number of trailing zero bits\n  BN.prototype.zeroBits = function zeroBits () {\n    if (this.isZero()) return 0;\n\n    var r = 0;\n    for (var i = 0; i < this.length; i++) {\n      var b = this._zeroBits(this.words[i]);\n      r += b;\n      if (b !== 26) break;\n    }\n    return r;\n  };\n\n  BN.prototype.byteLength = function byteLength () {\n    return Math.ceil(this.bitLength() / 8);\n  };\n\n  BN.prototype.toTwos = function toTwos (width) {\n    if (this.negative !== 0) {\n      return this.abs().inotn(width).iaddn(1);\n    }\n    return this.clone();\n  };\n\n  BN.prototype.fromTwos = function fromTwos (width) {\n    if (this.testn(width - 1)) {\n      return this.notn(width).iaddn(1).ineg();\n    }\n    return this.clone();\n  };\n\n  BN.prototype.isNeg = function isNeg () {\n    return this.negative !== 0;\n  };\n\n  // Return negative clone of `this`\n  BN.prototype.neg = function neg () {\n    return this.clone().ineg();\n  };\n\n  BN.prototype.ineg = function ineg () {\n    if (!this.isZero()) {\n      this.negative ^= 1;\n    }\n\n    return this;\n  };\n\n  // Or `num` with `this` in-place\n  BN.prototype.iuor = function iuor (num) {\n    while (this.length < num.length) {\n      this.words[this.length++] = 0;\n    }\n\n    for (var i = 0; i < num.length; i++) {\n      this.words[i] = this.words[i] | num.words[i];\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ior = function ior (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuor(num);\n  };\n\n  // Or `num` with `this`\n  BN.prototype.or = function or (num) {\n    if (this.length > num.length) return this.clone().ior(num);\n    return num.clone().ior(this);\n  };\n\n  BN.prototype.uor = function uor (num) {\n    if (this.length > num.length) return this.clone().iuor(num);\n    return num.clone().iuor(this);\n  };\n\n  // And `num` with `this` in-place\n  BN.prototype.iuand = function iuand (num) {\n    // b = min-length(num, this)\n    var b;\n    if (this.length > num.length) {\n      b = num;\n    } else {\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = this.words[i] & num.words[i];\n    }\n\n    this.length = b.length;\n\n    return this._strip();\n  };\n\n  BN.prototype.iand = function iand (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuand(num);\n  };\n\n  // And `num` with `this`\n  BN.prototype.and = function and (num) {\n    if (this.length > num.length) return this.clone().iand(num);\n    return num.clone().iand(this);\n  };\n\n  BN.prototype.uand = function uand (num) {\n    if (this.length > num.length) return this.clone().iuand(num);\n    return num.clone().iuand(this);\n  };\n\n  // Xor `num` with `this` in-place\n  BN.prototype.iuxor = function iuxor (num) {\n    // a.length > b.length\n    var a;\n    var b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = a.words[i] ^ b.words[i];\n    }\n\n    if (this !== a) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = a.length;\n\n    return this._strip();\n  };\n\n  BN.prototype.ixor = function ixor (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuxor(num);\n  };\n\n  // Xor `num` with `this`\n  BN.prototype.xor = function xor (num) {\n    if (this.length > num.length) return this.clone().ixor(num);\n    return num.clone().ixor(this);\n  };\n\n  BN.prototype.uxor = function uxor (num) {\n    if (this.length > num.length) return this.clone().iuxor(num);\n    return num.clone().iuxor(this);\n  };\n\n  // Not ``this`` with ``width`` bitwidth\n  BN.prototype.inotn = function inotn (width) {\n    assert(typeof width === 'number' && width >= 0);\n\n    var bytesNeeded = Math.ceil(width / 26) | 0;\n    var bitsLeft = width % 26;\n\n    // Extend the buffer with leading zeroes\n    this._expand(bytesNeeded);\n\n    if (bitsLeft > 0) {\n      bytesNeeded--;\n    }\n\n    // Handle complete words\n    for (var i = 0; i < bytesNeeded; i++) {\n      this.words[i] = ~this.words[i] & 0x3ffffff;\n    }\n\n    // Handle the residue\n    if (bitsLeft > 0) {\n      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n    }\n\n    // And remove leading zeroes\n    return this._strip();\n  };\n\n  BN.prototype.notn = function notn (width) {\n    return this.clone().inotn(width);\n  };\n\n  // Set `bit` of `this`\n  BN.prototype.setn = function setn (bit, val) {\n    assert(typeof bit === 'number' && bit >= 0);\n\n    var off = (bit / 26) | 0;\n    var wbit = bit % 26;\n\n    this._expand(off + 1);\n\n    if (val) {\n      this.words[off] = this.words[off] | (1 << wbit);\n    } else {\n      this.words[off] = this.words[off] & ~(1 << wbit);\n    }\n\n    return this._strip();\n  };\n\n  // Add `num` to `this` in-place\n  BN.prototype.iadd = function iadd (num) {\n    var r;\n\n    // negative + positive\n    if (this.negative !== 0 && num.negative === 0) {\n      this.negative = 0;\n      r = this.isub(num);\n      this.negative ^= 1;\n      return this._normSign();\n\n    // positive + negative\n    } else if (this.negative === 0 && num.negative !== 0) {\n      num.negative = 0;\n      r = this.isub(num);\n      num.negative = 1;\n      return r._normSign();\n    }\n\n    // a.length > b.length\n    var a, b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    this.length = a.length;\n    if (carry !== 0) {\n      this.words[this.length] = carry;\n      this.length++;\n    // Copy the rest of the words\n    } else if (a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    return this;\n  };\n\n  // Add `num` to `this`\n  BN.prototype.add = function add (num) {\n    var res;\n    if (num.negative !== 0 && this.negative === 0) {\n      num.negative = 0;\n      res = this.sub(num);\n      num.negative ^= 1;\n      return res;\n    } else if (num.negative === 0 && this.negative !== 0) {\n      this.negative = 0;\n      res = num.sub(this);\n      this.negative = 1;\n      return res;\n    }\n\n    if (this.length > num.length) return this.clone().iadd(num);\n\n    return num.clone().iadd(this);\n  };\n\n  // Subtract `num` from `this` in-place\n  BN.prototype.isub = function isub (num) {\n    // this - (-num) = this + num\n    if (num.negative !== 0) {\n      num.negative = 0;\n      var r = this.iadd(num);\n      num.negative = 1;\n      return r._normSign();\n\n    // -this - num = -(this + num)\n    } else if (this.negative !== 0) {\n      this.negative = 0;\n      this.iadd(num);\n      this.negative = 1;\n      return this._normSign();\n    }\n\n    // At this point both numbers are positive\n    var cmp = this.cmp(num);\n\n    // Optimization - zeroify\n    if (cmp === 0) {\n      this.negative = 0;\n      this.length = 1;\n      this.words[0] = 0;\n      return this;\n    }\n\n    // a > b\n    var a, b;\n    if (cmp > 0) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n\n    // Copy rest of the words\n    if (carry === 0 && i < a.length && a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = Math.max(this.length, i);\n\n    if (a !== this) {\n      this.negative = 1;\n    }\n\n    return this._strip();\n  };\n\n  // Subtract `num` from `this`\n  BN.prototype.sub = function sub (num) {\n    return this.clone().isub(num);\n  };\n\n  function smallMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    var len = (self.length + num.length) | 0;\n    out.length = len;\n    len = (len - 1) | 0;\n\n    // Peel one iteration (compiler can't do it, because of code complexity)\n    var a = self.words[0] | 0;\n    var b = num.words[0] | 0;\n    var r = a * b;\n\n    var lo = r & 0x3ffffff;\n    var carry = (r / 0x4000000) | 0;\n    out.words[0] = lo;\n\n    for (var k = 1; k < len; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = carry >>> 26;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = (k - j) | 0;\n        a = self.words[i] | 0;\n        b = num.words[j] | 0;\n        r = a * b + rword;\n        ncarry += (r / 0x4000000) | 0;\n        rword = r & 0x3ffffff;\n      }\n      out.words[k] = rword | 0;\n      carry = ncarry | 0;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry | 0;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  }\n\n  // TODO(indutny): it may be reasonable to omit it for users who don't need\n  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n  // multiplication (like elliptic secp256k1).\n  var comb10MulTo = function comb10MulTo (self, num, out) {\n    var a = self.words;\n    var b = num.words;\n    var o = out.words;\n    var c = 0;\n    var lo;\n    var mid;\n    var hi;\n    var a0 = a[0] | 0;\n    var al0 = a0 & 0x1fff;\n    var ah0 = a0 >>> 13;\n    var a1 = a[1] | 0;\n    var al1 = a1 & 0x1fff;\n    var ah1 = a1 >>> 13;\n    var a2 = a[2] | 0;\n    var al2 = a2 & 0x1fff;\n    var ah2 = a2 >>> 13;\n    var a3 = a[3] | 0;\n    var al3 = a3 & 0x1fff;\n    var ah3 = a3 >>> 13;\n    var a4 = a[4] | 0;\n    var al4 = a4 & 0x1fff;\n    var ah4 = a4 >>> 13;\n    var a5 = a[5] | 0;\n    var al5 = a5 & 0x1fff;\n    var ah5 = a5 >>> 13;\n    var a6 = a[6] | 0;\n    var al6 = a6 & 0x1fff;\n    var ah6 = a6 >>> 13;\n    var a7 = a[7] | 0;\n    var al7 = a7 & 0x1fff;\n    var ah7 = a7 >>> 13;\n    var a8 = a[8] | 0;\n    var al8 = a8 & 0x1fff;\n    var ah8 = a8 >>> 13;\n    var a9 = a[9] | 0;\n    var al9 = a9 & 0x1fff;\n    var ah9 = a9 >>> 13;\n    var b0 = b[0] | 0;\n    var bl0 = b0 & 0x1fff;\n    var bh0 = b0 >>> 13;\n    var b1 = b[1] | 0;\n    var bl1 = b1 & 0x1fff;\n    var bh1 = b1 >>> 13;\n    var b2 = b[2] | 0;\n    var bl2 = b2 & 0x1fff;\n    var bh2 = b2 >>> 13;\n    var b3 = b[3] | 0;\n    var bl3 = b3 & 0x1fff;\n    var bh3 = b3 >>> 13;\n    var b4 = b[4] | 0;\n    var bl4 = b4 & 0x1fff;\n    var bh4 = b4 >>> 13;\n    var b5 = b[5] | 0;\n    var bl5 = b5 & 0x1fff;\n    var bh5 = b5 >>> 13;\n    var b6 = b[6] | 0;\n    var bl6 = b6 & 0x1fff;\n    var bh6 = b6 >>> 13;\n    var b7 = b[7] | 0;\n    var bl7 = b7 & 0x1fff;\n    var bh7 = b7 >>> 13;\n    var b8 = b[8] | 0;\n    var bl8 = b8 & 0x1fff;\n    var bh8 = b8 >>> 13;\n    var b9 = b[9] | 0;\n    var bl9 = b9 & 0x1fff;\n    var bh9 = b9 >>> 13;\n\n    out.negative = self.negative ^ num.negative;\n    out.length = 19;\n    /* k = 0 */\n    lo = Math.imul(al0, bl0);\n    mid = Math.imul(al0, bh0);\n    mid = (mid + Math.imul(ah0, bl0)) | 0;\n    hi = Math.imul(ah0, bh0);\n    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\n    w0 &= 0x3ffffff;\n    /* k = 1 */\n    lo = Math.imul(al1, bl0);\n    mid = Math.imul(al1, bh0);\n    mid = (mid + Math.imul(ah1, bl0)) | 0;\n    hi = Math.imul(ah1, bh0);\n    lo = (lo + Math.imul(al0, bl1)) | 0;\n    mid = (mid + Math.imul(al0, bh1)) | 0;\n    mid = (mid + Math.imul(ah0, bl1)) | 0;\n    hi = (hi + Math.imul(ah0, bh1)) | 0;\n    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\n    w1 &= 0x3ffffff;\n    /* k = 2 */\n    lo = Math.imul(al2, bl0);\n    mid = Math.imul(al2, bh0);\n    mid = (mid + Math.imul(ah2, bl0)) | 0;\n    hi = Math.imul(ah2, bh0);\n    lo = (lo + Math.imul(al1, bl1)) | 0;\n    mid = (mid + Math.imul(al1, bh1)) | 0;\n    mid = (mid + Math.imul(ah1, bl1)) | 0;\n    hi = (hi + Math.imul(ah1, bh1)) | 0;\n    lo = (lo + Math.imul(al0, bl2)) | 0;\n    mid = (mid + Math.imul(al0, bh2)) | 0;\n    mid = (mid + Math.imul(ah0, bl2)) | 0;\n    hi = (hi + Math.imul(ah0, bh2)) | 0;\n    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\n    w2 &= 0x3ffffff;\n    /* k = 3 */\n    lo = Math.imul(al3, bl0);\n    mid = Math.imul(al3, bh0);\n    mid = (mid + Math.imul(ah3, bl0)) | 0;\n    hi = Math.imul(ah3, bh0);\n    lo = (lo + Math.imul(al2, bl1)) | 0;\n    mid = (mid + Math.imul(al2, bh1)) | 0;\n    mid = (mid + Math.imul(ah2, bl1)) | 0;\n    hi = (hi + Math.imul(ah2, bh1)) | 0;\n    lo = (lo + Math.imul(al1, bl2)) | 0;\n    mid = (mid + Math.imul(al1, bh2)) | 0;\n    mid = (mid + Math.imul(ah1, bl2)) | 0;\n    hi = (hi + Math.imul(ah1, bh2)) | 0;\n    lo = (lo + Math.imul(al0, bl3)) | 0;\n    mid = (mid + Math.imul(al0, bh3)) | 0;\n    mid = (mid + Math.imul(ah0, bl3)) | 0;\n    hi = (hi + Math.imul(ah0, bh3)) | 0;\n    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\n    w3 &= 0x3ffffff;\n    /* k = 4 */\n    lo = Math.imul(al4, bl0);\n    mid = Math.imul(al4, bh0);\n    mid = (mid + Math.imul(ah4, bl0)) | 0;\n    hi = Math.imul(ah4, bh0);\n    lo = (lo + Math.imul(al3, bl1)) | 0;\n    mid = (mid + Math.imul(al3, bh1)) | 0;\n    mid = (mid + Math.imul(ah3, bl1)) | 0;\n    hi = (hi + Math.imul(ah3, bh1)) | 0;\n    lo = (lo + Math.imul(al2, bl2)) | 0;\n    mid = (mid + Math.imul(al2, bh2)) | 0;\n    mid = (mid + Math.imul(ah2, bl2)) | 0;\n    hi = (hi + Math.imul(ah2, bh2)) | 0;\n    lo = (lo + Math.imul(al1, bl3)) | 0;\n    mid = (mid + Math.imul(al1, bh3)) | 0;\n    mid = (mid + Math.imul(ah1, bl3)) | 0;\n    hi = (hi + Math.imul(ah1, bh3)) | 0;\n    lo = (lo + Math.imul(al0, bl4)) | 0;\n    mid = (mid + Math.imul(al0, bh4)) | 0;\n    mid = (mid + Math.imul(ah0, bl4)) | 0;\n    hi = (hi + Math.imul(ah0, bh4)) | 0;\n    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\n    w4 &= 0x3ffffff;\n    /* k = 5 */\n    lo = Math.imul(al5, bl0);\n    mid = Math.imul(al5, bh0);\n    mid = (mid + Math.imul(ah5, bl0)) | 0;\n    hi = Math.imul(ah5, bh0);\n    lo = (lo + Math.imul(al4, bl1)) | 0;\n    mid = (mid + Math.imul(al4, bh1)) | 0;\n    mid = (mid + Math.imul(ah4, bl1)) | 0;\n    hi = (hi + Math.imul(ah4, bh1)) | 0;\n    lo = (lo + Math.imul(al3, bl2)) | 0;\n    mid = (mid + Math.imul(al3, bh2)) | 0;\n    mid = (mid + Math.imul(ah3, bl2)) | 0;\n    hi = (hi + Math.imul(ah3, bh2)) | 0;\n    lo = (lo + Math.imul(al2, bl3)) | 0;\n    mid = (mid + Math.imul(al2, bh3)) | 0;\n    mid = (mid + Math.imul(ah2, bl3)) | 0;\n    hi = (hi + Math.imul(ah2, bh3)) | 0;\n    lo = (lo + Math.imul(al1, bl4)) | 0;\n    mid = (mid + Math.imul(al1, bh4)) | 0;\n    mid = (mid + Math.imul(ah1, bl4)) | 0;\n    hi = (hi + Math.imul(ah1, bh4)) | 0;\n    lo = (lo + Math.imul(al0, bl5)) | 0;\n    mid = (mid + Math.imul(al0, bh5)) | 0;\n    mid = (mid + Math.imul(ah0, bl5)) | 0;\n    hi = (hi + Math.imul(ah0, bh5)) | 0;\n    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\n    w5 &= 0x3ffffff;\n    /* k = 6 */\n    lo = Math.imul(al6, bl0);\n    mid = Math.imul(al6, bh0);\n    mid = (mid + Math.imul(ah6, bl0)) | 0;\n    hi = Math.imul(ah6, bh0);\n    lo = (lo + Math.imul(al5, bl1)) | 0;\n    mid = (mid + Math.imul(al5, bh1)) | 0;\n    mid = (mid + Math.imul(ah5, bl1)) | 0;\n    hi = (hi + Math.imul(ah5, bh1)) | 0;\n    lo = (lo + Math.imul(al4, bl2)) | 0;\n    mid = (mid + Math.imul(al4, bh2)) | 0;\n    mid = (mid + Math.imul(ah4, bl2)) | 0;\n    hi = (hi + Math.imul(ah4, bh2)) | 0;\n    lo = (lo + Math.imul(al3, bl3)) | 0;\n    mid = (mid + Math.imul(al3, bh3)) | 0;\n    mid = (mid + Math.imul(ah3, bl3)) | 0;\n    hi = (hi + Math.imul(ah3, bh3)) | 0;\n    lo = (lo + Math.imul(al2, bl4)) | 0;\n    mid = (mid + Math.imul(al2, bh4)) | 0;\n    mid = (mid + Math.imul(ah2, bl4)) | 0;\n    hi = (hi + Math.imul(ah2, bh4)) | 0;\n    lo = (lo + Math.imul(al1, bl5)) | 0;\n    mid = (mid + Math.imul(al1, bh5)) | 0;\n    mid = (mid + Math.imul(ah1, bl5)) | 0;\n    hi = (hi + Math.imul(ah1, bh5)) | 0;\n    lo = (lo + Math.imul(al0, bl6)) | 0;\n    mid = (mid + Math.imul(al0, bh6)) | 0;\n    mid = (mid + Math.imul(ah0, bl6)) | 0;\n    hi = (hi + Math.imul(ah0, bh6)) | 0;\n    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\n    w6 &= 0x3ffffff;\n    /* k = 7 */\n    lo = Math.imul(al7, bl0);\n    mid = Math.imul(al7, bh0);\n    mid = (mid + Math.imul(ah7, bl0)) | 0;\n    hi = Math.imul(ah7, bh0);\n    lo = (lo + Math.imul(al6, bl1)) | 0;\n    mid = (mid + Math.imul(al6, bh1)) | 0;\n    mid = (mid + Math.imul(ah6, bl1)) | 0;\n    hi = (hi + Math.imul(ah6, bh1)) | 0;\n    lo = (lo + Math.imul(al5, bl2)) | 0;\n    mid = (mid + Math.imul(al5, bh2)) | 0;\n    mid = (mid + Math.imul(ah5, bl2)) | 0;\n    hi = (hi + Math.imul(ah5, bh2)) | 0;\n    lo = (lo + Math.imul(al4, bl3)) | 0;\n    mid = (mid + Math.imul(al4, bh3)) | 0;\n    mid = (mid + Math.imul(ah4, bl3)) | 0;\n    hi = (hi + Math.imul(ah4, bh3)) | 0;\n    lo = (lo + Math.imul(al3, bl4)) | 0;\n    mid = (mid + Math.imul(al3, bh4)) | 0;\n    mid = (mid + Math.imul(ah3, bl4)) | 0;\n    hi = (hi + Math.imul(ah3, bh4)) | 0;\n    lo = (lo + Math.imul(al2, bl5)) | 0;\n    mid = (mid + Math.imul(al2, bh5)) | 0;\n    mid = (mid + Math.imul(ah2, bl5)) | 0;\n    hi = (hi + Math.imul(ah2, bh5)) | 0;\n    lo = (lo + Math.imul(al1, bl6)) | 0;\n    mid = (mid + Math.imul(al1, bh6)) | 0;\n    mid = (mid + Math.imul(ah1, bl6)) | 0;\n    hi = (hi + Math.imul(ah1, bh6)) | 0;\n    lo = (lo + Math.imul(al0, bl7)) | 0;\n    mid = (mid + Math.imul(al0, bh7)) | 0;\n    mid = (mid + Math.imul(ah0, bl7)) | 0;\n    hi = (hi + Math.imul(ah0, bh7)) | 0;\n    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\n    w7 &= 0x3ffffff;\n    /* k = 8 */\n    lo = Math.imul(al8, bl0);\n    mid = Math.imul(al8, bh0);\n    mid = (mid + Math.imul(ah8, bl0)) | 0;\n    hi = Math.imul(ah8, bh0);\n    lo = (lo + Math.imul(al7, bl1)) | 0;\n    mid = (mid + Math.imul(al7, bh1)) | 0;\n    mid = (mid + Math.imul(ah7, bl1)) | 0;\n    hi = (hi + Math.imul(ah7, bh1)) | 0;\n    lo = (lo + Math.imul(al6, bl2)) | 0;\n    mid = (mid + Math.imul(al6, bh2)) | 0;\n    mid = (mid + Math.imul(ah6, bl2)) | 0;\n    hi = (hi + Math.imul(ah6, bh2)) | 0;\n    lo = (lo + Math.imul(al5, bl3)) | 0;\n    mid = (mid + Math.imul(al5, bh3)) | 0;\n    mid = (mid + Math.imul(ah5, bl3)) | 0;\n    hi = (hi + Math.imul(ah5, bh3)) | 0;\n    lo = (lo + Math.imul(al4, bl4)) | 0;\n    mid = (mid + Math.imul(al4, bh4)) | 0;\n    mid = (mid + Math.imul(ah4, bl4)) | 0;\n    hi = (hi + Math.imul(ah4, bh4)) | 0;\n    lo = (lo + Math.imul(al3, bl5)) | 0;\n    mid = (mid + Math.imul(al3, bh5)) | 0;\n    mid = (mid + Math.imul(ah3, bl5)) | 0;\n    hi = (hi + Math.imul(ah3, bh5)) | 0;\n    lo = (lo + Math.imul(al2, bl6)) | 0;\n    mid = (mid + Math.imul(al2, bh6)) | 0;\n    mid = (mid + Math.imul(ah2, bl6)) | 0;\n    hi = (hi + Math.imul(ah2, bh6)) | 0;\n    lo = (lo + Math.imul(al1, bl7)) | 0;\n    mid = (mid + Math.imul(al1, bh7)) | 0;\n    mid = (mid + Math.imul(ah1, bl7)) | 0;\n    hi = (hi + Math.imul(ah1, bh7)) | 0;\n    lo = (lo + Math.imul(al0, bl8)) | 0;\n    mid = (mid + Math.imul(al0, bh8)) | 0;\n    mid = (mid + Math.imul(ah0, bl8)) | 0;\n    hi = (hi + Math.imul(ah0, bh8)) | 0;\n    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\n    w8 &= 0x3ffffff;\n    /* k = 9 */\n    lo = Math.imul(al9, bl0);\n    mid = Math.imul(al9, bh0);\n    mid = (mid + Math.imul(ah9, bl0)) | 0;\n    hi = Math.imul(ah9, bh0);\n    lo = (lo + Math.imul(al8, bl1)) | 0;\n    mid = (mid + Math.imul(al8, bh1)) | 0;\n    mid = (mid + Math.imul(ah8, bl1)) | 0;\n    hi = (hi + Math.imul(ah8, bh1)) | 0;\n    lo = (lo + Math.imul(al7, bl2)) | 0;\n    mid = (mid + Math.imul(al7, bh2)) | 0;\n    mid = (mid + Math.imul(ah7, bl2)) | 0;\n    hi = (hi + Math.imul(ah7, bh2)) | 0;\n    lo = (lo + Math.imul(al6, bl3)) | 0;\n    mid = (mid + Math.imul(al6, bh3)) | 0;\n    mid = (mid + Math.imul(ah6, bl3)) | 0;\n    hi = (hi + Math.imul(ah6, bh3)) | 0;\n    lo = (lo + Math.imul(al5, bl4)) | 0;\n    mid = (mid + Math.imul(al5, bh4)) | 0;\n    mid = (mid + Math.imul(ah5, bl4)) | 0;\n    hi = (hi + Math.imul(ah5, bh4)) | 0;\n    lo = (lo + Math.imul(al4, bl5)) | 0;\n    mid = (mid + Math.imul(al4, bh5)) | 0;\n    mid = (mid + Math.imul(ah4, bl5)) | 0;\n    hi = (hi + Math.imul(ah4, bh5)) | 0;\n    lo = (lo + Math.imul(al3, bl6)) | 0;\n    mid = (mid + Math.imul(al3, bh6)) | 0;\n    mid = (mid + Math.imul(ah3, bl6)) | 0;\n    hi = (hi + Math.imul(ah3, bh6)) | 0;\n    lo = (lo + Math.imul(al2, bl7)) | 0;\n    mid = (mid + Math.imul(al2, bh7)) | 0;\n    mid = (mid + Math.imul(ah2, bl7)) | 0;\n    hi = (hi + Math.imul(ah2, bh7)) | 0;\n    lo = (lo + Math.imul(al1, bl8)) | 0;\n    mid = (mid + Math.imul(al1, bh8)) | 0;\n    mid = (mid + Math.imul(ah1, bl8)) | 0;\n    hi = (hi + Math.imul(ah1, bh8)) | 0;\n    lo = (lo + Math.imul(al0, bl9)) | 0;\n    mid = (mid + Math.imul(al0, bh9)) | 0;\n    mid = (mid + Math.imul(ah0, bl9)) | 0;\n    hi = (hi + Math.imul(ah0, bh9)) | 0;\n    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\n    w9 &= 0x3ffffff;\n    /* k = 10 */\n    lo = Math.imul(al9, bl1);\n    mid = Math.imul(al9, bh1);\n    mid = (mid + Math.imul(ah9, bl1)) | 0;\n    hi = Math.imul(ah9, bh1);\n    lo = (lo + Math.imul(al8, bl2)) | 0;\n    mid = (mid + Math.imul(al8, bh2)) | 0;\n    mid = (mid + Math.imul(ah8, bl2)) | 0;\n    hi = (hi + Math.imul(ah8, bh2)) | 0;\n    lo = (lo + Math.imul(al7, bl3)) | 0;\n    mid = (mid + Math.imul(al7, bh3)) | 0;\n    mid = (mid + Math.imul(ah7, bl3)) | 0;\n    hi = (hi + Math.imul(ah7, bh3)) | 0;\n    lo = (lo + Math.imul(al6, bl4)) | 0;\n    mid = (mid + Math.imul(al6, bh4)) | 0;\n    mid = (mid + Math.imul(ah6, bl4)) | 0;\n    hi = (hi + Math.imul(ah6, bh4)) | 0;\n    lo = (lo + Math.imul(al5, bl5)) | 0;\n    mid = (mid + Math.imul(al5, bh5)) | 0;\n    mid = (mid + Math.imul(ah5, bl5)) | 0;\n    hi = (hi + Math.imul(ah5, bh5)) | 0;\n    lo = (lo + Math.imul(al4, bl6)) | 0;\n    mid = (mid + Math.imul(al4, bh6)) | 0;\n    mid = (mid + Math.imul(ah4, bl6)) | 0;\n    hi = (hi + Math.imul(ah4, bh6)) | 0;\n    lo = (lo + Math.imul(al3, bl7)) | 0;\n    mid = (mid + Math.imul(al3, bh7)) | 0;\n    mid = (mid + Math.imul(ah3, bl7)) | 0;\n    hi = (hi + Math.imul(ah3, bh7)) | 0;\n    lo = (lo + Math.imul(al2, bl8)) | 0;\n    mid = (mid + Math.imul(al2, bh8)) | 0;\n    mid = (mid + Math.imul(ah2, bl8)) | 0;\n    hi = (hi + Math.imul(ah2, bh8)) | 0;\n    lo = (lo + Math.imul(al1, bl9)) | 0;\n    mid = (mid + Math.imul(al1, bh9)) | 0;\n    mid = (mid + Math.imul(ah1, bl9)) | 0;\n    hi = (hi + Math.imul(ah1, bh9)) | 0;\n    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\n    w10 &= 0x3ffffff;\n    /* k = 11 */\n    lo = Math.imul(al9, bl2);\n    mid = Math.imul(al9, bh2);\n    mid = (mid + Math.imul(ah9, bl2)) | 0;\n    hi = Math.imul(ah9, bh2);\n    lo = (lo + Math.imul(al8, bl3)) | 0;\n    mid = (mid + Math.imul(al8, bh3)) | 0;\n    mid = (mid + Math.imul(ah8, bl3)) | 0;\n    hi = (hi + Math.imul(ah8, bh3)) | 0;\n    lo = (lo + Math.imul(al7, bl4)) | 0;\n    mid = (mid + Math.imul(al7, bh4)) | 0;\n    mid = (mid + Math.imul(ah7, bl4)) | 0;\n    hi = (hi + Math.imul(ah7, bh4)) | 0;\n    lo = (lo + Math.imul(al6, bl5)) | 0;\n    mid = (mid + Math.imul(al6, bh5)) | 0;\n    mid = (mid + Math.imul(ah6, bl5)) | 0;\n    hi = (hi + Math.imul(ah6, bh5)) | 0;\n    lo = (lo + Math.imul(al5, bl6)) | 0;\n    mid = (mid + Math.imul(al5, bh6)) | 0;\n    mid = (mid + Math.imul(ah5, bl6)) | 0;\n    hi = (hi + Math.imul(ah5, bh6)) | 0;\n    lo = (lo + Math.imul(al4, bl7)) | 0;\n    mid = (mid + Math.imul(al4, bh7)) | 0;\n    mid = (mid + Math.imul(ah4, bl7)) | 0;\n    hi = (hi + Math.imul(ah4, bh7)) | 0;\n    lo = (lo + Math.imul(al3, bl8)) | 0;\n    mid = (mid + Math.imul(al3, bh8)) | 0;\n    mid = (mid + Math.imul(ah3, bl8)) | 0;\n    hi = (hi + Math.imul(ah3, bh8)) | 0;\n    lo = (lo + Math.imul(al2, bl9)) | 0;\n    mid = (mid + Math.imul(al2, bh9)) | 0;\n    mid = (mid + Math.imul(ah2, bl9)) | 0;\n    hi = (hi + Math.imul(ah2, bh9)) | 0;\n    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\n    w11 &= 0x3ffffff;\n    /* k = 12 */\n    lo = Math.imul(al9, bl3);\n    mid = Math.imul(al9, bh3);\n    mid = (mid + Math.imul(ah9, bl3)) | 0;\n    hi = Math.imul(ah9, bh3);\n    lo = (lo + Math.imul(al8, bl4)) | 0;\n    mid = (mid + Math.imul(al8, bh4)) | 0;\n    mid = (mid + Math.imul(ah8, bl4)) | 0;\n    hi = (hi + Math.imul(ah8, bh4)) | 0;\n    lo = (lo + Math.imul(al7, bl5)) | 0;\n    mid = (mid + Math.imul(al7, bh5)) | 0;\n    mid = (mid + Math.imul(ah7, bl5)) | 0;\n    hi = (hi + Math.imul(ah7, bh5)) | 0;\n    lo = (lo + Math.imul(al6, bl6)) | 0;\n    mid = (mid + Math.imul(al6, bh6)) | 0;\n    mid = (mid + Math.imul(ah6, bl6)) | 0;\n    hi = (hi + Math.imul(ah6, bh6)) | 0;\n    lo = (lo + Math.imul(al5, bl7)) | 0;\n    mid = (mid + Math.imul(al5, bh7)) | 0;\n    mid = (mid + Math.imul(ah5, bl7)) | 0;\n    hi = (hi + Math.imul(ah5, bh7)) | 0;\n    lo = (lo + Math.imul(al4, bl8)) | 0;\n    mid = (mid + Math.imul(al4, bh8)) | 0;\n    mid = (mid + Math.imul(ah4, bl8)) | 0;\n    hi = (hi + Math.imul(ah4, bh8)) | 0;\n    lo = (lo + Math.imul(al3, bl9)) | 0;\n    mid = (mid + Math.imul(al3, bh9)) | 0;\n    mid = (mid + Math.imul(ah3, bl9)) | 0;\n    hi = (hi + Math.imul(ah3, bh9)) | 0;\n    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\n    w12 &= 0x3ffffff;\n    /* k = 13 */\n    lo = Math.imul(al9, bl4);\n    mid = Math.imul(al9, bh4);\n    mid = (mid + Math.imul(ah9, bl4)) | 0;\n    hi = Math.imul(ah9, bh4);\n    lo = (lo + Math.imul(al8, bl5)) | 0;\n    mid = (mid + Math.imul(al8, bh5)) | 0;\n    mid = (mid + Math.imul(ah8, bl5)) | 0;\n    hi = (hi + Math.imul(ah8, bh5)) | 0;\n    lo = (lo + Math.imul(al7, bl6)) | 0;\n    mid = (mid + Math.imul(al7, bh6)) | 0;\n    mid = (mid + Math.imul(ah7, bl6)) | 0;\n    hi = (hi + Math.imul(ah7, bh6)) | 0;\n    lo = (lo + Math.imul(al6, bl7)) | 0;\n    mid = (mid + Math.imul(al6, bh7)) | 0;\n    mid = (mid + Math.imul(ah6, bl7)) | 0;\n    hi = (hi + Math.imul(ah6, bh7)) | 0;\n    lo = (lo + Math.imul(al5, bl8)) | 0;\n    mid = (mid + Math.imul(al5, bh8)) | 0;\n    mid = (mid + Math.imul(ah5, bl8)) | 0;\n    hi = (hi + Math.imul(ah5, bh8)) | 0;\n    lo = (lo + Math.imul(al4, bl9)) | 0;\n    mid = (mid + Math.imul(al4, bh9)) | 0;\n    mid = (mid + Math.imul(ah4, bl9)) | 0;\n    hi = (hi + Math.imul(ah4, bh9)) | 0;\n    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\n    w13 &= 0x3ffffff;\n    /* k = 14 */\n    lo = Math.imul(al9, bl5);\n    mid = Math.imul(al9, bh5);\n    mid = (mid + Math.imul(ah9, bl5)) | 0;\n    hi = Math.imul(ah9, bh5);\n    lo = (lo + Math.imul(al8, bl6)) | 0;\n    mid = (mid + Math.imul(al8, bh6)) | 0;\n    mid = (mid + Math.imul(ah8, bl6)) | 0;\n    hi = (hi + Math.imul(ah8, bh6)) | 0;\n    lo = (lo + Math.imul(al7, bl7)) | 0;\n    mid = (mid + Math.imul(al7, bh7)) | 0;\n    mid = (mid + Math.imul(ah7, bl7)) | 0;\n    hi = (hi + Math.imul(ah7, bh7)) | 0;\n    lo = (lo + Math.imul(al6, bl8)) | 0;\n    mid = (mid + Math.imul(al6, bh8)) | 0;\n    mid = (mid + Math.imul(ah6, bl8)) | 0;\n    hi = (hi + Math.imul(ah6, bh8)) | 0;\n    lo = (lo + Math.imul(al5, bl9)) | 0;\n    mid = (mid + Math.imul(al5, bh9)) | 0;\n    mid = (mid + Math.imul(ah5, bl9)) | 0;\n    hi = (hi + Math.imul(ah5, bh9)) | 0;\n    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\n    w14 &= 0x3ffffff;\n    /* k = 15 */\n    lo = Math.imul(al9, bl6);\n    mid = Math.imul(al9, bh6);\n    mid = (mid + Math.imul(ah9, bl6)) | 0;\n    hi = Math.imul(ah9, bh6);\n    lo = (lo + Math.imul(al8, bl7)) | 0;\n    mid = (mid + Math.imul(al8, bh7)) | 0;\n    mid = (mid + Math.imul(ah8, bl7)) | 0;\n    hi = (hi + Math.imul(ah8, bh7)) | 0;\n    lo = (lo + Math.imul(al7, bl8)) | 0;\n    mid = (mid + Math.imul(al7, bh8)) | 0;\n    mid = (mid + Math.imul(ah7, bl8)) | 0;\n    hi = (hi + Math.imul(ah7, bh8)) | 0;\n    lo = (lo + Math.imul(al6, bl9)) | 0;\n    mid = (mid + Math.imul(al6, bh9)) | 0;\n    mid = (mid + Math.imul(ah6, bl9)) | 0;\n    hi = (hi + Math.imul(ah6, bh9)) | 0;\n    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\n    w15 &= 0x3ffffff;\n    /* k = 16 */\n    lo = Math.imul(al9, bl7);\n    mid = Math.imul(al9, bh7);\n    mid = (mid + Math.imul(ah9, bl7)) | 0;\n    hi = Math.imul(ah9, bh7);\n    lo = (lo + Math.imul(al8, bl8)) | 0;\n    mid = (mid + Math.imul(al8, bh8)) | 0;\n    mid = (mid + Math.imul(ah8, bl8)) | 0;\n    hi = (hi + Math.imul(ah8, bh8)) | 0;\n    lo = (lo + Math.imul(al7, bl9)) | 0;\n    mid = (mid + Math.imul(al7, bh9)) | 0;\n    mid = (mid + Math.imul(ah7, bl9)) | 0;\n    hi = (hi + Math.imul(ah7, bh9)) | 0;\n    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\n    w16 &= 0x3ffffff;\n    /* k = 17 */\n    lo = Math.imul(al9, bl8);\n    mid = Math.imul(al9, bh8);\n    mid = (mid + Math.imul(ah9, bl8)) | 0;\n    hi = Math.imul(ah9, bh8);\n    lo = (lo + Math.imul(al8, bl9)) | 0;\n    mid = (mid + Math.imul(al8, bh9)) | 0;\n    mid = (mid + Math.imul(ah8, bl9)) | 0;\n    hi = (hi + Math.imul(ah8, bh9)) | 0;\n    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\n    w17 &= 0x3ffffff;\n    /* k = 18 */\n    lo = Math.imul(al9, bl9);\n    mid = Math.imul(al9, bh9);\n    mid = (mid + Math.imul(ah9, bl9)) | 0;\n    hi = Math.imul(ah9, bh9);\n    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\n    w18 &= 0x3ffffff;\n    o[0] = w0;\n    o[1] = w1;\n    o[2] = w2;\n    o[3] = w3;\n    o[4] = w4;\n    o[5] = w5;\n    o[6] = w6;\n    o[7] = w7;\n    o[8] = w8;\n    o[9] = w9;\n    o[10] = w10;\n    o[11] = w11;\n    o[12] = w12;\n    o[13] = w13;\n    o[14] = w14;\n    o[15] = w15;\n    o[16] = w16;\n    o[17] = w17;\n    o[18] = w18;\n    if (c !== 0) {\n      o[19] = c;\n      out.length++;\n    }\n    return out;\n  };\n\n  // Polyfill comb\n  if (!Math.imul) {\n    comb10MulTo = smallMulTo;\n  }\n\n  function bigMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    out.length = self.length + num.length;\n\n    var carry = 0;\n    var hncarry = 0;\n    for (var k = 0; k < out.length - 1; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = hncarry;\n      hncarry = 0;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = k - j;\n        var a = self.words[i] | 0;\n        var b = num.words[j] | 0;\n        var r = a * b;\n\n        var lo = r & 0x3ffffff;\n        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n        lo = (lo + rword) | 0;\n        rword = lo & 0x3ffffff;\n        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n        hncarry += ncarry >>> 26;\n        ncarry &= 0x3ffffff;\n      }\n      out.words[k] = rword;\n      carry = ncarry;\n      ncarry = hncarry;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  }\n\n  function jumboMulTo (self, num, out) {\n    // Temporary disable, see https://github.com/indutny/bn.js/issues/211\n    // var fftm = new FFTM();\n    // return fftm.mulp(self, num, out);\n    return bigMulTo(self, num, out);\n  }\n\n  BN.prototype.mulTo = function mulTo (num, out) {\n    var res;\n    var len = this.length + num.length;\n    if (this.length === 10 && num.length === 10) {\n      res = comb10MulTo(this, num, out);\n    } else if (len < 63) {\n      res = smallMulTo(this, num, out);\n    } else if (len < 1024) {\n      res = bigMulTo(this, num, out);\n    } else {\n      res = jumboMulTo(this, num, out);\n    }\n\n    return res;\n  };\n\n  // Cooley-Tukey algorithm for FFT\n  // slightly revisited to rely on looping instead of recursion\n\n  function FFTM (x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  FFTM.prototype.makeRBT = function makeRBT (N) {\n    var t = new Array(N);\n    var l = BN.prototype._countBits(N) - 1;\n    for (var i = 0; i < N; i++) {\n      t[i] = this.revBin(i, l, N);\n    }\n\n    return t;\n  };\n\n  // Returns binary-reversed representation of `x`\n  FFTM.prototype.revBin = function revBin (x, l, N) {\n    if (x === 0 || x === N - 1) return x;\n\n    var rb = 0;\n    for (var i = 0; i < l; i++) {\n      rb |= (x & 1) << (l - i - 1);\n      x >>= 1;\n    }\n\n    return rb;\n  };\n\n  // Performs \"tweedling\" phase, therefore 'emulating'\n  // behaviour of the recursive algorithm\n  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n    for (var i = 0; i < N; i++) {\n      rtws[i] = rws[rbt[i]];\n      itws[i] = iws[rbt[i]];\n    }\n  };\n\n  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n    this.permute(rbt, rws, iws, rtws, itws, N);\n\n    for (var s = 1; s < N; s <<= 1) {\n      var l = s << 1;\n\n      var rtwdf = Math.cos(2 * Math.PI / l);\n      var itwdf = Math.sin(2 * Math.PI / l);\n\n      for (var p = 0; p < N; p += l) {\n        var rtwdf_ = rtwdf;\n        var itwdf_ = itwdf;\n\n        for (var j = 0; j < s; j++) {\n          var re = rtws[p + j];\n          var ie = itws[p + j];\n\n          var ro = rtws[p + j + s];\n          var io = itws[p + j + s];\n\n          var rx = rtwdf_ * ro - itwdf_ * io;\n\n          io = rtwdf_ * io + itwdf_ * ro;\n          ro = rx;\n\n          rtws[p + j] = re + ro;\n          itws[p + j] = ie + io;\n\n          rtws[p + j + s] = re - ro;\n          itws[p + j + s] = ie - io;\n\n          /* jshint maxdepth : false */\n          if (j !== l) {\n            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n            rtwdf_ = rx;\n          }\n        }\n      }\n    }\n  };\n\n  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n    var N = Math.max(m, n) | 1;\n    var odd = N & 1;\n    var i = 0;\n    for (N = N / 2 | 0; N; N = N >>> 1) {\n      i++;\n    }\n\n    return 1 << i + 1 + odd;\n  };\n\n  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n    if (N <= 1) return;\n\n    for (var i = 0; i < N / 2; i++) {\n      var t = rws[i];\n\n      rws[i] = rws[N - i - 1];\n      rws[N - i - 1] = t;\n\n      t = iws[i];\n\n      iws[i] = -iws[N - i - 1];\n      iws[N - i - 1] = -t;\n    }\n  };\n\n  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n    var carry = 0;\n    for (var i = 0; i < N / 2; i++) {\n      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n        Math.round(ws[2 * i] / N) +\n        carry;\n\n      ws[i] = w & 0x3ffffff;\n\n      if (w < 0x4000000) {\n        carry = 0;\n      } else {\n        carry = w / 0x4000000 | 0;\n      }\n    }\n\n    return ws;\n  };\n\n  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n    var carry = 0;\n    for (var i = 0; i < len; i++) {\n      carry = carry + (ws[i] | 0);\n\n      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n    }\n\n    // Pad with zeroes\n    for (i = 2 * len; i < N; ++i) {\n      rws[i] = 0;\n    }\n\n    assert(carry === 0);\n    assert((carry & ~0x1fff) === 0);\n  };\n\n  FFTM.prototype.stub = function stub (N) {\n    var ph = new Array(N);\n    for (var i = 0; i < N; i++) {\n      ph[i] = 0;\n    }\n\n    return ph;\n  };\n\n  FFTM.prototype.mulp = function mulp (x, y, out) {\n    var N = 2 * this.guessLen13b(x.length, y.length);\n\n    var rbt = this.makeRBT(N);\n\n    var _ = this.stub(N);\n\n    var rws = new Array(N);\n    var rwst = new Array(N);\n    var iwst = new Array(N);\n\n    var nrws = new Array(N);\n    var nrwst = new Array(N);\n    var niwst = new Array(N);\n\n    var rmws = out.words;\n    rmws.length = N;\n\n    this.convert13b(x.words, x.length, rws, N);\n    this.convert13b(y.words, y.length, nrws, N);\n\n    this.transform(rws, _, rwst, iwst, N, rbt);\n    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n    for (var i = 0; i < N; i++) {\n      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n      rwst[i] = rx;\n    }\n\n    this.conjugate(rwst, iwst, N);\n    this.transform(rwst, iwst, rmws, _, N, rbt);\n    this.conjugate(rmws, _, N);\n    this.normalize13b(rmws, N);\n\n    out.negative = x.negative ^ y.negative;\n    out.length = x.length + y.length;\n    return out._strip();\n  };\n\n  // Multiply `this` by `num`\n  BN.prototype.mul = function mul (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return this.mulTo(num, out);\n  };\n\n  // Multiply employing FFT\n  BN.prototype.mulf = function mulf (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return jumboMulTo(this, num, out);\n  };\n\n  // In-place Multiplication\n  BN.prototype.imul = function imul (num) {\n    return this.clone().mulTo(num, this);\n  };\n\n  BN.prototype.imuln = function imuln (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n\n    // Carry\n    var carry = 0;\n    for (var i = 0; i < this.length; i++) {\n      var w = (this.words[i] | 0) * num;\n      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n      carry >>= 26;\n      carry += (w / 0x4000000) | 0;\n      // NOTE: lo is 27bit maximum\n      carry += lo >>> 26;\n      this.words[i] = lo & 0x3ffffff;\n    }\n\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.muln = function muln (num) {\n    return this.clone().imuln(num);\n  };\n\n  // `this` * `this`\n  BN.prototype.sqr = function sqr () {\n    return this.mul(this);\n  };\n\n  // `this` * `this` in-place\n  BN.prototype.isqr = function isqr () {\n    return this.imul(this.clone());\n  };\n\n  // Math.pow(`this`, `num`)\n  BN.prototype.pow = function pow (num) {\n    var w = toBitArray(num);\n    if (w.length === 0) return new BN(1);\n\n    // Skip leading zeroes\n    var res = this;\n    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n      if (w[i] !== 0) break;\n    }\n\n    if (++i < w.length) {\n      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n        if (w[i] === 0) continue;\n\n        res = res.mul(q);\n      }\n    }\n\n    return res;\n  };\n\n  // Shift-left in-place\n  BN.prototype.iushln = function iushln (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n    var i;\n\n    if (r !== 0) {\n      var carry = 0;\n\n      for (i = 0; i < this.length; i++) {\n        var newCarry = this.words[i] & carryMask;\n        var c = ((this.words[i] | 0) - newCarry) << r;\n        this.words[i] = c | carry;\n        carry = newCarry >>> (26 - r);\n      }\n\n      if (carry) {\n        this.words[i] = carry;\n        this.length++;\n      }\n    }\n\n    if (s !== 0) {\n      for (i = this.length - 1; i >= 0; i--) {\n        this.words[i + s] = this.words[i];\n      }\n\n      for (i = 0; i < s; i++) {\n        this.words[i] = 0;\n      }\n\n      this.length += s;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishln = function ishln (bits) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushln(bits);\n  };\n\n  // Shift-right in-place\n  // NOTE: `hint` is a lowest bit before trailing zeroes\n  // NOTE: if `extended` is present - it will be filled with destroyed bits\n  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var h;\n    if (hint) {\n      h = (hint - (hint % 26)) / 26;\n    } else {\n      h = 0;\n    }\n\n    var r = bits % 26;\n    var s = Math.min((bits - r) / 26, this.length);\n    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n    var maskedWords = extended;\n\n    h -= s;\n    h = Math.max(0, h);\n\n    // Extended mode, copy masked part\n    if (maskedWords) {\n      for (var i = 0; i < s; i++) {\n        maskedWords.words[i] = this.words[i];\n      }\n      maskedWords.length = s;\n    }\n\n    if (s === 0) {\n      // No-op, we should not move anything at all\n    } else if (this.length > s) {\n      this.length -= s;\n      for (i = 0; i < this.length; i++) {\n        this.words[i] = this.words[i + s];\n      }\n    } else {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    var carry = 0;\n    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n      var word = this.words[i] | 0;\n      this.words[i] = (carry << (26 - r)) | (word >>> r);\n      carry = word & mask;\n    }\n\n    // Push carried bits as a mask\n    if (maskedWords && carry !== 0) {\n      maskedWords.words[maskedWords.length++] = carry;\n    }\n\n    if (this.length === 0) {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushrn(bits, hint, extended);\n  };\n\n  // Shift-left\n  BN.prototype.shln = function shln (bits) {\n    return this.clone().ishln(bits);\n  };\n\n  BN.prototype.ushln = function ushln (bits) {\n    return this.clone().iushln(bits);\n  };\n\n  // Shift-right\n  BN.prototype.shrn = function shrn (bits) {\n    return this.clone().ishrn(bits);\n  };\n\n  BN.prototype.ushrn = function ushrn (bits) {\n    return this.clone().iushrn(bits);\n  };\n\n  // Test if n bit is set\n  BN.prototype.testn = function testn (bit) {\n    assert(typeof bit === 'number' && bit >= 0);\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) return false;\n\n    // Check bit and return\n    var w = this.words[s];\n\n    return !!(w & q);\n  };\n\n  // Return only lowers bits of number (in-place)\n  BN.prototype.imaskn = function imaskn (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n\n    assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n    if (this.length <= s) {\n      return this;\n    }\n\n    if (r !== 0) {\n      s++;\n    }\n    this.length = Math.min(s, this.length);\n\n    if (r !== 0) {\n      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n      this.words[this.length - 1] &= mask;\n    }\n\n    return this._strip();\n  };\n\n  // Return only lowers bits of number\n  BN.prototype.maskn = function maskn (bits) {\n    return this.clone().imaskn(bits);\n  };\n\n  // Add plain number `num` to `this`\n  BN.prototype.iaddn = function iaddn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.isubn(-num);\n\n    // Possible sign change\n    if (this.negative !== 0) {\n      if (this.length === 1 && (this.words[0] | 0) <= num) {\n        this.words[0] = num - (this.words[0] | 0);\n        this.negative = 0;\n        return this;\n      }\n\n      this.negative = 0;\n      this.isubn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    // Add without checks\n    return this._iaddn(num);\n  };\n\n  BN.prototype._iaddn = function _iaddn (num) {\n    this.words[0] += num;\n\n    // Carry\n    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n      this.words[i] -= 0x4000000;\n      if (i === this.length - 1) {\n        this.words[i + 1] = 1;\n      } else {\n        this.words[i + 1]++;\n      }\n    }\n    this.length = Math.max(this.length, i + 1);\n\n    return this;\n  };\n\n  // Subtract plain number `num` from `this`\n  BN.prototype.isubn = function isubn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.iaddn(-num);\n\n    if (this.negative !== 0) {\n      this.negative = 0;\n      this.iaddn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    this.words[0] -= num;\n\n    if (this.length === 1 && this.words[0] < 0) {\n      this.words[0] = -this.words[0];\n      this.negative = 1;\n    } else {\n      // Carry\n      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n        this.words[i] += 0x4000000;\n        this.words[i + 1] -= 1;\n      }\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.addn = function addn (num) {\n    return this.clone().iaddn(num);\n  };\n\n  BN.prototype.subn = function subn (num) {\n    return this.clone().isubn(num);\n  };\n\n  BN.prototype.iabs = function iabs () {\n    this.negative = 0;\n\n    return this;\n  };\n\n  BN.prototype.abs = function abs () {\n    return this.clone().iabs();\n  };\n\n  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n    var len = num.length + shift;\n    var i;\n\n    this._expand(len);\n\n    var w;\n    var carry = 0;\n    for (i = 0; i < num.length; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      var right = (num.words[i] | 0) * mul;\n      w -= right & 0x3ffffff;\n      carry = (w >> 26) - ((right / 0x4000000) | 0);\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n    for (; i < this.length - shift; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      carry = w >> 26;\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    if (carry === 0) return this._strip();\n\n    // Subtraction overflow\n    assert(carry === -1);\n    carry = 0;\n    for (i = 0; i < this.length; i++) {\n      w = -(this.words[i] | 0) + carry;\n      carry = w >> 26;\n      this.words[i] = w & 0x3ffffff;\n    }\n    this.negative = 1;\n\n    return this._strip();\n  };\n\n  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n    var shift = this.length - num.length;\n\n    var a = this.clone();\n    var b = num;\n\n    // Normalize\n    var bhi = b.words[b.length - 1] | 0;\n    var bhiBits = this._countBits(bhi);\n    shift = 26 - bhiBits;\n    if (shift !== 0) {\n      b = b.ushln(shift);\n      a.iushln(shift);\n      bhi = b.words[b.length - 1] | 0;\n    }\n\n    // Initialize quotient\n    var m = a.length - b.length;\n    var q;\n\n    if (mode !== 'mod') {\n      q = new BN(null);\n      q.length = m + 1;\n      q.words = new Array(q.length);\n      for (var i = 0; i < q.length; i++) {\n        q.words[i] = 0;\n      }\n    }\n\n    var diff = a.clone()._ishlnsubmul(b, 1, m);\n    if (diff.negative === 0) {\n      a = diff;\n      if (q) {\n        q.words[m] = 1;\n      }\n    }\n\n    for (var j = m - 1; j >= 0; j--) {\n      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n        (a.words[b.length + j - 1] | 0);\n\n      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n      // (0x7ffffff)\n      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n      a._ishlnsubmul(b, qj, j);\n      while (a.negative !== 0) {\n        qj--;\n        a.negative = 0;\n        a._ishlnsubmul(b, 1, j);\n        if (!a.isZero()) {\n          a.negative ^= 1;\n        }\n      }\n      if (q) {\n        q.words[j] = qj;\n      }\n    }\n    if (q) {\n      q._strip();\n    }\n    a._strip();\n\n    // Denormalize\n    if (mode !== 'div' && shift !== 0) {\n      a.iushrn(shift);\n    }\n\n    return {\n      div: q || null,\n      mod: a\n    };\n  };\n\n  // NOTE: 1) `mode` can be set to `mod` to request mod only,\n  //       to `div` to request div only, or be absent to\n  //       request both div & mod\n  //       2) `positive` is true if unsigned mod is requested\n  BN.prototype.divmod = function divmod (num, mode, positive) {\n    assert(!num.isZero());\n\n    if (this.isZero()) {\n      return {\n        div: new BN(0),\n        mod: new BN(0)\n      };\n    }\n\n    var div, mod, res;\n    if (this.negative !== 0 && num.negative === 0) {\n      res = this.neg().divmod(num, mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.iadd(num);\n        }\n      }\n\n      return {\n        div: div,\n        mod: mod\n      };\n    }\n\n    if (this.negative === 0 && num.negative !== 0) {\n      res = this.divmod(num.neg(), mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      return {\n        div: div,\n        mod: res.mod\n      };\n    }\n\n    if ((this.negative & num.negative) !== 0) {\n      res = this.neg().divmod(num.neg(), mode);\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.isub(num);\n        }\n      }\n\n      return {\n        div: res.div,\n        mod: mod\n      };\n    }\n\n    // Both numbers are positive at this point\n\n    // Strip both numbers to approximate shift value\n    if (num.length > this.length || this.cmp(num) < 0) {\n      return {\n        div: new BN(0),\n        mod: this\n      };\n    }\n\n    // Very short reduction\n    if (num.length === 1) {\n      if (mode === 'div') {\n        return {\n          div: this.divn(num.words[0]),\n          mod: null\n        };\n      }\n\n      if (mode === 'mod') {\n        return {\n          div: null,\n          mod: new BN(this.modrn(num.words[0]))\n        };\n      }\n\n      return {\n        div: this.divn(num.words[0]),\n        mod: new BN(this.modrn(num.words[0]))\n      };\n    }\n\n    return this._wordDiv(num, mode);\n  };\n\n  // Find `this` / `num`\n  BN.prototype.div = function div (num) {\n    return this.divmod(num, 'div', false).div;\n  };\n\n  // Find `this` % `num`\n  BN.prototype.mod = function mod (num) {\n    return this.divmod(num, 'mod', false).mod;\n  };\n\n  BN.prototype.umod = function umod (num) {\n    return this.divmod(num, 'mod', true).mod;\n  };\n\n  // Find Round(`this` / `num`)\n  BN.prototype.divRound = function divRound (num) {\n    var dm = this.divmod(num);\n\n    // Fast case - exact division\n    if (dm.mod.isZero()) return dm.div;\n\n    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n    var half = num.ushrn(1);\n    var r2 = num.andln(1);\n    var cmp = mod.cmp(half);\n\n    // Round down\n    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;\n\n    // Round up\n    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n  };\n\n  BN.prototype.modrn = function modrn (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(num <= 0x3ffffff);\n    var p = (1 << 26) % num;\n\n    var acc = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      acc = (p * acc + (this.words[i] | 0)) % num;\n    }\n\n    return isNegNum ? -acc : acc;\n  };\n\n  // WARNING: DEPRECATED\n  BN.prototype.modn = function modn (num) {\n    return this.modrn(num);\n  };\n\n  // In-place division by number\n  BN.prototype.idivn = function idivn (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(num <= 0x3ffffff);\n\n    var carry = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var w = (this.words[i] | 0) + carry * 0x4000000;\n      this.words[i] = (w / num) | 0;\n      carry = w % num;\n    }\n\n    this._strip();\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.divn = function divn (num) {\n    return this.clone().idivn(num);\n  };\n\n  BN.prototype.egcd = function egcd (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var x = this;\n    var y = p.clone();\n\n    if (x.negative !== 0) {\n      x = x.umod(p);\n    } else {\n      x = x.clone();\n    }\n\n    // A * x + B * y = x\n    var A = new BN(1);\n    var B = new BN(0);\n\n    // C * x + D * y = y\n    var C = new BN(0);\n    var D = new BN(1);\n\n    var g = 0;\n\n    while (x.isEven() && y.isEven()) {\n      x.iushrn(1);\n      y.iushrn(1);\n      ++g;\n    }\n\n    var yp = y.clone();\n    var xp = x.clone();\n\n    while (!x.isZero()) {\n      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        x.iushrn(i);\n        while (i-- > 0) {\n          if (A.isOdd() || B.isOdd()) {\n            A.iadd(yp);\n            B.isub(xp);\n          }\n\n          A.iushrn(1);\n          B.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        y.iushrn(j);\n        while (j-- > 0) {\n          if (C.isOdd() || D.isOdd()) {\n            C.iadd(yp);\n            D.isub(xp);\n          }\n\n          C.iushrn(1);\n          D.iushrn(1);\n        }\n      }\n\n      if (x.cmp(y) >= 0) {\n        x.isub(y);\n        A.isub(C);\n        B.isub(D);\n      } else {\n        y.isub(x);\n        C.isub(A);\n        D.isub(B);\n      }\n    }\n\n    return {\n      a: C,\n      b: D,\n      gcd: y.iushln(g)\n    };\n  };\n\n  // This is reduced incarnation of the binary EEA\n  // above, designated to invert members of the\n  // _prime_ fields F(p) at a maximal speed\n  BN.prototype._invmp = function _invmp (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var a = this;\n    var b = p.clone();\n\n    if (a.negative !== 0) {\n      a = a.umod(p);\n    } else {\n      a = a.clone();\n    }\n\n    var x1 = new BN(1);\n    var x2 = new BN(0);\n\n    var delta = b.clone();\n\n    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        a.iushrn(i);\n        while (i-- > 0) {\n          if (x1.isOdd()) {\n            x1.iadd(delta);\n          }\n\n          x1.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        b.iushrn(j);\n        while (j-- > 0) {\n          if (x2.isOdd()) {\n            x2.iadd(delta);\n          }\n\n          x2.iushrn(1);\n        }\n      }\n\n      if (a.cmp(b) >= 0) {\n        a.isub(b);\n        x1.isub(x2);\n      } else {\n        b.isub(a);\n        x2.isub(x1);\n      }\n    }\n\n    var res;\n    if (a.cmpn(1) === 0) {\n      res = x1;\n    } else {\n      res = x2;\n    }\n\n    if (res.cmpn(0) < 0) {\n      res.iadd(p);\n    }\n\n    return res;\n  };\n\n  BN.prototype.gcd = function gcd (num) {\n    if (this.isZero()) return num.abs();\n    if (num.isZero()) return this.abs();\n\n    var a = this.clone();\n    var b = num.clone();\n    a.negative = 0;\n    b.negative = 0;\n\n    // Remove common factor of two\n    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n      a.iushrn(1);\n      b.iushrn(1);\n    }\n\n    do {\n      while (a.isEven()) {\n        a.iushrn(1);\n      }\n      while (b.isEven()) {\n        b.iushrn(1);\n      }\n\n      var r = a.cmp(b);\n      if (r < 0) {\n        // Swap `a` and `b` to make `a` always bigger than `b`\n        var t = a;\n        a = b;\n        b = t;\n      } else if (r === 0 || b.cmpn(1) === 0) {\n        break;\n      }\n\n      a.isub(b);\n    } while (true);\n\n    return b.iushln(shift);\n  };\n\n  // Invert number in the field F(num)\n  BN.prototype.invm = function invm (num) {\n    return this.egcd(num).a.umod(num);\n  };\n\n  BN.prototype.isEven = function isEven () {\n    return (this.words[0] & 1) === 0;\n  };\n\n  BN.prototype.isOdd = function isOdd () {\n    return (this.words[0] & 1) === 1;\n  };\n\n  // And first word and num\n  BN.prototype.andln = function andln (num) {\n    return this.words[0] & num;\n  };\n\n  // Increment at the bit position in-line\n  BN.prototype.bincn = function bincn (bit) {\n    assert(typeof bit === 'number');\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) {\n      this._expand(s + 1);\n      this.words[s] |= q;\n      return this;\n    }\n\n    // Add bit and propagate, if needed\n    var carry = q;\n    for (var i = s; carry !== 0 && i < this.length; i++) {\n      var w = this.words[i] | 0;\n      w += carry;\n      carry = w >>> 26;\n      w &= 0x3ffffff;\n      this.words[i] = w;\n    }\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n    return this;\n  };\n\n  BN.prototype.isZero = function isZero () {\n    return this.length === 1 && this.words[0] === 0;\n  };\n\n  BN.prototype.cmpn = function cmpn (num) {\n    var negative = num < 0;\n\n    if (this.negative !== 0 && !negative) return -1;\n    if (this.negative === 0 && negative) return 1;\n\n    this._strip();\n\n    var res;\n    if (this.length > 1) {\n      res = 1;\n    } else {\n      if (negative) {\n        num = -num;\n      }\n\n      assert(num <= 0x3ffffff, 'Number is too big');\n\n      var w = this.words[0] | 0;\n      res = w === num ? 0 : w < num ? -1 : 1;\n    }\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Compare two numbers and return:\n  // 1 - if `this` > `num`\n  // 0 - if `this` == `num`\n  // -1 - if `this` < `num`\n  BN.prototype.cmp = function cmp (num) {\n    if (this.negative !== 0 && num.negative === 0) return -1;\n    if (this.negative === 0 && num.negative !== 0) return 1;\n\n    var res = this.ucmp(num);\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Unsigned comparison\n  BN.prototype.ucmp = function ucmp (num) {\n    // At this point both numbers have the same sign\n    if (this.length > num.length) return 1;\n    if (this.length < num.length) return -1;\n\n    var res = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var a = this.words[i] | 0;\n      var b = num.words[i] | 0;\n\n      if (a === b) continue;\n      if (a < b) {\n        res = -1;\n      } else if (a > b) {\n        res = 1;\n      }\n      break;\n    }\n    return res;\n  };\n\n  BN.prototype.gtn = function gtn (num) {\n    return this.cmpn(num) === 1;\n  };\n\n  BN.prototype.gt = function gt (num) {\n    return this.cmp(num) === 1;\n  };\n\n  BN.prototype.gten = function gten (num) {\n    return this.cmpn(num) >= 0;\n  };\n\n  BN.prototype.gte = function gte (num) {\n    return this.cmp(num) >= 0;\n  };\n\n  BN.prototype.ltn = function ltn (num) {\n    return this.cmpn(num) === -1;\n  };\n\n  BN.prototype.lt = function lt (num) {\n    return this.cmp(num) === -1;\n  };\n\n  BN.prototype.lten = function lten (num) {\n    return this.cmpn(num) <= 0;\n  };\n\n  BN.prototype.lte = function lte (num) {\n    return this.cmp(num) <= 0;\n  };\n\n  BN.prototype.eqn = function eqn (num) {\n    return this.cmpn(num) === 0;\n  };\n\n  BN.prototype.eq = function eq (num) {\n    return this.cmp(num) === 0;\n  };\n\n  //\n  // A reduce context, could be using montgomery or something better, depending\n  // on the `m` itself.\n  //\n  BN.red = function red (num) {\n    return new Red(num);\n  };\n\n  BN.prototype.toRed = function toRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    assert(this.negative === 0, 'red works only with positives');\n    return ctx.convertTo(this)._forceRed(ctx);\n  };\n\n  BN.prototype.fromRed = function fromRed () {\n    assert(this.red, 'fromRed works only with numbers in reduction context');\n    return this.red.convertFrom(this);\n  };\n\n  BN.prototype._forceRed = function _forceRed (ctx) {\n    this.red = ctx;\n    return this;\n  };\n\n  BN.prototype.forceRed = function forceRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    return this._forceRed(ctx);\n  };\n\n  BN.prototype.redAdd = function redAdd (num) {\n    assert(this.red, 'redAdd works only with red numbers');\n    return this.red.add(this, num);\n  };\n\n  BN.prototype.redIAdd = function redIAdd (num) {\n    assert(this.red, 'redIAdd works only with red numbers');\n    return this.red.iadd(this, num);\n  };\n\n  BN.prototype.redSub = function redSub (num) {\n    assert(this.red, 'redSub works only with red numbers');\n    return this.red.sub(this, num);\n  };\n\n  BN.prototype.redISub = function redISub (num) {\n    assert(this.red, 'redISub works only with red numbers');\n    return this.red.isub(this, num);\n  };\n\n  BN.prototype.redShl = function redShl (num) {\n    assert(this.red, 'redShl works only with red numbers');\n    return this.red.shl(this, num);\n  };\n\n  BN.prototype.redMul = function redMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.mul(this, num);\n  };\n\n  BN.prototype.redIMul = function redIMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.imul(this, num);\n  };\n\n  BN.prototype.redSqr = function redSqr () {\n    assert(this.red, 'redSqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqr(this);\n  };\n\n  BN.prototype.redISqr = function redISqr () {\n    assert(this.red, 'redISqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.isqr(this);\n  };\n\n  // Square root over p\n  BN.prototype.redSqrt = function redSqrt () {\n    assert(this.red, 'redSqrt works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqrt(this);\n  };\n\n  BN.prototype.redInvm = function redInvm () {\n    assert(this.red, 'redInvm works only with red numbers');\n    this.red._verify1(this);\n    return this.red.invm(this);\n  };\n\n  // Return negative clone of `this` % `red modulo`\n  BN.prototype.redNeg = function redNeg () {\n    assert(this.red, 'redNeg works only with red numbers');\n    this.red._verify1(this);\n    return this.red.neg(this);\n  };\n\n  BN.prototype.redPow = function redPow (num) {\n    assert(this.red && !num.red, 'redPow(normalNum)');\n    this.red._verify1(this);\n    return this.red.pow(this, num);\n  };\n\n  // Prime numbers with efficient reduction\n  var primes = {\n    k256: null,\n    p224: null,\n    p192: null,\n    p25519: null\n  };\n\n  // Pseudo-Mersenne prime\n  function MPrime (name, p) {\n    // P = 2 ^ N - K\n    this.name = name;\n    this.p = new BN(p, 16);\n    this.n = this.p.bitLength();\n    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n    this.tmp = this._tmp();\n  }\n\n  MPrime.prototype._tmp = function _tmp () {\n    var tmp = new BN(null);\n    tmp.words = new Array(Math.ceil(this.n / 13));\n    return tmp;\n  };\n\n  MPrime.prototype.ireduce = function ireduce (num) {\n    // Assumes that `num` is less than `P^2`\n    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n    var r = num;\n    var rlen;\n\n    do {\n      this.split(r, this.tmp);\n      r = this.imulK(r);\n      r = r.iadd(this.tmp);\n      rlen = r.bitLength();\n    } while (rlen > this.n);\n\n    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n    if (cmp === 0) {\n      r.words[0] = 0;\n      r.length = 1;\n    } else if (cmp > 0) {\n      r.isub(this.p);\n    } else {\n      if (r.strip !== undefined) {\n        // r is a BN v4 instance\n        r.strip();\n      } else {\n        // r is a BN v5 instance\n        r._strip();\n      }\n    }\n\n    return r;\n  };\n\n  MPrime.prototype.split = function split (input, out) {\n    input.iushrn(this.n, 0, out);\n  };\n\n  MPrime.prototype.imulK = function imulK (num) {\n    return num.imul(this.k);\n  };\n\n  function K256 () {\n    MPrime.call(\n      this,\n      'k256',\n      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n  }\n  inherits(K256, MPrime);\n\n  K256.prototype.split = function split (input, output) {\n    // 256 = 9 * 26 + 22\n    var mask = 0x3fffff;\n\n    var outLen = Math.min(input.length, 9);\n    for (var i = 0; i < outLen; i++) {\n      output.words[i] = input.words[i];\n    }\n    output.length = outLen;\n\n    if (input.length <= 9) {\n      input.words[0] = 0;\n      input.length = 1;\n      return;\n    }\n\n    // Shift by 9 limbs\n    var prev = input.words[9];\n    output.words[output.length++] = prev & mask;\n\n    for (i = 10; i < input.length; i++) {\n      var next = input.words[i] | 0;\n      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n      prev = next;\n    }\n    prev >>>= 22;\n    input.words[i - 10] = prev;\n    if (prev === 0 && input.length > 10) {\n      input.length -= 10;\n    } else {\n      input.length -= 9;\n    }\n  };\n\n  K256.prototype.imulK = function imulK (num) {\n    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n    num.words[num.length] = 0;\n    num.words[num.length + 1] = 0;\n    num.length += 2;\n\n    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n    var lo = 0;\n    for (var i = 0; i < num.length; i++) {\n      var w = num.words[i] | 0;\n      lo += w * 0x3d1;\n      num.words[i] = lo & 0x3ffffff;\n      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n    }\n\n    // Fast length reduction\n    if (num.words[num.length - 1] === 0) {\n      num.length--;\n      if (num.words[num.length - 1] === 0) {\n        num.length--;\n      }\n    }\n    return num;\n  };\n\n  function P224 () {\n    MPrime.call(\n      this,\n      'p224',\n      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n  }\n  inherits(P224, MPrime);\n\n  function P192 () {\n    MPrime.call(\n      this,\n      'p192',\n      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n  }\n  inherits(P192, MPrime);\n\n  function P25519 () {\n    // 2 ^ 255 - 19\n    MPrime.call(\n      this,\n      '25519',\n      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n  }\n  inherits(P25519, MPrime);\n\n  P25519.prototype.imulK = function imulK (num) {\n    // K = 0x13\n    var carry = 0;\n    for (var i = 0; i < num.length; i++) {\n      var hi = (num.words[i] | 0) * 0x13 + carry;\n      var lo = hi & 0x3ffffff;\n      hi >>>= 26;\n\n      num.words[i] = lo;\n      carry = hi;\n    }\n    if (carry !== 0) {\n      num.words[num.length++] = carry;\n    }\n    return num;\n  };\n\n  // Exported mostly for testing purposes, use plain name instead\n  BN._prime = function prime (name) {\n    // Cached version of prime\n    if (primes[name]) return primes[name];\n\n    var prime;\n    if (name === 'k256') {\n      prime = new K256();\n    } else if (name === 'p224') {\n      prime = new P224();\n    } else if (name === 'p192') {\n      prime = new P192();\n    } else if (name === 'p25519') {\n      prime = new P25519();\n    } else {\n      throw new Error('Unknown prime ' + name);\n    }\n    primes[name] = prime;\n\n    return prime;\n  };\n\n  //\n  // Base reduction engine\n  //\n  function Red (m) {\n    if (typeof m === 'string') {\n      var prime = BN._prime(m);\n      this.m = prime.p;\n      this.prime = prime;\n    } else {\n      assert(m.gtn(1), 'modulus must be greater than 1');\n      this.m = m;\n      this.prime = null;\n    }\n  }\n\n  Red.prototype._verify1 = function _verify1 (a) {\n    assert(a.negative === 0, 'red works only with positives');\n    assert(a.red, 'red works only with red numbers');\n  };\n\n  Red.prototype._verify2 = function _verify2 (a, b) {\n    assert((a.negative | b.negative) === 0, 'red works only with positives');\n    assert(a.red && a.red === b.red,\n      'red works only with red numbers');\n  };\n\n  Red.prototype.imod = function imod (a) {\n    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n\n    move(a, a.umod(this.m)._forceRed(this));\n    return a;\n  };\n\n  Red.prototype.neg = function neg (a) {\n    if (a.isZero()) {\n      return a.clone();\n    }\n\n    return this.m.sub(a)._forceRed(this);\n  };\n\n  Red.prototype.add = function add (a, b) {\n    this._verify2(a, b);\n\n    var res = a.add(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.iadd = function iadd (a, b) {\n    this._verify2(a, b);\n\n    var res = a.iadd(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.sub = function sub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.sub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.isub = function isub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.isub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.shl = function shl (a, num) {\n    this._verify1(a);\n    return this.imod(a.ushln(num));\n  };\n\n  Red.prototype.imul = function imul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.imul(b));\n  };\n\n  Red.prototype.mul = function mul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.mul(b));\n  };\n\n  Red.prototype.isqr = function isqr (a) {\n    return this.imul(a, a.clone());\n  };\n\n  Red.prototype.sqr = function sqr (a) {\n    return this.mul(a, a);\n  };\n\n  Red.prototype.sqrt = function sqrt (a) {\n    if (a.isZero()) return a.clone();\n\n    var mod3 = this.m.andln(3);\n    assert(mod3 % 2 === 1);\n\n    // Fast case\n    if (mod3 === 3) {\n      var pow = this.m.add(new BN(1)).iushrn(2);\n      return this.pow(a, pow);\n    }\n\n    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n    //\n    // Find Q and S, that Q * 2 ^ S = (P - 1)\n    var q = this.m.subn(1);\n    var s = 0;\n    while (!q.isZero() && q.andln(1) === 0) {\n      s++;\n      q.iushrn(1);\n    }\n    assert(!q.isZero());\n\n    var one = new BN(1).toRed(this);\n    var nOne = one.redNeg();\n\n    // Find quadratic non-residue\n    // NOTE: Max is such because of generalized Riemann hypothesis.\n    var lpow = this.m.subn(1).iushrn(1);\n    var z = this.m.bitLength();\n    z = new BN(2 * z * z).toRed(this);\n\n    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n      z.redIAdd(nOne);\n    }\n\n    var c = this.pow(z, q);\n    var r = this.pow(a, q.addn(1).iushrn(1));\n    var t = this.pow(a, q);\n    var m = s;\n    while (t.cmp(one) !== 0) {\n      var tmp = t;\n      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n        tmp = tmp.redSqr();\n      }\n      assert(i < m);\n      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n      r = r.redMul(b);\n      c = b.redSqr();\n      t = t.redMul(c);\n      m = i;\n    }\n\n    return r;\n  };\n\n  Red.prototype.invm = function invm (a) {\n    var inv = a._invmp(this.m);\n    if (inv.negative !== 0) {\n      inv.negative = 0;\n      return this.imod(inv).redNeg();\n    } else {\n      return this.imod(inv);\n    }\n  };\n\n  Red.prototype.pow = function pow (a, num) {\n    if (num.isZero()) return new BN(1).toRed(this);\n    if (num.cmpn(1) === 0) return a.clone();\n\n    var windowSize = 4;\n    var wnd = new Array(1 << windowSize);\n    wnd[0] = new BN(1).toRed(this);\n    wnd[1] = a;\n    for (var i = 2; i < wnd.length; i++) {\n      wnd[i] = this.mul(wnd[i - 1], a);\n    }\n\n    var res = wnd[0];\n    var current = 0;\n    var currentLen = 0;\n    var start = num.bitLength() % 26;\n    if (start === 0) {\n      start = 26;\n    }\n\n    for (i = num.length - 1; i >= 0; i--) {\n      var word = num.words[i];\n      for (var j = start - 1; j >= 0; j--) {\n        var bit = (word >> j) & 1;\n        if (res !== wnd[0]) {\n          res = this.sqr(res);\n        }\n\n        if (bit === 0 && current === 0) {\n          currentLen = 0;\n          continue;\n        }\n\n        current <<= 1;\n        current |= bit;\n        currentLen++;\n        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n        res = this.mul(res, wnd[current]);\n        currentLen = 0;\n        current = 0;\n      }\n      start = 26;\n    }\n\n    return res;\n  };\n\n  Red.prototype.convertTo = function convertTo (num) {\n    var r = num.umod(this.m);\n\n    return r === num ? r.clone() : r;\n  };\n\n  Red.prototype.convertFrom = function convertFrom (num) {\n    var res = num.clone();\n    res.red = null;\n    return res;\n  };\n\n  //\n  // Montgomery method engine\n  //\n\n  BN.mont = function mont (num) {\n    return new Mont(num);\n  };\n\n  function Mont (m) {\n    Red.call(this, m);\n\n    this.shift = this.m.bitLength();\n    if (this.shift % 26 !== 0) {\n      this.shift += 26 - (this.shift % 26);\n    }\n\n    this.r = new BN(1).iushln(this.shift);\n    this.r2 = this.imod(this.r.sqr());\n    this.rinv = this.r._invmp(this.m);\n\n    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n    this.minv = this.minv.umod(this.r);\n    this.minv = this.r.sub(this.minv);\n  }\n  inherits(Mont, Red);\n\n  Mont.prototype.convertTo = function convertTo (num) {\n    return this.imod(num.ushln(this.shift));\n  };\n\n  Mont.prototype.convertFrom = function convertFrom (num) {\n    var r = this.imod(num.mul(this.rinv));\n    r.red = null;\n    return r;\n  };\n\n  Mont.prototype.imul = function imul (a, b) {\n    if (a.isZero() || b.isZero()) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    var t = a.imul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.mul = function mul (a, b) {\n    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n    var t = a.mul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.invm = function invm (a) {\n    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n    var res = this.imod(a._invmp(this.m).mul(this.r2));\n    return res._forceRed(this);\n  };\n})( false || module, this);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack://Fabric/./node_modules/browserify-sign/node_modules/bn.js/lib/bn.js?");
./assets/fabric.min.js:eval("/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = __webpack_require__(/*! util */ 6);\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = __webpack_require__(/*! ./internal/streams/buffer_list */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/buffer_list.js\");\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/state.js\"),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = __webpack_require__(/*! ../errors */ \"./node_modules/browserify-sign/node_modules/readable-stream/errors-browser.js\").codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Readable, Stream);\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_duplex.js\");\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n  this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_duplex.js\");\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n  var p = this._readableState.buffer.head;\n  var content = '';\n\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n\n  this._readableState.buffer.clear();\n\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n}; // Don't raise the hwm > 1GB\n\n\nvar MAX_HWM = 0x40000000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = __webpack_require__(/*! ./internal/streams/async_iterator */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/async_iterator.js\");\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = __webpack_require__(/*! ./internal/streams/from */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/from-browser.js\");\n    }\n\n    return from(Readable, iterable, opts);\n  };\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://Fabric/./node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_readable.js?");
./assets/fabric.min.js:eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\nmodule.exports = Transform;\n\nvar _require$codes = __webpack_require__(/*! ../errors */ \"./node_modules/browserify-sign/node_modules/readable-stream/errors-browser.js\").codes,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\n\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  }; // start out asking for a readable event once data is transformed.\n\n  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  } // When the writable side finishes, then flush out anything remaining.\n\n\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n}; // This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\n\n\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n}; // Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\n\n\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}\n\n//# sourceURL=webpack://Fabric/./node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_transform.js?");
./assets/fabric.min.js:eval("/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\nmodule.exports = Writable;\n/* <replacement> */\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n} // It seems a linked list but it is not\n// there will be only 2 of these for each stream\n\n\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\n\n\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n/*<replacement>*/\n\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \"./node_modules/util-deprecate/browser.js\")\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/state.js\"),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = __webpack_require__(/*! ../errors */ \"./node_modules/browserify-sign/node_modules/readable-stream/errors-browser.js\").codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_duplex.js\");\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\n\n  this.finalCalled = false; // drain event flag.\n\n  this.needDrain = false; // at the start of calling end()\n\n  this.ending = false; // when end() has been called, and returned\n\n  this.ended = false; // when 'finish' is emitted\n\n  this.finished = false; // has it been destroyed\n\n  this.destroyed = false; // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n\n  this.length = 0; // a flag to see when we're in the middle of a write.\n\n  this.writing = false; // when true all writes will be buffered until .uncork() call\n\n  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n\n  this.sync = true; // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n  this.writecb = null; // the amount that is being written when _write is called.\n\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n\n  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n\n  this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\n\n  this.autoDestroy = !!options.autoDestroy; // count buffered requests\n\n  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})(); // Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\n\n\nvar realHasInstance;\n\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_duplex.js\"); // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex); // legacy.\n\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n} // Otherwise people can pipe Writable streams, which is just wrong.\n\n\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\n\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n} // Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\n\n\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n\n  return true;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n}); // if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\n\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er); // this can emit finish, and it will always happen\n    // after error\n\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er); // this can emit finish, but finish must\n    // always follow error\n\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n} // Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\n\n\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n} // if there's something in the buffer waiting, then process it\n\n\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  } // ignore unnecessary end() calls.\n\n\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n\n  if (need) {\n    prefinish(stream, state);\n\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  } // reuse the free corkReq.\n\n\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\n\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://Fabric/./node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_writable.js?");
./assets/fabric.min.js:eval("\n\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\nfunction Cipher(options) {\n  this.options = options;\n\n  this.type = this.options.type;\n  this.blockSize = 8;\n  this._init();\n\n  this.buffer = new Array(this.blockSize);\n  this.bufferOff = 0;\n}\nmodule.exports = Cipher;\n\nCipher.prototype._init = function _init() {\n  // Might be overrided\n};\n\nCipher.prototype.update = function update(data) {\n  if (data.length === 0)\n    return [];\n\n  if (this.type === 'decrypt')\n    return this._updateDecrypt(data);\n  else\n    return this._updateEncrypt(data);\n};\n\nCipher.prototype._buffer = function _buffer(data, off) {\n  // Append data to buffer\n  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);\n  for (var i = 0; i < min; i++)\n    this.buffer[this.bufferOff + i] = data[off + i];\n  this.bufferOff += min;\n\n  // Shift next\n  return min;\n};\n\nCipher.prototype._flushBuffer = function _flushBuffer(out, off) {\n  this._update(this.buffer, 0, out, off);\n  this.bufferOff = 0;\n  return this.blockSize;\n};\n\nCipher.prototype._updateEncrypt = function _updateEncrypt(data) {\n  var inputOff = 0;\n  var outputOff = 0;\n\n  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;\n  var out = new Array(count * this.blockSize);\n\n  if (this.bufferOff !== 0) {\n    inputOff += this._buffer(data, inputOff);\n\n    if (this.bufferOff === this.buffer.length)\n      outputOff += this._flushBuffer(out, outputOff);\n  }\n\n  // Write blocks\n  var max = data.length - ((data.length - inputOff) % this.blockSize);\n  for (; inputOff < max; inputOff += this.blockSize) {\n    this._update(data, inputOff, out, outputOff);\n    outputOff += this.blockSize;\n  }\n\n  // Queue rest\n  for (; inputOff < data.length; inputOff++, this.bufferOff++)\n    this.buffer[this.bufferOff] = data[inputOff];\n\n  return out;\n};\n\nCipher.prototype._updateDecrypt = function _updateDecrypt(data) {\n  var inputOff = 0;\n  var outputOff = 0;\n\n  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;\n  var out = new Array(count * this.blockSize);\n\n  // TODO(indutny): optimize it, this is far from optimal\n  for (; count > 0; count--) {\n    inputOff += this._buffer(data, inputOff);\n    outputOff += this._flushBuffer(out, outputOff);\n  }\n\n  // Buffer rest of the input\n  inputOff += this._buffer(data, inputOff);\n\n  return out;\n};\n\nCipher.prototype.final = function final(buffer) {\n  var first;\n  if (buffer)\n    first = this.update(buffer);\n\n  var last;\n  if (this.type === 'encrypt')\n    last = this._finalEncrypt();\n  else\n    last = this._finalDecrypt();\n\n  if (first)\n    return first.concat(last);\n  else\n    return last;\n};\n\nCipher.prototype._pad = function _pad(buffer, off) {\n  if (off === 0)\n    return false;\n\n  while (off < buffer.length)\n    buffer[off++] = 0;\n\n  return true;\n};\n\nCipher.prototype._finalEncrypt = function _finalEncrypt() {\n  if (!this._pad(this.buffer, this.bufferOff))\n    return [];\n\n  var out = new Array(this.blockSize);\n  this._update(this.buffer, 0, out, 0);\n  return out;\n};\n\nCipher.prototype._unpad = function _unpad(buffer) {\n  return buffer;\n};\n\nCipher.prototype._finalDecrypt = function _finalDecrypt() {\n  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');\n  var out = new Array(this.blockSize);\n  this._flushBuffer(out, 0);\n\n  return this._unpad(out);\n};\n\n\n//# sourceURL=webpack://Fabric/./node_modules/des.js/lib/des/cipher.js?");
./assets/fabric.min.js:eval("/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = __webpack_require__(/*! util */ 0);\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = __webpack_require__(/*! ./internal/streams/buffer_list */ \"./node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/buffer_list.js\");\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"./node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/state.js\"),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = __webpack_require__(/*! ../errors */ \"./node_modules/hash-base/node_modules/readable-stream/errors-browser.js\").codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Readable, Stream);\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/hash-base/node_modules/readable-stream/lib/_stream_duplex.js\");\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n  this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/hash-base/node_modules/readable-stream/lib/_stream_duplex.js\");\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n  var p = this._readableState.buffer.head;\n  var content = '';\n\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n\n  this._readableState.buffer.clear();\n\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n}; // Don't raise the hwm > 1GB\n\n\nvar MAX_HWM = 0x40000000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = __webpack_require__(/*! ./internal/streams/async_iterator */ \"./node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/async_iterator.js\");\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = __webpack_require__(/*! ./internal/streams/from */ \"./node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/from-browser.js\");\n    }\n\n    return from(Readable, iterable, opts);\n  };\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://Fabric/./node_modules/hash-base/node_modules/readable-stream/lib/_stream_readable.js?");
./assets/fabric.min.js:eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\nmodule.exports = Transform;\n\nvar _require$codes = __webpack_require__(/*! ../errors */ \"./node_modules/hash-base/node_modules/readable-stream/errors-browser.js\").codes,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\n\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/hash-base/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  }; // start out asking for a readable event once data is transformed.\n\n  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  } // When the writable side finishes, then flush out anything remaining.\n\n\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n}; // This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\n\n\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n}; // Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\n\n\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}\n\n//# sourceURL=webpack://Fabric/./node_modules/hash-base/node_modules/readable-stream/lib/_stream_transform.js?");
./assets/fabric.min.js:eval("/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\nmodule.exports = Writable;\n/* <replacement> */\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n} // It seems a linked list but it is not\n// there will be only 2 of these for each stream\n\n\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\n\n\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n/*<replacement>*/\n\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \"./node_modules/util-deprecate/browser.js\")\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"./node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/state.js\"),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = __webpack_require__(/*! ../errors */ \"./node_modules/hash-base/node_modules/readable-stream/errors-browser.js\").codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/hash-base/node_modules/readable-stream/lib/_stream_duplex.js\");\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\n\n  this.finalCalled = false; // drain event flag.\n\n  this.needDrain = false; // at the start of calling end()\n\n  this.ending = false; // when end() has been called, and returned\n\n  this.ended = false; // when 'finish' is emitted\n\n  this.finished = false; // has it been destroyed\n\n  this.destroyed = false; // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n\n  this.length = 0; // a flag to see when we're in the middle of a write.\n\n  this.writing = false; // when true all writes will be buffered until .uncork() call\n\n  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n\n  this.sync = true; // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n  this.writecb = null; // the amount that is being written when _write is called.\n\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n\n  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n\n  this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\n\n  this.autoDestroy = !!options.autoDestroy; // count buffered requests\n\n  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})(); // Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\n\n\nvar realHasInstance;\n\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/hash-base/node_modules/readable-stream/lib/_stream_duplex.js\"); // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex); // legacy.\n\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n} // Otherwise people can pipe Writable streams, which is just wrong.\n\n\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\n\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n} // Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\n\n\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n\n  return true;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n}); // if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\n\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er); // this can emit finish, and it will always happen\n    // after error\n\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er); // this can emit finish, but finish must\n    // always follow error\n\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n} // Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\n\n\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n} // if there's something in the buffer waiting, then process it\n\n\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  } // ignore unnecessary end() calls.\n\n\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n\n  if (need) {\n    prefinish(stream, state);\n\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  } // reuse the free corkReq.\n\n\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\n\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://Fabric/./node_modules/hash-base/node_modules/readable-stream/lib/_stream_writable.js?");
./assets/fabric.min.js:eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nexports.__esModule = true;\nvar reverse = __webpack_require__(/*! buffer-reverse */ \"./node_modules/buffer-reverse/index.js\");\nvar CryptoJS = __webpack_require__(/*! crypto-js */ \"./node_modules/crypto-js/index.js\");\nvar treeify = __webpack_require__(/*! treeify */ \"./node_modules/treeify/treeify.js\");\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */\nvar MerkleTree = /** @class */ (function () {\n    /**\n     * @desc Constructs a Merkle Tree.\n     * All nodes and leaves are stored as Buffers.\n     * Lonely leaf nodes are promoted to the next level up without being hashed again.\n     * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.\n     * @param {Function} hashAlgorithm - Algorithm used for hashing leaves and nodes\n     * @param {Object} options - Additional options\n     * @example\n     *```js\n     *const MerkleTree = require('merkletreejs')\n     *const crypto = require('crypto')\n     *\n     *function sha256(data) {\n     *  // returns Buffer\n     *  return crypto.createHash('sha256').update(data).digest()\n     *}\n     *\n     *const leaves = ['a', 'b', 'c'].map(x => keccak(x))\n     *\n     *const tree = new MerkleTree(leaves, sha256)\n     *```\n     */\n    function MerkleTree(leaves, hashAlgorithm, options) {\n        if (options === void 0) { options = {}; }\n        this.isBitcoinTree = !!options.isBitcoinTree;\n        this.hashLeaves = !!options.hashLeaves;\n        this.sortLeaves = !!options.sortLeaves;\n        this.sortPairs = !!options.sortPairs;\n        this.sort = !!options.sort;\n        if (this.sort) {\n            this.sortLeaves = true;\n            this.sortPairs = true;\n        }\n        this.duplicateOdd = !!options.duplicateOdd;\n        this.hashAlgo = bufferifyFn(hashAlgorithm);\n        if (this.hashLeaves) {\n            leaves = leaves.map(this.hashAlgo);\n        }\n        this.leaves = leaves.map(bufferify);\n        if (this.sortLeaves) {\n            this.leaves = this.leaves.sort(Buffer.compare);\n        }\n        this.layers = [this.leaves];\n        this.createHashes(this.leaves);\n    }\n    // TODO: documentation\n    MerkleTree.prototype.createHashes = function (nodes) {\n        while (nodes.length > 1) {\n            var layerIndex = this.layers.length;\n            this.layers.push([]);\n            for (var i = 0; i < nodes.length; i += 2) {\n                if (i + 1 === nodes.length) {\n                    if (nodes.length % 2 === 1) {\n                        var data_1 = nodes[nodes.length - 1];\n                        var hash_1 = data_1;\n                        // is bitcoin tree\n                        if (this.isBitcoinTree) {\n                            // Bitcoin method of duplicating the odd ending nodes\n                            data_1 = Buffer.concat([reverse(data_1), reverse(data_1)]);\n                            hash_1 = this.hashAlgo(data_1);\n                            hash_1 = reverse(this.hashAlgo(hash_1));\n                            this.layers[layerIndex].push(hash_1);\n                            continue;\n                        }\n                        else {\n                            if (!this.duplicateOdd) {\n                                this.layers[layerIndex].push(nodes[i]);\n                                continue;\n                            }\n                        }\n                    }\n                }\n                var left = nodes[i];\n                var right = i + 1 == nodes.length ? left : nodes[i + 1];\n                var data = null;\n                var combined = null;\n                if (this.isBitcoinTree) {\n                    combined = [reverse(left), reverse(right)];\n                }\n                else {\n                    combined = [left, right];\n                }\n                if (this.sortPairs) {\n                    combined.sort(Buffer.compare);\n                }\n                data = Buffer.concat(combined);\n                var hash = this.hashAlgo(data);\n                // double hash if bitcoin tree\n                if (this.isBitcoinTree) {\n                    hash = reverse(this.hashAlgo(hash));\n                }\n                this.layers[layerIndex].push(hash);\n            }\n            nodes = this.layers[layerIndex];\n        }\n    };\n    /**\n     * getLeaves\n     * @desc Returns array of leaves of Merkle Tree.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const leaves = tree.getLeaves()\n     *```\n     */\n    MerkleTree.prototype.getLeaves = function () {\n        return this.leaves;\n    };\n    /**\n     * getLayers\n     * @desc Returns array of all layers of Merkle Tree, including leaves and root.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const layers = tree.getLayers()\n     *```\n     */\n    MerkleTree.prototype.getLayers = function () {\n        return this.layers;\n    };\n    /**\n     * getRoot\n     * @desc Returns the Merkle root hash as a Buffer.\n     * @return {Buffer}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *```\n     */\n    MerkleTree.prototype.getRoot = function () {\n        return this.layers[this.layers.length - 1][0] || Buffer.from([]);\n    };\n    // TODO: documentation\n    MerkleTree.prototype.getHexRoot = function () {\n        return bufferToHex(this.getRoot());\n    };\n    /**\n     * getProof\n     * @desc Returns the proof for a target leaf.\n     * @param {Buffer} leaf - Target leaf\n     * @param {Number} [index] - Target leaf index in leaves array.\n     * Use if there are leaves containing duplicate data in order to distinguish it.\n     * @return {Object[]} - Array of objects containing a position property of type string\n     * with values of 'left' or 'right' and a data property of type Buffer.\n     *@example\n     * ```js\n     *const proof = tree.getProof(leaves[2])\n     *```\n     *\n     * @example\n     *```js\n     *const leaves = ['a', 'b', 'a'].map(x => keccak(x))\n     *const tree = new MerkleTree(leaves, keccak)\n     *const proof = tree.getProof(leaves[2], 2)\n     *```\n     */\n    MerkleTree.prototype.getProof = function (leaf, index) {\n        leaf = bufferify(leaf);\n        var proof = [];\n        if (typeof index !== 'number') {\n            index = -1;\n            for (var i = 0; i < this.leaves.length; i++) {\n                if (Buffer.compare(leaf, this.leaves[i]) === 0) {\n                    index = i;\n                }\n            }\n        }\n        if (index <= -1) {\n            return [];\n        }\n        if (this.isBitcoinTree && index === (this.leaves.length - 1)) {\n            // Proof Generation for Bitcoin Trees\n            for (var i = 0; i < this.layers.length - 1; i++) {\n                var layer = this.layers[i];\n                var isRightNode = index % 2;\n                var pairIndex = (isRightNode ? index - 1 : index);\n                if (pairIndex < layer.length) {\n                    proof.push({\n                        data: layer[pairIndex]\n                    });\n                }\n                // set index to parent index\n                index = (index / 2) | 0;\n            }\n            return proof;\n        }\n        else {\n            // Proof Generation for Non-Bitcoin Trees\n            for (var i = 0; i < this.layers.length; i++) {\n                var layer = this.layers[i];\n                var isRightNode = index % 2;\n                var pairIndex = (isRightNode ? index - 1 : index + 1);\n                if (pairIndex < layer.length) {\n                    proof.push({\n                        position: isRightNode ? 'left' : 'right',\n                        data: layer[pairIndex]\n                    });\n                }\n                // set index to parent index\n                index = (index / 2) | 0;\n            }\n            return proof;\n        }\n    };\n    // TODO: documentation\n    MerkleTree.prototype.getHexProof = function (leaf, index) {\n        return this.getProof(leaf, index).map(function (x) { return bufferToHex(x.data); });\n    };\n    /**\n     * verify\n     * @desc Returns true if the proof path (array of hashes) can connect the target node\n     * to the Merkle root.\n     * @param {Object[]} proof - Array of proof objects that should connect\n     * target node to Merkle root.\n     * @param {Buffer} targetNode - Target node Buffer\n     * @param {Buffer} root - Merkle root Buffer\n     * @return {Boolean}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *const proof = tree.getProof(leaves[2])\n     *const verified = tree.verify(proof, leaves[2], root)\n     *```\n     */\n    MerkleTree.prototype.verify = function (proof, targetNode, root) {\n        var hash = bufferify(targetNode);\n        root = bufferify(root);\n        if (!Array.isArray(proof) ||\n            !proof.length ||\n            !targetNode ||\n            !root) {\n            return false;\n        }\n        for (var i = 0; i < proof.length; i++) {\n            var node = proof[i];\n            var data = null;\n            var isLeftNode = null;\n            // NOTE: case for when proof is hex values only\n            if (typeof node === 'string') {\n                data = bufferify(node);\n                isLeftNode = true;\n            }\n            else {\n                data = node.data;\n                isLeftNode = (node.position === 'left');\n            }\n            var buffers = [];\n            if (this.isBitcoinTree) {\n                buffers.push(reverse(hash));\n                buffers[isLeftNode ? 'unshift' : 'push'](reverse(data));\n                hash = this.hashAlgo(Buffer.concat(buffers));\n                hash = reverse(this.hashAlgo(hash));\n            }\n            else {\n                if (this.sortPairs) {\n                    if (Buffer.compare(hash, data) === -1) {\n                        buffers.push(hash, data);\n                        hash = this.hashAlgo(Buffer.concat(buffers));\n                    }\n                    else {\n                        buffers.push(data, hash);\n                        hash = this.hashAlgo(Buffer.concat(buffers));\n                    }\n                }\n                else {\n                    buffers.push(hash);\n                    buffers[isLeftNode ? 'unshift' : 'push'](data);\n                    hash = this.hashAlgo(Buffer.concat(buffers));\n                }\n            }\n        }\n        return Buffer.compare(hash, root) === 0;\n    };\n    // TODO: documentation\n    MerkleTree.prototype.getLayersAsObject = function () {\n        var _a;\n        var layers = this.getLayers().map(function (x) { return x.map(function (x) { return x.toString('hex'); }); });\n        var objs = [];\n        for (var i = 0; i < layers.length; i++) {\n            var arr = [];\n            for (var j = 0; j < layers[i].length; j++) {\n                var obj = (_a = {}, _a[layers[i][j]] = null, _a);\n                if (objs.length) {\n                    obj[layers[i][j]] = {};\n                    var a = objs.shift();\n                    var akey = Object.keys(a)[0];\n                    obj[layers[i][j]][akey] = a[akey];\n                    if (objs.length) {\n                        var b = objs.shift();\n                        var bkey = Object.keys(b)[0];\n                        obj[layers[i][j]][bkey] = b[bkey];\n                    }\n                }\n                arr.push(obj);\n            }\n            objs.push.apply(objs, arr);\n        }\n        return objs[0];\n    };\n    // TODO: documentation\n    MerkleTree.prototype.print = function () {\n        MerkleTree.print(this);\n    };\n    // TODO: documentation\n    MerkleTree.prototype.toTreeString = function () {\n        var obj = this.getLayersAsObject();\n        return treeify.asTree(obj, true);\n    };\n    // TODO: documentation\n    MerkleTree.prototype.toString = function () {\n        return this.toTreeString();\n    };\n    // TODO: documentation\n    MerkleTree.bufferify = function (x) {\n        return bufferify(x);\n    };\n    // TODO: documentation\n    MerkleTree.print = function (tree) {\n        console.log(tree.toString());\n    };\n    return MerkleTree;\n}());\nexports.MerkleTree = MerkleTree;\nfunction bufferToHex(value) {\n    return '0x' + value.toString('hex');\n}\nfunction bufferify(x) {\n    if (!Buffer.isBuffer(x)) {\n        // crypto-js support\n        if (typeof x === 'object' && x.words) {\n            return Buffer.from(x.toString(CryptoJS.enc.Hex), 'hex');\n        }\n        else if (isHexStr(x)) {\n            return Buffer.from(x.replace(/^0x/, ''), 'hex');\n        }\n        else if (typeof x === 'string') {\n            return Buffer.from(x);\n        }\n    }\n    return x;\n}\nfunction bufferifyFn(f) {\n    return function (x) {\n        var v = f(x);\n        if (Buffer.isBuffer(v)) {\n            return v;\n        }\n        if (isHexStr(v)) {\n            return Buffer.from(v, 'hex');\n        }\n        // crypto-js support\n        return Buffer.from(f(CryptoJS.enc.Hex.parse(x.toString('hex'))).toString(CryptoJS.enc.Hex), 'hex');\n    };\n}\nfunction isHexStr(v) {\n    return (typeof v === 'string' && /^(0x)?[0-9A-Fa-f]*$/.test(v));\n}\nexports[\"default\"] = MerkleTree;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://Fabric/./node_modules/merkletreejs/dist/index.js?");
./assets/fabric.min.js:eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://Fabric/./node_modules/node-libs-browser/node_modules/buffer/index.js?");
./assets/fabric.min.js:eval("/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \"./node_modules/util-deprecate/browser.js\")\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\"), __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://Fabric/./node_modules/readable-stream/lib/_stream_writable.js?");
./assets/fabric.min.js:eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\n\nconst crypto = __webpack_require__(/*! crypto */ \"./node_modules/crypto-browserify/index.js\");\n\nconst Events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nconst Machine = __webpack_require__(/*! ./machine */ \"./types/machine.js\");\n\n/**\n * Live instance of an ARC in Fabric.\n * @type {Object}\n */\nclass Entity extends Events.EventEmitter {\n  /**\n   * Generic template for virtual objects.\n   * @param  {Object} [data={}] Pass an object to use.\n   * @return {Entity}           Instance of the {@link Entity}.\n   */\n  constructor (data = {}) {\n    super(data);\n\n    // allow this entity to be run without the new keyword\n    if (!(this instanceof Entity)) return new Entity(data);\n\n    // set internal properties\n    this.machine = new Machine();\n    this.settings = {\n      verbosity: 2 // Information && Warnings\n    };\n\n    // configure defaults\n    this.actor = Object.assign({}, this._downsample(data));\n    this.data = Object.assign({}, data);\n\n    // TODO: use getters/setters to restrict access to these elements\n    // remove EventEmitter cruft\n    Object.defineProperty(this, '_events', { enumerable: false });\n    Object.defineProperty(this, '_eventsCount', { enumerable: false });\n    Object.defineProperty(this, '_maxListeners', { enumerable: false });\n\n    // remove mutable variables\n    Object.defineProperty(this, 'actor', { enumerable: false });\n    Object.defineProperty(this, 'machine', { enumerable: false });\n\n    // return instance\n    return this;\n  }\n\n  get version () {\n    return 1;\n  }\n\n  set state (state) {\n    if (!state) throw new Error('State must be provided.');\n    this._state = state;\n  }\n\n  get state () {\n    return Object.assign({}, this._state);\n  }\n\n  get buffer () {\n    let entity = this;\n    return function buffer () {\n      return Buffer.from(entity.toJSON(), 'utf8');\n    }\n  }\n\n  get id () {\n    let data = this.toJSON();\n    let hash = crypto.createHash('sha256').update(data).digest('hex');\n    if (this.settings.verbosity >= 5) console.log('[FABRIC:ENTITY (pending upstream!)]', 'hash:', hash, 'data:', data);\n    return hash;\n  }\n\n  serialize () {\n    return this.toJSON();\n  }\n\n  toBuffer () {\n    return Buffer.from(this.toString(), 'utf8');\n  }\n\n  /**\n   * Produces a string of JSON, representing the entity.\n   * @return {String} JSON-encoded object.\n   */\n  toJSON () {\n    let result = null;\n\n    switch (this.actor['@type']) {\n      default:\n        result = JSON.stringify(this.toObject());\n        break;\n      case 'Buffer':\n      case 'String':\n        result = JSON.stringify(this.toString());\n        break;\n    }\n\n    return result;\n  }\n\n  toString () {\n    let result = null;\n\n    switch (this.actor['@type']) {\n      default:\n        result = JSON.stringify(this.actor['@data']);\n        break;\n      case 'Buffer':\n        const buffer = new Uint8Array(this.data);\n        const values = Object.values(this.data);\n        result = JSON.stringify(values);\n        break;\n      case 'String':\n        // TODO: write up longer-form explanation as to why we use an Array here\n        result = this.actor['@data'].map(x => String.fromCharCode(x)).join('');\n        // console.log('was string in array? now:', result);\n        break;\n    }\n\n    return result;\n  }\n\n  toObject () {\n    return this.actor['@data'];\n  }\n\n  /**\n   * As a {@link Buffer}.\n   * @return {Buffer} Slice of memory.\n   */\n  toRaw () {\n    return Buffer.from(this.toJSON(), 'utf8');\n  }\n\n  /**\n   * Return a {@link Fabric}-labeled {@link Object} for this {@link Entity}.\n   * @param {Mixed} [input] Input to downsample.  If not provided, current Entity will be used. \n   */\n  _downsample (input = this.data) {\n    let result = {};\n\n    if (typeof input === 'string') {\n      result = {\n        '@type': 'String',\n        '@data': input.split('').map(x => x.charCodeAt(0))\n      };\n    } else if (input instanceof Array) {\n      result = {\n        '@type': 'Array',\n        '@data': input\n      };\n    } else if (input instanceof Buffer) {\n      result = {\n        '@type': 'Buffer',\n        '@data': JSON.parse(JSON.stringify(input))[0]\n      };\n    } else {\n      try {\n        result = {\n          '@type': 'Entity',\n          '@data': JSON.parse(JSON.stringify(input))\n        };\n      } catch (E) {\n        console.log('Something could not be converted:', E, input);\n      }\n    }\n\n    return result;\n  }\n}\n\nmodule.exports = Entity;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://Fabric/./types/entity.js?");
./assets/fabric.min.js:eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\n\nconst crypto = __webpack_require__(/*! crypto */ \"./node_modules/crypto-browserify/index.js\");\n\n/**\n * Simple interaction with 256-bit spaces.\n */\nclass Hash256 {\n  /**\n   * Create an instance of a `Hash256` object by calling `new Hash256()`,\n   * where `settings` can be provided to supply a particular input object.\n   * \n   * If the `settings` is not a string, `input` must be provided.\n   * @param {Object} settings \n   * @param {String} settings.input Input string to map as 256-bit hash.\n   */\n  constructor (settings = {}) {\n    if (typeof settings === 'string') settings = { input: settings };\n    if (!settings.input) settings.input = crypto.randomBytes(32).toString('hex');\n\n    this.settings = Object.assign({\n      hash: Hash256.digest(settings.input)\n    }, settings);\n  }\n\n  /**\n   * Produce a SHA256 digest of some input data.\n   * @param {String|Buffer} input Content to digest.\n   * @returns {String} `SHA256(input)` as a hexadecimal string.\n   */\n  static digest (input) {\n    if (typeof input !== 'string' && !(input instanceof Buffer)) {\n      throw new Error(`Input to process must be of type \"String\" or \"Buffer\" to digest.`);\n    }\n\n    // consume and output as string\n    return crypto.createHash('sha256').update(input).digest('hex');\n  }\n\n  // TODO: document `hash256.value`\n  get value () {\n    return Hash256.digest(this.settings.input);\n  }\n}\n\nmodule.exports = Hash256;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://Fabric/./types/hash256.js?");
./assets/fabric.min.js:eval("\n\n// TODO: replace with bcoin\nconst Base58Check = __webpack_require__(/*! base58check */ \"./node_modules/base58check/index.js\");\n\n// Dependencies\nconst crypto = __webpack_require__(/*! crypto */ \"./node_modules/crypto-browserify/index.js\");\nconst EC = __webpack_require__(/*! elliptic */ \"./node_modules/elliptic/lib/elliptic.js\").ec;\nconst ec = new EC('secp256k1');\n\n// Dependencies\nconst bcoin = __webpack_require__(/*! bcoin */ \"./node_modules/bcoin/lib/bcoin.js\");\nconst {\n  KeyRing,\n  Mnemonic\n} = __webpack_require__(/*! bcoin */ \"./node_modules/bcoin/lib/bcoin.js\");\n\n// Fabric Types\nconst Entity = __webpack_require__(/*! ./entity */ \"./types/entity.js\");\n\n/**\n * Represents a cryptographic key.\n */\nclass Key extends Entity {\n  /**\n   * Create an instance of a Fabric Key, either restoring from some known\n   * values or from prior knowledge.  For instance, you can call `new Key()`\n   * to create a fresh keypair, or `new Key({ public: 'deadbeef...' })` to\n   * create it from a known public key.\n   * @param {Object} [settings] Initialization for the key.\n   * @param {String} [settings.network] Network string.\n   * @param {String} [settings.seed] Mnemonic seed for initializing the key.\n   * @param {String} [settings.public] Public key in hex.\n   * @param {String} [settings.private] Private key in hex.\n   */\n  constructor (init = {}) {\n    super(init);\n\n    this.config = Object.assign({\n      network: 'main',\n      prefix: '00',\n      public: null,\n      private: null,\n      hd: true\n    }, init);\n\n    this.master = null;\n    this.private = null;\n    this.public = null;\n\n    if (this.config.seed) {\n      // Seed provided, compute keys\n      let mnemonic = new bcoin.Mnemonic(this.config.seed);\n      let master = bcoin.hd.fromMnemonic(mnemonic);\n      let ring = new bcoin.KeyRing(master, this.config.network);\n\n      // Assign keys\n      this.master = master;\n      this.keypair = ec.keyFromPrivate(ring.getPrivateKey('hex'));\n      this.status = 'seeded';\n    } else if (this.config.private) {\n      // Key is private\n      this.keypair = ec.keyFromPrivate(this.config.private, 16);\n    } else if (this.config.pubkey || this.config.public) {\n      // Key is only public\n      let pubkey = this.config.pubkey || this.config.public;\n      this.keypair = ec.keyFromPublic(pubkey, 'hex');\n    } else {\n      // Generate new keys\n      this.keypair = ec.genKeyPair();\n    }\n\n    this.private = this.keypair.getPrivate();\n    this.public = this.keypair.getPublic(true);\n\n    // STANDARD BEGINS HERE\n    this.pubkey = this.public.encodeCompressed('hex');\n\n    // BELOW THIS NON-STANDARD\n    // DO NOT USE IN PRODUCTION\n    this.pubkeyhash = crypto.createHash('sha256').update(this.pubkey).digest('hex');\n\n    let input = `${this.config.prefix}${this.pubkeyhash}`;\n    let hash = crypto.createHash('sha256').update(input).digest('hex');\n    let safe = crypto.createHash('sha256').update(hash).digest('hex');\n    let checksum = safe.substring(0, 8);\n    let address = `${input}${checksum}`;\n\n    this.ripe = crypto.createHash('ripemd160').update(input).digest('hex');\n    this.address = Base58Check.encode(this.ripe);\n\n    this['@data'] = {\n      'type': 'Key',\n      'public': this.pubkey,\n      'address': this.address\n    };\n\n    Object.defineProperty(this, 'keypair', {\n      enumerable: false\n    });\n\n    Object.defineProperty(this, 'private', {\n      enumerable: false\n    });\n\n    return this;\n  }\n\n  static Mnemonic (seed) {\n    return new Mnemonic(seed);\n  }\n\n  get id () {\n    return this.pubkeyhash;\n  }\n\n  _sign (msg) {\n    // console.log(`[KEY] signing: ${msg}...`);\n    if (typeof msg !== 'string') msg = JSON.stringify(msg);\n    let hmac = crypto.createHash('sha256').update(msg).digest('hex');\n    let signature = this.keypair.sign(hmac);\n    // console.log(`[KEY] signature:`, signature);\n    return signature.toDER();\n  }\n\n  _verify (msg, sig) {\n    let hmac = crypto.createHash('sha256').update(msg).digest('hex');\n    let valid = this.keypair.verify(hmac, sig);\n    return valid;\n  }\n\n  derive (path = `m/44'/0'/0'/0/0`) {\n    if (!this.master) throw new Error('You cannot derive without a master key.  Provide a seed phrase.');\n    return this.master.derivePath(path);\n  }\n}\n\nmodule.exports = Key;\n\n\n//# sourceURL=webpack://Fabric/./types/key.js?");
./assets/fabric.min.js:eval("/* WEBPACK VAR INJECTION */(function(Buffer) { // commit (.) and continue (,) ⇒ ;\n\nconst crypto = __webpack_require__(/*! crypto */ \"./node_modules/crypto-browserify/index.js\");\nconst arbitrary = __webpack_require__(/*! arbitrary */ \"./node_modules/arbitrary/docs/dist/index.js\");\nconst monitor = __webpack_require__(/*! fast-json-patch */ \"./node_modules/fast-json-patch/lib/duplex.js\");\n\nconst Scribe = __webpack_require__(/*! ./scribe */ \"./types/scribe.js\");\nconst State = __webpack_require__(/*! ./state */ \"./types/state.js\");\nconst Vector = __webpack_require__(/*! ./vector */ \"./types/vector.js\");\n\n/**\n * General-purpose state machine with {@link Vector}-based instructions.\n */\nclass Machine extends Scribe {\n  /**\n   * Create a Machine.\n   * @param       {Object} config Run-time configuration.\n   */\n  constructor (config) {\n    super(config);\n\n    this.config = Object.assign({\n      path: './stores/machine',\n      debug: true,\n      deterministic: true,\n      seed: 1 // TODO: select seed for production\n    }, config);\n\n    this.clock = 0;\n\n    // define integer field\n    this.seed = crypto.createHash('sha256').update(this.config.seed + '');\n    this.q = parseInt(this.seed.digest('hex'));\n\n    // deterministic entropy and RNG\n    this.generator = new arbitrary.default.Generator(this.q);\n    this.entropy = this.sip();\n\n    this.known = {}; // definitions\n    this.script = []; // input\n    this.stack = []; // output\n\n    this.state = new State(); // JS map\n    this.history = []; // State tree\n\n    this.observer = monitor.observe(this.state['@data']);\n    this.vector = new Vector(this.state['@data']);\n\n    Object.defineProperty(this, 'tip', function (val) {\n      this.log(`tip requested: ${val}`);\n      this.log(`tip requested, history: ${JSON.stringify(this.history)}`);\n      return this.history[this.history.length - 1] || null;\n    });\n\n    return this;\n  }\n\n  /**\n   * Get `n` bits of entropy.\n   * @param  {Number} [n=32] Number of bits to retrieve (max = 32).\n   * @return {Number}        Random bits from {@link Generator}.\n   */\n  sip (n = 32) {\n    return this.generator.next.bits(n);\n  }\n\n  /**\n   * Computes the next \"step\" for our current Vector.  Analagous to `sum`.\n   * The top item on the stack is always the memory held at current position,\n   * so counts should always begin with 0.\n   * @param  {Vector} input - Input state, undefined if desired.\n   * @return {Promise}\n   */\n  async compute (input) {\n    ++this.clock;\n\n    this.emit('tick', this.clock);\n\n    for (let i in this.script) {\n      let instruction = this.script[i];\n\n      if (this.known[instruction]) {\n        let op = new State({\n          '@type': 'Cycle',\n          parent: this.id,\n          state: this.state,\n          known: this.known,\n          input: input\n        });\n        let data = this.known[instruction].call(op, input);\n        this.stack.push(data);\n      } else {\n        this.stack.push(instruction | 0);\n      }\n    }\n\n    if (this.stack.length > 1) {\n      this.warn('Stack is dirty:', this.stack);\n    }\n\n    this.state['@data'] = this.stack;\n    this.state['@id'] = this.id;\n\n    let commit = await this.commit();\n    let state = await this.state.commit();\n\n    return state;\n  }\n\n  asBuffer () {\n    let data = this.serialize(this.state['@data']);\n    return Buffer.from(data);\n  }\n\n  // register a local function\n  define (name, op) {\n    this.known[name] = op.bind(this);\n  }\n\n  applyOperation (op) {\n    monitor.applyOperation(this.state, op);\n  }\n\n  commit () {\n    let self = this;\n    if (!self.observer) return false;\n\n    let changes = monitor.generate(self.observer);\n\n    if (changes && changes.length) {\n      let vector = new State({\n        '@type': 'Change',\n        '@data': changes,\n        method: 'patch',\n        parent: self.id,\n        params: changes\n      });\n\n      if (!self.history) self.history = [];\n      self.history.push(vector);\n\n      self.emit('transaction', vector);\n    }\n\n    return changes;\n  }\n}\n\nmodule.exports = Machine;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://Fabric/./types/machine.js?");
./assets/fabric.min.js:eval("\n\nconst crypto = __webpack_require__(/*! crypto */ \"./node_modules/crypto-browserify/index.js\");\n\n// Fabric Components\nconst State = __webpack_require__(/*! ./state */ \"./types/state.js\");\n\n/**\n * Simple tag-based recordkeeper.\n * @extends State\n * @property {Object} config Current configuration.\n */\nclass Scribe extends State {\n  /**\n   * The \"Scribe\" is a simple tag-based recordkeeper.\n   * @param       {Object} config General configuration object.\n   * @param       {Boolean} config.verbose Should the Scribe be noisy?\n   */\n  constructor (config = {}) {\n    super(config);\n\n    // assign the defaults;\n    this.settings = this.config = Object.assign({\n      verbose: true,\n      verbosity: 2, // 0 none, 1 error, 2 warning, 3 notice, 4 debug\n      path: './stores/scribe',\n      tags: []\n    }, config);\n\n    // internal state\n    this._state = new State(config);\n\n    // signal ready\n    this.status = 'ready';\n\n    return this;\n  }\n\n  /** Retrives the current timestamp, in milliseconds.\n   * @return {Number} {@link Number} representation of the millisecond {@link Integer} value.\n   */\n  now () {\n    // return new Date().toISOString();\n    return new Date().getTime();\n  }\n\n  sha256 (data) {\n    return crypto.createHash('sha256').update(data).digest('hex');\n  }\n\n  _sign () {\n    this.commit();\n  }\n\n  /**\n   * Blindly bind event handlers to the {@link Source}.\n   * @param  {Source} source Event stream.\n   * @return {Scribe}        Instance of the {@link Scribe}.\n   */\n  trust (source) {\n    let self = this;\n\n    source.on('message', async function handleTrustedMessage (msg) {\n      // console.trace('[FABRIC:SCRIBE]', 'Our Scribe received the following message from a trusted source:', msg);\n    });\n\n    source.on('transaction', async function handleTrustedTransaction (transaction) {\n      self.log('[SCRIBE]', '[EVENT:TRANSACTION]', 'apply this transaction to local state:', transaction);\n      self.log('[PROPOSAL]', 'apply this transaction to local state:', transaction);\n    });\n\n    return self;\n  }\n\n  /**\n   * Use an existing Scribe instance as a parent.\n   * @param  {Scribe} scribe Instance of Scribe to use as parent.\n   * @return {Scribe}        The configured instance of the Scribe.\n   */\n  inherits (scribe) {\n    return this.tags.push(scribe.config.namespace);\n  }\n\n  log (...inputs) {\n    let now = this.now();\n\n    inputs.unshift(`[${this.constructor.name.toUpperCase()}]`);\n    inputs.unshift(`[${now}]`);\n\n    if (this.settings.verbosity >= 3) {\n      console.log.apply(null, ['[SCRIBE]'].concat(inputs));\n    }\n\n    return this.emit('info', ['[SCRIBE]'].concat(inputs));\n  }\n\n  error (...inputs) {\n    let now = this.now();\n\n    inputs.unshift(`[${this.constructor.name.toUpperCase()}]`);\n    inputs.unshift(`[${now}]`);\n\n    if (this.config.verbose) {\n      console.error.apply(null, ['[SCRIBE]'].concat(inputs));\n    }\n\n    return this.emit('error', ['[SCRIBE]'].concat(inputs));\n  }\n\n  warn (...inputs) {\n    let now = this.now();\n\n    inputs.unshift(`[${this.constructor.name.toUpperCase()}]`);\n    inputs.unshift(`[${now}]`);\n\n    if (this.config.verbose) {\n      console.warn.apply(null, ['[SCRIBE]'].concat(inputs));\n    }\n\n    return this.emit('warning', ['[SCRIBE]'].concat(inputs));\n  }\n\n  debug (...inputs) {\n    let now = this.now();\n\n    inputs.unshift(`[${this.constructor.name.toUpperCase()}]`);\n    inputs.unshift(`[${now}]`);\n\n    if (this.config.verbose) {\n      console.debug.apply(null, ['[SCRIBE]'].concat(inputs));\n    }\n\n    return this.emit('debug', ['[SCRIBE]'].concat(inputs));\n  }\n\n  async open () {\n    this.status = 'opened';\n    return this;\n  }\n\n  async close () {\n    this.status = 'closed';\n    return this;\n  }\n\n  async start () {\n    this.status = 'starting';\n    this['@data'] = this.config;\n\n    await this.open();\n    await this.commit();\n\n    // TODO: enable\n    // this.trust(this.state);\n\n    this.status = 'started';\n\n    return this;\n  }\n\n  async stop () {\n    this.status = 'stopping';\n    await this.close();\n    this.status = 'stopped';\n    return this;\n  }\n}\n\nmodule.exports = Scribe;\n\n\n//# sourceURL=webpack://Fabric/./types/scribe.js?");
./assets/fabric.min.js:eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\n\nconst {\n  MAX_MEMORY_ALLOC,\n  MAX_FRAME_SIZE\n} = __webpack_require__(/*! ../constants */ \"./constants.js\");\n\nconst State = __webpack_require__(/*! ./state */ \"./types/state.js\");\nconst { MerkleTree } = __webpack_require__(/*! merkletreejs */ \"./node_modules/merkletreejs/dist/index.js\");\n\n/**\n * Manage stacks of data.\n */\nclass Stack extends State {\n  /**\n   * Create a {@link Stack} instance.\n   * @param  {Array}  [list=[]] Genesis state for the {@link Stack} instance.\n   * @return {Stack}            Instance of the {@link Stack}.\n   */\n  constructor (list = []) {\n    super(list);\n\n    this.limit = MAX_MEMORY_ALLOC;\n    this.frame = Buffer.alloc(MAX_FRAME_SIZE);\n    this.config = list || [];\n\n    // Patch for new Collection inheritance\n    this.settings = Object.assign({\n      verbosity: 2\n    }, list);\n\n    this['@type'] = this.config['@type'];\n    this['@entity'].frames = {};\n    this['@entity'].states = {};\n    this['@states'] = {};\n    this['@data'] = [];\n\n    if (list instanceof Array) {\n      for (let i in list) {\n        this.push(list[i]);\n      }\n    }\n\n    this['@entity']['@type'] = this['@type'];\n    this['@entity']['@data'] = this['@data'];\n    this['@id'] = this.id;\n\n    return this;\n  }\n\n  get size () {\n    return this['@data'].length;\n  }\n\n  /**\n   * Push data onto the stack.  Changes the {@link Stack#frame} and\n   * {@link Stack#id}.\n   * @param  {Mixed} data Treated as a {@link State}.\n   * @return {Number}      Resulting size of the stack.\n   */\n  push (data) {\n    let state = new State(data);\n\n    this['@entity'].states[this.id] = this['@data'];\n    this['@entity'].states[state.id] = state['@data'];\n    this['@entity'].frames[this.id] = this['@data'];\n    this['@entity'].frames[state.id] = state['@data'];\n\n    // write the frame\n    // NOTE: no garbage collection\n    this.frame = Buffer.from(state.id);\n\n    // push frame onto stack\n    this['@data'].push(this.frame);\n    this['@type'] = 'Stack';\n    this['@size'] = this['@data'].length * MAX_FRAME_SIZE;\n\n    this.commit();\n\n    return this['@data'].length;\n  }\n\n  dedupe () {\n    return new Stack([...new Set(this.asArray())]);\n  }\n\n  pop () {\n    let element = this['@data'].pop();\n    return element;\n  }\n\n  asArray () {\n    return Array.from(this['@data']);\n  }\n\n  asMerkleTree () {\n    return new MerkleTree(this.asArray(), this.sha256, {\n      isBitcoinTree: true\n    });\n  }\n\n  snapshot () {\n    return this.id || { '@id': `${this.sha256(this.state['@data'])}` };\n  }\n\n  commit () {\n    let stack = this;\n    let changes = super.commit();\n\n    if (changes.length) {\n      let data = Object.assign({}, {\n        parent: stack.tip,\n        changes: changes\n      });\n\n      stack.state['@data'] = data;\n      stack.history.push(stack.state.id);\n    }\n\n    // TODO: return Transaction\n    return changes;\n  }\n}\n\nmodule.exports = Stack;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://Fabric/./types/stack.js?");
./assets/fabric.min.js:eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\n\nconst {\n  MAX_MESSAGE_SIZE\n} = __webpack_require__(/*! ../constants */ \"./constants.js\");\n\nconst crypto = __webpack_require__(/*! crypto */ \"./node_modules/crypto-browserify/index.js\");\nconst monitor = __webpack_require__(/*! fast-json-patch */ \"./node_modules/fast-json-patch/lib/duplex.js\");\nconst pointer = __webpack_require__(/*! json-pointer */ \"./node_modules/json-pointer/index.js\");\nconst EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\n/**\n * The {@link State} is the core of most {@link User}-facing interactions.  To\n * interact with the {@link User}, simply propose a change in the state by\n * committing to the outcome.  This workflow keeps app design quite simple!\n * @augments EventEmitter\n * @property {Number} size Size of state in bytes.\n * @property {Buffer} @buffer Byte-for-byte memory representation of state.\n * @property {String} @type Named type.\n * @property {Mixed} @data Local instance of the state.\n * @property {String} @id Unique identifier for this data.\n */\nclass State extends EventEmitter {\n  /**\n   * Creates a snapshot of some information.\n   * @param  {Mixed} data Input data.\n   * @return {State}      Resulting state.\n   */\n  constructor (data = {}) {\n    super(data);\n\n    this['@version'] = 0x01;\n    this['@input'] = data || null;\n    this['@data'] = data || {};\n    this['@meta'] = {};\n    this['@encoding'] = 'json';\n\n    // Literal Entity Structure\n    this['@entity'] = {\n      '@type': 'State',\n      '@data': data\n    };\n\n    // TODO: test and document memory alignment\n    // this['@buffer'] = Buffer.alloc(Constants.MAX_MESSAGE_SIZE);\n    this['@allocation'] = Buffer.alloc(MAX_MESSAGE_SIZE);\n    this['@buffer'] = Buffer.from(this.serialize(this['@entity']['@data']));\n\n    // if not destined to be an object...\n    if (typeof this['@data'] === 'string') {\n      this['@entity']['@type'] = 'String';\n      this['@entity']['@data'] = this['@data'].split('').map(x => x.charCodeAt(0));\n    } else if (this['@data'] instanceof Array) {\n      this['@entity']['@type'] = 'Array';\n    } else if (this['@data'] instanceof Buffer) {\n      this['@entity']['@type'] = 'Buffer';\n    } else if (\n      this['@data'] &&\n      this['@data']['@type'] &&\n      this['@data']['@data']\n    ) {\n      switch (this['@data']['@type']) {\n        default:\n          this['@entity']['@type'] = this['@data']['@type'];\n          this['@entity']['@data'] = this['@data']['@data'];\n          break;\n      }\n    } else {\n      this['@entity']['@type'] = 'Object';\n      this['@entity']['@data'] = data;\n    }\n\n    Object.defineProperty(this, `size`, {\n      enumerable: true,\n      get: function count () {\n        return this['@buffer'].length;\n      }\n    });\n\n    Object.defineProperty(this, 'domain', {\n      enumerable: false\n    });\n\n    Object.defineProperty(this, '_events', {\n      enumerable: false\n    });\n\n    Object.defineProperty(this, '_eventsCount', {\n      enumerable: false\n    });\n\n    Object.defineProperty(this, '_maxListeners', {\n      enumerable: false\n    });\n\n    // start at zero\n    this.clock = 0;\n\n    // set various #meta\n    this['@type'] = this['@entity']['@type'];\n    // this['@id'] = null;\n    // this['@id'] = this.id;\n\n    // set internal data\n    this.services = ['json'];\n    // TODO: re-enable\n    // this.name = this['@entity'].name || this.id;\n    this.link = `/entities/${this.fingerprint()}`;\n\n    if (this['@entity']['@data']) {\n      try {\n        this.observer = monitor.observe(this['@entity']['@data']);\n      } catch (E) {\n        console.error('Could not create observer:', E, this['@entity']['@data']);\n      }\n    }\n\n    this.value = {};\n\n    // TODO: document hidden properties\n    // Remove various undesired clutter from output\n    Object.defineProperty(this, '@allocation', { enumerable: false });\n    Object.defineProperty(this, '@buffer', { enumerable: false });\n    Object.defineProperty(this, '@encoding', { enumerable: false });\n    Object.defineProperty(this, 'services', { enumerable: false });\n\n    return this;\n  }\n\n  static get pointer () {\n    return pointer;\n  }\n\n  /**\n   * Identity function.\n   * @type {Boolean}\n   */\n  get id () {\n    return this.fingerprint();\n  }\n\n  get state () {\n    return this.value;\n    // TODO: re-enable the below, map security considerations\n    // return Object.assign({}, this.value);\n  }\n\n  set state (value) {\n    this.value = value;\n  }\n\n  /**\n   * Marshall an input into an instance of a {@link State}.  States have\n   * absolute authority over their own domain, so choose your States wisely.\n   * @param  {String} input Arbitrary input.\n   * @return {State}       Resulting instance of the {@link State}.\n   */\n  static fromJSON (input) {\n    if (typeof input !== 'string') return null;\n\n    let result = null;\n\n    try {\n      result = JSON.parse(input);\n    } catch (E) {\n      console.error('Failure in fromJSON:', E);\n    }\n\n    return result;\n  }\n\n  static fromHex (input) {\n    if (typeof input !== 'string') return null;\n    return this.fromJSON(Buffer.from(input, 'hex').toString('utf8'));\n  }\n\n  static fromString (input) {\n    if (typeof input !== 'string') return null;\n    return this.fromJSON(input);\n  }\n\n  async _getState () {\n    let self = this;\n    let results = await Promise.all([\n      async function () {\n        return self.value;\n      }\n    ]).then(([\n      state\n    ]) => {\n      return {\n        state\n      };\n    }).catch(e => console.error(e));\n\n    return results;\n  }\n\n  sha256 (value) {\n    return crypto.createHash('sha256').update(value).digest('hex');\n  }\n\n  async _applyChanges (ops) {\n    try {\n      monitor.applyPatch(this['@data'], ops);\n\n      await this.commit();\n    } catch (E) {\n      this.error('Error applying changes:', E);\n    }\n\n    return this;\n  }\n\n  fingerprint () {\n    let map = {};\n    map['@method'] = 'sha256';\n    map['@input'] = this.serialize(this['@entity']['@data']);\n    map['@buffer'] = crypto.createHash('sha256').update(map['@input'], 'utf8');\n    map['@output'] = map['@buffer'].digest('hex');\n    return map['@output'];\n  }\n\n  isRoot () {\n    return this['@parent'] === this.id;\n  }\n\n  toBuffer () {\n    if (this['@data'] instanceof Buffer) return this['@data'];\n    if (this['@data']) return this.serialize();\n\n    return Buffer.from(this['@data']['@data']);\n  }\n\n  toHTML () {\n    let state = this;\n    let solution = state['@output'].toString('utf8');\n    let confirmed = String(solution);\n    let raw = `X-Claim-ID: ${this.id}\nX-Claim-Integrity: sha256\nX-Claim-Type: Response\nX-Claim-Result: ${state.id}\nBody:\n# STOP!\nHere is your opportunity to read the documentation: https://dev.fabric.pub\n\nDocument ID: ${this.id}\nDocument Type (local JSON): ${this.constructor.name}\nDocument Path: ${this.path}\nDocument Name: ${this.name}\nDocument Integrity: sha256:${this.id}\nDocument Data (local JSON): ${confirmed}\nDocument Source:\n\\`\\`\\`\n${confirmed}\n\\`\\`\\`\n\n## Source Code\n### Free as in _freedom_.\nLabs: https://github.com/FabricLabs\n\nTo edit this message, visit this URL: https://github.com/FabricLabs/fabric/edit/master/types/state.js\n\n## Onboarding\nWhen you're ready to continue, visit the following URL: https://dev.fabric.pub/WELCOME.html\n`;\n\n    return raw;\n  }\n\n  /**\n   * Unmarshall an existing state to an instance of a {@link Blob}.\n   * @return {String} Serialized {@link Blob}.\n   */\n  toString () {\n    return this.serialize();\n  }\n\n  overlay (data) {\n    let state = new State(data);\n    this['@parent'] = this['@id'];\n    this['@data'] = Object.assign({}, this['@data'], state['@data']);\n    this['@did'] = `did:fabric:${this.id}`;\n    this['@id'] = this.id;\n    return this;\n  }\n\n  pack (data) {\n    if (!data) data = this['@data'];\n    return JSON.stringify(data);\n  }\n\n  /**\n   * Convert to {@link Buffer}.\n   * @param  {Mixed} [input] Input to serialize.\n   * @return {Buffer}       {@link Store}-able blob.\n   */\n  serialize (input, encoding = 'json') {\n    if (!input) input = this['@data'];\n\n    let result = null;\n    let state = {};\n\n    if (typeof input === 'string') {\n      result = Buffer.from(`${JSON.stringify(input)}`, 'utf8');\n    } else if (input instanceof Array) {\n      result = Buffer.from(`${JSON.stringify(input)}`, 'utf8');\n    } else if (input instanceof Buffer) {\n      result = input;\n    } else if (input['@type'] && input['@data']) {\n      return this.serialize(input['@data']);\n    } else {\n      switch (input.constructor.name) {\n        default:\n          result = input.toString('utf8');\n          break;\n        case 'Function':\n          result = Buffer.from(input.toString('utf8'));\n          break;\n        case 'Boolean':\n          result = Buffer.from(JSON.stringify(input));\n          break;\n        case 'Buffer':\n          result = Buffer.from(JSON.stringify(input.toString('utf8')));\n          break;\n        case 'Object':\n          result = Buffer.from(JSON.stringify(input));\n      }\n\n      // strip special fields\n      // TODO: order?\n      for (let name in input) {\n        if (name.charAt(0) === '@') {\n          continue;\n        } else {\n          state[name] = input[name];\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Take a hex-encoded input and convert to a {@link State} object.\n   * @param  {String} input [description]\n   * @return {State}       [description]\n   */\n  deserialize (input) {\n    let output = null;\n\n    if (typeof input === 'string') {\n      // Let's create a state object...\n      try {\n        let state = new State(input);\n        // Assign our output to the state data\n        output = state['@data'];\n      } catch (E) {\n        this.error('Could not parse string as Buffer:', E);\n      }\n\n      return output;\n    } else {\n      this.log('WARNING:', `input not a string`, input);\n    }\n\n    if (!output) return null;\n\n    switch (output['@type']) {\n      case 'String':\n        output = output['@buffer'].toString(output['@encoding']);\n        break;\n    }\n\n    return output;\n  }\n\n  flatten () {\n    let map = {};\n\n    for (let k in this['@data']) {\n      map[k] = this.serialize(this['@data'][k]);\n    }\n\n    return map;\n  }\n\n  /**\n   * Creates a new child {@link State}, with `@parent` set to\n   * the current {@link State} by immutable identifier.\n   * @returns {State}\n   */\n  fork () {\n    let data = Object.assign({\n      '@parent': this.id\n    }, this['@data']);\n    return new State(data);\n  }\n\n  /**\n   * Retrieve a key from the {@link State}.\n   * @param {Path} path Key to retrieve.\n   * @returns {Mixed}\n   */\n  get (path) {\n    // return pointer.get(this.state, path);\n    let result = null;\n    try {\n      result = pointer.get(this['@entity']['@data'], path);\n    } catch (exception) {\n      console.error('[FABRIC:STATE]', 'Could not retrieve path:', path, pointer.get(this['@entity']['@data'], '/'), exception);\n    }\n    return result;\n  }\n\n  /**\n   * Set a key in the {@link State} to a particular value.\n   * @param {Path} path Key to retrieve.\n   * @returns {Mixed}\n   */\n  set (path, value) {\n    // console.log('setting:', path, value);\n    pointer.set(this.value, path, value);\n    pointer.set(this['@entity']['@data'], path, value);\n    let result = pointer.set(this.value, path, value);\n    this.commit();\n    return result;\n  }\n\n  /**\n   * Increment the vector clock, broadcast all changes as a transaction.\n   */\n  commit () {\n    ++this.clock;\n\n    this['@parent'] = this.id;\n    this['@preimage'] = this.toString();\n    this['@constructor'] = this.constructor;\n\n    if (this.observer) {\n      this['@changes'] = monitor.generate(this.observer);\n    }\n\n    this['@id'] = this.id;\n\n    if (this['@changes'] && this['@changes'].length) {\n      this.emit('changes', this['@changes']);\n      this.emit('state', this['@state']);\n      this.emit('message', {\n        '@type': 'Transaction',\n        '@data': {\n          'changes': this['@changes'],\n          'state': this['@changes']\n        }\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Compose a JSON string for network consumption.\n   * @return {String} JSON-encoded {@link String}.\n   */\n  render () {\n    this['@id'] = this.id;\n    this['@encoding'] = 'json';\n    this['@output'] = this.serialize(this['@entity']['@data'], 'json');\n    this['@commit'] = this.commit();\n\n    switch (this['@type']) {\n      default:\n        return this['@output'].toString('utf8');\n    }\n  }\n}\n\nmodule.exports = State;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://Fabric/./types/state.js?");
./assets/fabric.min.js:eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\n\nconst Scribe = __webpack_require__(/*! ./scribe */ \"./types/scribe.js\");\nconst Stack = __webpack_require__(/*! ./stack */ \"./types/stack.js\");\n\nclass Vector extends Scribe {\n  /**\n   * An \"Initialization\" Vector.\n   * @param       {Object} - Input state (will map to `@data`.)\n   * @constructor\n   */\n  constructor (origin) {\n    super(origin);\n\n    this.config = Object.assign({}, origin);\n\n    this.known = {};\n    this.registry = {};\n\n    this.stack = new Stack();\n    this.script = [];\n\n    this.status = 'initialized';\n\n    return this;\n  }\n\n  static fromObjectString (input) {\n    let result = [];\n    let object = JSON.parse(input);\n\n    for (let i in object) {\n      let element = object[i];\n\n      if (element instanceof Array) {\n        element = Buffer.from(element);\n      } else {\n        element = Buffer.from(element.data);\n      }\n\n      result.push(element);\n    }\n\n    return result;\n  }\n\n  /**\n   * _serialize is a placeholder, should be discussed.\n   * @param {String} input - What to serialize.  Defaults to `this.state`.\n   * @return {String} - resulting string [JSON-encoded version of the local `@data` value.]\n   */\n  _serialize (input) {\n    return this.toString(input);\n  }\n\n  _deserialize (input) {\n    return this.fromString(input);\n  }\n\n  // TODO: standardize on a serialization format\n  fromString (input) {\n    return JSON.parse(input);\n  }\n\n  toObject () {\n    let object = {};\n    for (let property in this['@data']) {\n      if (property.charAt(0) !== '@') {\n        object[property] = this['@data'][property];\n      }\n    }\n    return object;\n  }\n\n  /**\n   * Render the output to a {@link String}.\n   * @param  {Mixed} input Arbitrary input.\n   * @return {String}\n   */\n  toString (input) {\n    if (!input) input = this.state;\n    // TODO: standardize on a serialization format\n    return JSON.stringify(input);\n  }\n\n  validate (input) {\n    return true;\n  }\n\n  async step () {\n    return super.compute((this.clock | 0));\n  }\n}\n\nmodule.exports = Vector;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://Fabric/./types/vector.js?");
./GOALS.md:- [ ] Find all TODO items (run script, check diff)
./services/bitcoin.js:      // httpPort: 48449, // TODO: disable HTTP entirely!
./services/bitcoin.js:    // TODO: ensure all appropriate fields, valid block
./services/bitcoin.js:    // TODO: verify local hash (see below)
./services/bitcoin.js:      // TODO: verify block hash!!!
./services/bitcoin.js:      // TODO: enable sharing of local hashes
./services/bitcoin.js:      // TODO: fix @types/wallet to use named types for Addresses...
./services/bitcoin.js:    // TODO: listen for sync finalization
./services/bitcoin.js:    // TODO: test and verify append() on chain length 0 sets genesis
./services/bitcoin.js:      // TODO: subscribe to this event in CLI
./services/bitcoin.js:      // TODO: loop through all providers
./services/bitcoin.js:      // TODO: cleanup
./services/bitcoin.js:    // TODO: re-enable these
./services/bitcoin.js:    // TODO: re-enable SPV
./services/bitcoin.js:    // END TODO
./services/bitcoin.js:      // TODO: refactor Chain
./services/turntable.js:    // TODO: await REST or GraphQL API?
./services/exchange.js:    // TODO: finalize Collection API in #docs-update
./services/matrix.js:// TODO: compare API against {@link Service}
./services/matrix.js:  // TODO: supply at least 7 coordinators
./services/matrix.js:    // TODO: remove old use of `@data` while internal to Fabric
./services/ethereum.js:// TODO: re-evaluate inclusion of Ethereum toolchain
./services/ethereum.js:      // TODO: loop through all providers
./services/lightning.js:      // TODO: loop through all providers
./services/lightning.js:      // TODO: loop through all providers
./whitepaper.md:TODO
./whitepaper.md:TODO: include content hashes of links as they appear at
